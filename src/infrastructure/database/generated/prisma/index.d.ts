
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model bancos
 * 
 */
export type bancos = $Result.DefaultSelection<Prisma.$bancosPayload>
/**
 * Model configuracao
 * 
 */
export type configuracao = $Result.DefaultSelection<Prisma.$configuracaoPayload>
/**
 * Model consultas
 * 
 */
export type consultas = $Result.DefaultSelection<Prisma.$consultasPayload>
/**
 * Model consultasoffline
 * 
 */
export type consultasoffline = $Result.DefaultSelection<Prisma.$consultasofflinePayload>
/**
 * Model consultasofflinesiape
 * 
 */
export type consultasofflinesiape = $Result.DefaultSelection<Prisma.$consultasofflinesiapePayload>
/**
 * Model credito
 * 
 */
export type credito = $Result.DefaultSelection<Prisma.$creditoPayload>
/**
 * Model desbloqueios
 * 
 */
export type desbloqueios = $Result.DefaultSelection<Prisma.$desbloqueiosPayload>
/**
 * Model entrantesinss
 * 
 */
export type entrantesinss = $Result.DefaultSelection<Prisma.$entrantesinssPayload>
/**
 * Model especiebeneficio
 * 
 */
export type especiebeneficio = $Result.DefaultSelection<Prisma.$especiebeneficioPayload>
/**
 * Model extratooffline
 * 
 */
export type extratooffline = $Result.DefaultSelection<Prisma.$extratoofflinePayload>
/**
 * Model extratoonline
 * 
 */
export type extratoonline = $Result.DefaultSelection<Prisma.$extratoonlinePayload>
/**
 * Model fornecedor
 * 
 */
export type fornecedor = $Result.DefaultSelection<Prisma.$fornecedorPayload>
/**
 * Model fornecedorservico
 * 
 */
export type fornecedorservico = $Result.DefaultSelection<Prisma.$fornecedorservicoPayload>
/**
 * Model historicoconsultaapi
 * 
 */
export type historicoconsultaapi = $Result.DefaultSelection<Prisma.$historicoconsultaapiPayload>
/**
 * Model historicocredito
 * 
 */
export type historicocredito = $Result.DefaultSelection<Prisma.$historicocreditoPayload>
/**
 * Model in100
 * 
 */
export type in100 = $Result.DefaultSelection<Prisma.$in100Payload>
/**
 * Model logins
 * 
 */
export type logins = $Result.DefaultSelection<Prisma.$loginsPayload>
/**
 * Model menu
 * 
 */
export type menu = $Result.DefaultSelection<Prisma.$menuPayload>
/**
 * Model modulos
 * 
 */
export type modulos = $Result.DefaultSelection<Prisma.$modulosPayload>
/**
 * Model perfil_modulo
 * 
 */
export type perfil_modulo = $Result.DefaultSelection<Prisma.$perfil_moduloPayload>
/**
 * Model perfilusuario
 * 
 */
export type perfilusuario = $Result.DefaultSelection<Prisma.$perfilusuarioPayload>
/**
 * Model senhas
 * 
 */
export type senhas = $Result.DefaultSelection<Prisma.$senhasPayload>
/**
 * Model situacao
 * 
 */
export type situacao = $Result.DefaultSelection<Prisma.$situacaoPayload>
/**
 * Model situacaosolicsenha
 * 
 */
export type situacaosolicsenha = $Result.DefaultSelection<Prisma.$situacaosolicsenhaPayload>
/**
 * Model statussolicitacaoservico
 * 
 */
export type statussolicitacaoservico = $Result.DefaultSelection<Prisma.$statussolicitacaoservicoPayload>
/**
 * Model tiposervico
 * 
 */
export type tiposervico = $Result.DefaultSelection<Prisma.$tiposervicoPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Bancos
 * const bancos = await prisma.bancos.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Bancos
   * const bancos = await prisma.bancos.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.bancos`: Exposes CRUD operations for the **bancos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bancos
    * const bancos = await prisma.bancos.findMany()
    * ```
    */
  get bancos(): Prisma.bancosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configuracao`: Exposes CRUD operations for the **configuracao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configuracaos
    * const configuracaos = await prisma.configuracao.findMany()
    * ```
    */
  get configuracao(): Prisma.configuracaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consultas`: Exposes CRUD operations for the **consultas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consultas
    * const consultas = await prisma.consultas.findMany()
    * ```
    */
  get consultas(): Prisma.consultasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consultasoffline`: Exposes CRUD operations for the **consultasoffline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consultasofflines
    * const consultasofflines = await prisma.consultasoffline.findMany()
    * ```
    */
  get consultasoffline(): Prisma.consultasofflineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consultasofflinesiape`: Exposes CRUD operations for the **consultasofflinesiape** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consultasofflinesiapes
    * const consultasofflinesiapes = await prisma.consultasofflinesiape.findMany()
    * ```
    */
  get consultasofflinesiape(): Prisma.consultasofflinesiapeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.credito`: Exposes CRUD operations for the **credito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Creditos
    * const creditos = await prisma.credito.findMany()
    * ```
    */
  get credito(): Prisma.creditoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.desbloqueios`: Exposes CRUD operations for the **desbloqueios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Desbloqueios
    * const desbloqueios = await prisma.desbloqueios.findMany()
    * ```
    */
  get desbloqueios(): Prisma.desbloqueiosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.entrantesinss`: Exposes CRUD operations for the **entrantesinss** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entrantesinsses
    * const entrantesinsses = await prisma.entrantesinss.findMany()
    * ```
    */
  get entrantesinss(): Prisma.entrantesinssDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.especiebeneficio`: Exposes CRUD operations for the **especiebeneficio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Especiebeneficios
    * const especiebeneficios = await prisma.especiebeneficio.findMany()
    * ```
    */
  get especiebeneficio(): Prisma.especiebeneficioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.extratooffline`: Exposes CRUD operations for the **extratooffline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Extratoofflines
    * const extratoofflines = await prisma.extratooffline.findMany()
    * ```
    */
  get extratooffline(): Prisma.extratoofflineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.extratoonline`: Exposes CRUD operations for the **extratoonline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Extratoonlines
    * const extratoonlines = await prisma.extratoonline.findMany()
    * ```
    */
  get extratoonline(): Prisma.extratoonlineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fornecedor`: Exposes CRUD operations for the **fornecedor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fornecedors
    * const fornecedors = await prisma.fornecedor.findMany()
    * ```
    */
  get fornecedor(): Prisma.fornecedorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fornecedorservico`: Exposes CRUD operations for the **fornecedorservico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fornecedorservicos
    * const fornecedorservicos = await prisma.fornecedorservico.findMany()
    * ```
    */
  get fornecedorservico(): Prisma.fornecedorservicoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.historicoconsultaapi`: Exposes CRUD operations for the **historicoconsultaapi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historicoconsultaapis
    * const historicoconsultaapis = await prisma.historicoconsultaapi.findMany()
    * ```
    */
  get historicoconsultaapi(): Prisma.historicoconsultaapiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.historicocredito`: Exposes CRUD operations for the **historicocredito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historicocreditos
    * const historicocreditos = await prisma.historicocredito.findMany()
    * ```
    */
  get historicocredito(): Prisma.historicocreditoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.in100`: Exposes CRUD operations for the **in100** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more In100s
    * const in100s = await prisma.in100.findMany()
    * ```
    */
  get in100(): Prisma.in100Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.logins`: Exposes CRUD operations for the **logins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logins
    * const logins = await prisma.logins.findMany()
    * ```
    */
  get logins(): Prisma.loginsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menu`: Exposes CRUD operations for the **menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menus
    * const menus = await prisma.menu.findMany()
    * ```
    */
  get menu(): Prisma.menuDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modulos`: Exposes CRUD operations for the **modulos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modulos
    * const modulos = await prisma.modulos.findMany()
    * ```
    */
  get modulos(): Prisma.modulosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.perfil_modulo`: Exposes CRUD operations for the **perfil_modulo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Perfil_modulos
    * const perfil_modulos = await prisma.perfil_modulo.findMany()
    * ```
    */
  get perfil_modulo(): Prisma.perfil_moduloDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.perfilusuario`: Exposes CRUD operations for the **perfilusuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Perfilusuarios
    * const perfilusuarios = await prisma.perfilusuario.findMany()
    * ```
    */
  get perfilusuario(): Prisma.perfilusuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.senhas`: Exposes CRUD operations for the **senhas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Senhas
    * const senhas = await prisma.senhas.findMany()
    * ```
    */
  get senhas(): Prisma.senhasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.situacao`: Exposes CRUD operations for the **situacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Situacaos
    * const situacaos = await prisma.situacao.findMany()
    * ```
    */
  get situacao(): Prisma.situacaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.situacaosolicsenha`: Exposes CRUD operations for the **situacaosolicsenha** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Situacaosolicsenhas
    * const situacaosolicsenhas = await prisma.situacaosolicsenha.findMany()
    * ```
    */
  get situacaosolicsenha(): Prisma.situacaosolicsenhaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.statussolicitacaoservico`: Exposes CRUD operations for the **statussolicitacaoservico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Statussolicitacaoservicos
    * const statussolicitacaoservicos = await prisma.statussolicitacaoservico.findMany()
    * ```
    */
  get statussolicitacaoservico(): Prisma.statussolicitacaoservicoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tiposervico`: Exposes CRUD operations for the **tiposervico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tiposervicos
    * const tiposervicos = await prisma.tiposervico.findMany()
    * ```
    */
  get tiposervico(): Prisma.tiposervicoDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    bancos: 'bancos',
    configuracao: 'configuracao',
    consultas: 'consultas',
    consultasoffline: 'consultasoffline',
    consultasofflinesiape: 'consultasofflinesiape',
    credito: 'credito',
    desbloqueios: 'desbloqueios',
    entrantesinss: 'entrantesinss',
    especiebeneficio: 'especiebeneficio',
    extratooffline: 'extratooffline',
    extratoonline: 'extratoonline',
    fornecedor: 'fornecedor',
    fornecedorservico: 'fornecedorservico',
    historicoconsultaapi: 'historicoconsultaapi',
    historicocredito: 'historicocredito',
    in100: 'in100',
    logins: 'logins',
    menu: 'menu',
    modulos: 'modulos',
    perfil_modulo: 'perfil_modulo',
    perfilusuario: 'perfilusuario',
    senhas: 'senhas',
    situacao: 'situacao',
    situacaosolicsenha: 'situacaosolicsenha',
    statussolicitacaoservico: 'statussolicitacaoservico',
    tiposervico: 'tiposervico'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "bancos" | "configuracao" | "consultas" | "consultasoffline" | "consultasofflinesiape" | "credito" | "desbloqueios" | "entrantesinss" | "especiebeneficio" | "extratooffline" | "extratoonline" | "fornecedor" | "fornecedorservico" | "historicoconsultaapi" | "historicocredito" | "in100" | "logins" | "menu" | "modulos" | "perfil_modulo" | "perfilusuario" | "senhas" | "situacao" | "situacaosolicsenha" | "statussolicitacaoservico" | "tiposervico"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      bancos: {
        payload: Prisma.$bancosPayload<ExtArgs>
        fields: Prisma.bancosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bancosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bancosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bancosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bancosPayload>
          }
          findFirst: {
            args: Prisma.bancosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bancosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bancosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bancosPayload>
          }
          findMany: {
            args: Prisma.bancosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bancosPayload>[]
          }
          create: {
            args: Prisma.bancosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bancosPayload>
          }
          createMany: {
            args: Prisma.bancosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bancosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bancosPayload>
          }
          update: {
            args: Prisma.bancosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bancosPayload>
          }
          deleteMany: {
            args: Prisma.bancosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bancosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bancosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bancosPayload>
          }
          aggregate: {
            args: Prisma.BancosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBancos>
          }
          groupBy: {
            args: Prisma.bancosGroupByArgs<ExtArgs>
            result: $Utils.Optional<BancosGroupByOutputType>[]
          }
          count: {
            args: Prisma.bancosCountArgs<ExtArgs>
            result: $Utils.Optional<BancosCountAggregateOutputType> | number
          }
        }
      }
      configuracao: {
        payload: Prisma.$configuracaoPayload<ExtArgs>
        fields: Prisma.configuracaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.configuracaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configuracaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.configuracaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configuracaoPayload>
          }
          findFirst: {
            args: Prisma.configuracaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configuracaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.configuracaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configuracaoPayload>
          }
          findMany: {
            args: Prisma.configuracaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configuracaoPayload>[]
          }
          create: {
            args: Prisma.configuracaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configuracaoPayload>
          }
          createMany: {
            args: Prisma.configuracaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.configuracaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configuracaoPayload>
          }
          update: {
            args: Prisma.configuracaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configuracaoPayload>
          }
          deleteMany: {
            args: Prisma.configuracaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.configuracaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.configuracaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configuracaoPayload>
          }
          aggregate: {
            args: Prisma.ConfiguracaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfiguracao>
          }
          groupBy: {
            args: Prisma.configuracaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfiguracaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.configuracaoCountArgs<ExtArgs>
            result: $Utils.Optional<ConfiguracaoCountAggregateOutputType> | number
          }
        }
      }
      consultas: {
        payload: Prisma.$consultasPayload<ExtArgs>
        fields: Prisma.consultasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consultasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consultasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload>
          }
          findFirst: {
            args: Prisma.consultasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consultasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload>
          }
          findMany: {
            args: Prisma.consultasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload>[]
          }
          create: {
            args: Prisma.consultasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload>
          }
          createMany: {
            args: Prisma.consultasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.consultasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload>
          }
          update: {
            args: Prisma.consultasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload>
          }
          deleteMany: {
            args: Prisma.consultasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consultasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.consultasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasPayload>
          }
          aggregate: {
            args: Prisma.ConsultasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultas>
          }
          groupBy: {
            args: Prisma.consultasGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultasGroupByOutputType>[]
          }
          count: {
            args: Prisma.consultasCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultasCountAggregateOutputType> | number
          }
        }
      }
      consultasoffline: {
        payload: Prisma.$consultasofflinePayload<ExtArgs>
        fields: Prisma.consultasofflineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consultasofflineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consultasofflineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinePayload>
          }
          findFirst: {
            args: Prisma.consultasofflineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consultasofflineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinePayload>
          }
          findMany: {
            args: Prisma.consultasofflineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinePayload>[]
          }
          create: {
            args: Prisma.consultasofflineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinePayload>
          }
          createMany: {
            args: Prisma.consultasofflineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.consultasofflineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinePayload>
          }
          update: {
            args: Prisma.consultasofflineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinePayload>
          }
          deleteMany: {
            args: Prisma.consultasofflineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consultasofflineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.consultasofflineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinePayload>
          }
          aggregate: {
            args: Prisma.ConsultasofflineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultasoffline>
          }
          groupBy: {
            args: Prisma.consultasofflineGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultasofflineGroupByOutputType>[]
          }
          count: {
            args: Prisma.consultasofflineCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultasofflineCountAggregateOutputType> | number
          }
        }
      }
      consultasofflinesiape: {
        payload: Prisma.$consultasofflinesiapePayload<ExtArgs>
        fields: Prisma.consultasofflinesiapeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consultasofflinesiapeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinesiapePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consultasofflinesiapeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinesiapePayload>
          }
          findFirst: {
            args: Prisma.consultasofflinesiapeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinesiapePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consultasofflinesiapeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinesiapePayload>
          }
          findMany: {
            args: Prisma.consultasofflinesiapeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinesiapePayload>[]
          }
          create: {
            args: Prisma.consultasofflinesiapeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinesiapePayload>
          }
          createMany: {
            args: Prisma.consultasofflinesiapeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.consultasofflinesiapeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinesiapePayload>
          }
          update: {
            args: Prisma.consultasofflinesiapeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinesiapePayload>
          }
          deleteMany: {
            args: Prisma.consultasofflinesiapeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consultasofflinesiapeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.consultasofflinesiapeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consultasofflinesiapePayload>
          }
          aggregate: {
            args: Prisma.ConsultasofflinesiapeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultasofflinesiape>
          }
          groupBy: {
            args: Prisma.consultasofflinesiapeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultasofflinesiapeGroupByOutputType>[]
          }
          count: {
            args: Prisma.consultasofflinesiapeCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultasofflinesiapeCountAggregateOutputType> | number
          }
        }
      }
      credito: {
        payload: Prisma.$creditoPayload<ExtArgs>
        fields: Prisma.creditoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.creditoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.creditoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditoPayload>
          }
          findFirst: {
            args: Prisma.creditoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.creditoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditoPayload>
          }
          findMany: {
            args: Prisma.creditoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditoPayload>[]
          }
          create: {
            args: Prisma.creditoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditoPayload>
          }
          createMany: {
            args: Prisma.creditoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.creditoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditoPayload>
          }
          update: {
            args: Prisma.creditoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditoPayload>
          }
          deleteMany: {
            args: Prisma.creditoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.creditoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.creditoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditoPayload>
          }
          aggregate: {
            args: Prisma.CreditoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredito>
          }
          groupBy: {
            args: Prisma.creditoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditoGroupByOutputType>[]
          }
          count: {
            args: Prisma.creditoCountArgs<ExtArgs>
            result: $Utils.Optional<CreditoCountAggregateOutputType> | number
          }
        }
      }
      desbloqueios: {
        payload: Prisma.$desbloqueiosPayload<ExtArgs>
        fields: Prisma.desbloqueiosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.desbloqueiosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$desbloqueiosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.desbloqueiosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$desbloqueiosPayload>
          }
          findFirst: {
            args: Prisma.desbloqueiosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$desbloqueiosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.desbloqueiosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$desbloqueiosPayload>
          }
          findMany: {
            args: Prisma.desbloqueiosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$desbloqueiosPayload>[]
          }
          create: {
            args: Prisma.desbloqueiosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$desbloqueiosPayload>
          }
          createMany: {
            args: Prisma.desbloqueiosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.desbloqueiosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$desbloqueiosPayload>
          }
          update: {
            args: Prisma.desbloqueiosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$desbloqueiosPayload>
          }
          deleteMany: {
            args: Prisma.desbloqueiosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.desbloqueiosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.desbloqueiosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$desbloqueiosPayload>
          }
          aggregate: {
            args: Prisma.DesbloqueiosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDesbloqueios>
          }
          groupBy: {
            args: Prisma.desbloqueiosGroupByArgs<ExtArgs>
            result: $Utils.Optional<DesbloqueiosGroupByOutputType>[]
          }
          count: {
            args: Prisma.desbloqueiosCountArgs<ExtArgs>
            result: $Utils.Optional<DesbloqueiosCountAggregateOutputType> | number
          }
        }
      }
      entrantesinss: {
        payload: Prisma.$entrantesinssPayload<ExtArgs>
        fields: Prisma.entrantesinssFieldRefs
        operations: {
          findUnique: {
            args: Prisma.entrantesinssFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrantesinssPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.entrantesinssFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrantesinssPayload>
          }
          findFirst: {
            args: Prisma.entrantesinssFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrantesinssPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.entrantesinssFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrantesinssPayload>
          }
          findMany: {
            args: Prisma.entrantesinssFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrantesinssPayload>[]
          }
          create: {
            args: Prisma.entrantesinssCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrantesinssPayload>
          }
          createMany: {
            args: Prisma.entrantesinssCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.entrantesinssDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrantesinssPayload>
          }
          update: {
            args: Prisma.entrantesinssUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrantesinssPayload>
          }
          deleteMany: {
            args: Prisma.entrantesinssDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.entrantesinssUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.entrantesinssUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entrantesinssPayload>
          }
          aggregate: {
            args: Prisma.EntrantesinssAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntrantesinss>
          }
          groupBy: {
            args: Prisma.entrantesinssGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntrantesinssGroupByOutputType>[]
          }
          count: {
            args: Prisma.entrantesinssCountArgs<ExtArgs>
            result: $Utils.Optional<EntrantesinssCountAggregateOutputType> | number
          }
        }
      }
      especiebeneficio: {
        payload: Prisma.$especiebeneficioPayload<ExtArgs>
        fields: Prisma.especiebeneficioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.especiebeneficioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especiebeneficioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.especiebeneficioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especiebeneficioPayload>
          }
          findFirst: {
            args: Prisma.especiebeneficioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especiebeneficioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.especiebeneficioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especiebeneficioPayload>
          }
          findMany: {
            args: Prisma.especiebeneficioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especiebeneficioPayload>[]
          }
          create: {
            args: Prisma.especiebeneficioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especiebeneficioPayload>
          }
          createMany: {
            args: Prisma.especiebeneficioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.especiebeneficioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especiebeneficioPayload>
          }
          update: {
            args: Prisma.especiebeneficioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especiebeneficioPayload>
          }
          deleteMany: {
            args: Prisma.especiebeneficioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.especiebeneficioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.especiebeneficioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$especiebeneficioPayload>
          }
          aggregate: {
            args: Prisma.EspeciebeneficioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEspeciebeneficio>
          }
          groupBy: {
            args: Prisma.especiebeneficioGroupByArgs<ExtArgs>
            result: $Utils.Optional<EspeciebeneficioGroupByOutputType>[]
          }
          count: {
            args: Prisma.especiebeneficioCountArgs<ExtArgs>
            result: $Utils.Optional<EspeciebeneficioCountAggregateOutputType> | number
          }
        }
      }
      extratooffline: {
        payload: Prisma.$extratoofflinePayload<ExtArgs>
        fields: Prisma.extratoofflineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.extratoofflineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoofflinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.extratoofflineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoofflinePayload>
          }
          findFirst: {
            args: Prisma.extratoofflineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoofflinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.extratoofflineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoofflinePayload>
          }
          findMany: {
            args: Prisma.extratoofflineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoofflinePayload>[]
          }
          create: {
            args: Prisma.extratoofflineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoofflinePayload>
          }
          createMany: {
            args: Prisma.extratoofflineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.extratoofflineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoofflinePayload>
          }
          update: {
            args: Prisma.extratoofflineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoofflinePayload>
          }
          deleteMany: {
            args: Prisma.extratoofflineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.extratoofflineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.extratoofflineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoofflinePayload>
          }
          aggregate: {
            args: Prisma.ExtratoofflineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExtratooffline>
          }
          groupBy: {
            args: Prisma.extratoofflineGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExtratoofflineGroupByOutputType>[]
          }
          count: {
            args: Prisma.extratoofflineCountArgs<ExtArgs>
            result: $Utils.Optional<ExtratoofflineCountAggregateOutputType> | number
          }
        }
      }
      extratoonline: {
        payload: Prisma.$extratoonlinePayload<ExtArgs>
        fields: Prisma.extratoonlineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.extratoonlineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoonlinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.extratoonlineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoonlinePayload>
          }
          findFirst: {
            args: Prisma.extratoonlineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoonlinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.extratoonlineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoonlinePayload>
          }
          findMany: {
            args: Prisma.extratoonlineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoonlinePayload>[]
          }
          create: {
            args: Prisma.extratoonlineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoonlinePayload>
          }
          createMany: {
            args: Prisma.extratoonlineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.extratoonlineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoonlinePayload>
          }
          update: {
            args: Prisma.extratoonlineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoonlinePayload>
          }
          deleteMany: {
            args: Prisma.extratoonlineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.extratoonlineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.extratoonlineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extratoonlinePayload>
          }
          aggregate: {
            args: Prisma.ExtratoonlineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExtratoonline>
          }
          groupBy: {
            args: Prisma.extratoonlineGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExtratoonlineGroupByOutputType>[]
          }
          count: {
            args: Prisma.extratoonlineCountArgs<ExtArgs>
            result: $Utils.Optional<ExtratoonlineCountAggregateOutputType> | number
          }
        }
      }
      fornecedor: {
        payload: Prisma.$fornecedorPayload<ExtArgs>
        fields: Prisma.fornecedorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fornecedorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fornecedorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorPayload>
          }
          findFirst: {
            args: Prisma.fornecedorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fornecedorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorPayload>
          }
          findMany: {
            args: Prisma.fornecedorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorPayload>[]
          }
          create: {
            args: Prisma.fornecedorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorPayload>
          }
          createMany: {
            args: Prisma.fornecedorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.fornecedorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorPayload>
          }
          update: {
            args: Prisma.fornecedorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorPayload>
          }
          deleteMany: {
            args: Prisma.fornecedorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.fornecedorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.fornecedorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorPayload>
          }
          aggregate: {
            args: Prisma.FornecedorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFornecedor>
          }
          groupBy: {
            args: Prisma.fornecedorGroupByArgs<ExtArgs>
            result: $Utils.Optional<FornecedorGroupByOutputType>[]
          }
          count: {
            args: Prisma.fornecedorCountArgs<ExtArgs>
            result: $Utils.Optional<FornecedorCountAggregateOutputType> | number
          }
        }
      }
      fornecedorservico: {
        payload: Prisma.$fornecedorservicoPayload<ExtArgs>
        fields: Prisma.fornecedorservicoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fornecedorservicoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorservicoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fornecedorservicoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorservicoPayload>
          }
          findFirst: {
            args: Prisma.fornecedorservicoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorservicoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fornecedorservicoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorservicoPayload>
          }
          findMany: {
            args: Prisma.fornecedorservicoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorservicoPayload>[]
          }
          create: {
            args: Prisma.fornecedorservicoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorservicoPayload>
          }
          createMany: {
            args: Prisma.fornecedorservicoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.fornecedorservicoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorservicoPayload>
          }
          update: {
            args: Prisma.fornecedorservicoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorservicoPayload>
          }
          deleteMany: {
            args: Prisma.fornecedorservicoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.fornecedorservicoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.fornecedorservicoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fornecedorservicoPayload>
          }
          aggregate: {
            args: Prisma.FornecedorservicoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFornecedorservico>
          }
          groupBy: {
            args: Prisma.fornecedorservicoGroupByArgs<ExtArgs>
            result: $Utils.Optional<FornecedorservicoGroupByOutputType>[]
          }
          count: {
            args: Prisma.fornecedorservicoCountArgs<ExtArgs>
            result: $Utils.Optional<FornecedorservicoCountAggregateOutputType> | number
          }
        }
      }
      historicoconsultaapi: {
        payload: Prisma.$historicoconsultaapiPayload<ExtArgs>
        fields: Prisma.historicoconsultaapiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.historicoconsultaapiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicoconsultaapiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.historicoconsultaapiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicoconsultaapiPayload>
          }
          findFirst: {
            args: Prisma.historicoconsultaapiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicoconsultaapiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.historicoconsultaapiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicoconsultaapiPayload>
          }
          findMany: {
            args: Prisma.historicoconsultaapiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicoconsultaapiPayload>[]
          }
          create: {
            args: Prisma.historicoconsultaapiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicoconsultaapiPayload>
          }
          createMany: {
            args: Prisma.historicoconsultaapiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.historicoconsultaapiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicoconsultaapiPayload>
          }
          update: {
            args: Prisma.historicoconsultaapiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicoconsultaapiPayload>
          }
          deleteMany: {
            args: Prisma.historicoconsultaapiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.historicoconsultaapiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.historicoconsultaapiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicoconsultaapiPayload>
          }
          aggregate: {
            args: Prisma.HistoricoconsultaapiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistoricoconsultaapi>
          }
          groupBy: {
            args: Prisma.historicoconsultaapiGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistoricoconsultaapiGroupByOutputType>[]
          }
          count: {
            args: Prisma.historicoconsultaapiCountArgs<ExtArgs>
            result: $Utils.Optional<HistoricoconsultaapiCountAggregateOutputType> | number
          }
        }
      }
      historicocredito: {
        payload: Prisma.$historicocreditoPayload<ExtArgs>
        fields: Prisma.historicocreditoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.historicocreditoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicocreditoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.historicocreditoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicocreditoPayload>
          }
          findFirst: {
            args: Prisma.historicocreditoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicocreditoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.historicocreditoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicocreditoPayload>
          }
          findMany: {
            args: Prisma.historicocreditoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicocreditoPayload>[]
          }
          create: {
            args: Prisma.historicocreditoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicocreditoPayload>
          }
          createMany: {
            args: Prisma.historicocreditoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.historicocreditoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicocreditoPayload>
          }
          update: {
            args: Prisma.historicocreditoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicocreditoPayload>
          }
          deleteMany: {
            args: Prisma.historicocreditoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.historicocreditoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.historicocreditoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historicocreditoPayload>
          }
          aggregate: {
            args: Prisma.HistoricocreditoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistoricocredito>
          }
          groupBy: {
            args: Prisma.historicocreditoGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistoricocreditoGroupByOutputType>[]
          }
          count: {
            args: Prisma.historicocreditoCountArgs<ExtArgs>
            result: $Utils.Optional<HistoricocreditoCountAggregateOutputType> | number
          }
        }
      }
      in100: {
        payload: Prisma.$in100Payload<ExtArgs>
        fields: Prisma.in100FieldRefs
        operations: {
          findUnique: {
            args: Prisma.in100FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$in100Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.in100FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$in100Payload>
          }
          findFirst: {
            args: Prisma.in100FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$in100Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.in100FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$in100Payload>
          }
          findMany: {
            args: Prisma.in100FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$in100Payload>[]
          }
          create: {
            args: Prisma.in100CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$in100Payload>
          }
          createMany: {
            args: Prisma.in100CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.in100DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$in100Payload>
          }
          update: {
            args: Prisma.in100UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$in100Payload>
          }
          deleteMany: {
            args: Prisma.in100DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.in100UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.in100UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$in100Payload>
          }
          aggregate: {
            args: Prisma.In100AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIn100>
          }
          groupBy: {
            args: Prisma.in100GroupByArgs<ExtArgs>
            result: $Utils.Optional<In100GroupByOutputType>[]
          }
          count: {
            args: Prisma.in100CountArgs<ExtArgs>
            result: $Utils.Optional<In100CountAggregateOutputType> | number
          }
        }
      }
      logins: {
        payload: Prisma.$loginsPayload<ExtArgs>
        fields: Prisma.loginsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.loginsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.loginsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginsPayload>
          }
          findFirst: {
            args: Prisma.loginsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.loginsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginsPayload>
          }
          findMany: {
            args: Prisma.loginsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginsPayload>[]
          }
          create: {
            args: Prisma.loginsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginsPayload>
          }
          createMany: {
            args: Prisma.loginsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.loginsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginsPayload>
          }
          update: {
            args: Prisma.loginsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginsPayload>
          }
          deleteMany: {
            args: Prisma.loginsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.loginsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.loginsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginsPayload>
          }
          aggregate: {
            args: Prisma.LoginsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogins>
          }
          groupBy: {
            args: Prisma.loginsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoginsGroupByOutputType>[]
          }
          count: {
            args: Prisma.loginsCountArgs<ExtArgs>
            result: $Utils.Optional<LoginsCountAggregateOutputType> | number
          }
        }
      }
      menu: {
        payload: Prisma.$menuPayload<ExtArgs>
        fields: Prisma.menuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.menuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.menuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          findFirst: {
            args: Prisma.menuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.menuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          findMany: {
            args: Prisma.menuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload>[]
          }
          create: {
            args: Prisma.menuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          createMany: {
            args: Prisma.menuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.menuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          update: {
            args: Prisma.menuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          deleteMany: {
            args: Prisma.menuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.menuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.menuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menuPayload>
          }
          aggregate: {
            args: Prisma.MenuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenu>
          }
          groupBy: {
            args: Prisma.menuGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.menuCountArgs<ExtArgs>
            result: $Utils.Optional<MenuCountAggregateOutputType> | number
          }
        }
      }
      modulos: {
        payload: Prisma.$modulosPayload<ExtArgs>
        fields: Prisma.modulosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.modulosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.modulosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulosPayload>
          }
          findFirst: {
            args: Prisma.modulosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.modulosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulosPayload>
          }
          findMany: {
            args: Prisma.modulosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulosPayload>[]
          }
          create: {
            args: Prisma.modulosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulosPayload>
          }
          createMany: {
            args: Prisma.modulosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.modulosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulosPayload>
          }
          update: {
            args: Prisma.modulosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulosPayload>
          }
          deleteMany: {
            args: Prisma.modulosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.modulosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.modulosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulosPayload>
          }
          aggregate: {
            args: Prisma.ModulosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModulos>
          }
          groupBy: {
            args: Prisma.modulosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModulosGroupByOutputType>[]
          }
          count: {
            args: Prisma.modulosCountArgs<ExtArgs>
            result: $Utils.Optional<ModulosCountAggregateOutputType> | number
          }
        }
      }
      perfil_modulo: {
        payload: Prisma.$perfil_moduloPayload<ExtArgs>
        fields: Prisma.perfil_moduloFieldRefs
        operations: {
          findUnique: {
            args: Prisma.perfil_moduloFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfil_moduloPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.perfil_moduloFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfil_moduloPayload>
          }
          findFirst: {
            args: Prisma.perfil_moduloFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfil_moduloPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.perfil_moduloFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfil_moduloPayload>
          }
          findMany: {
            args: Prisma.perfil_moduloFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfil_moduloPayload>[]
          }
          create: {
            args: Prisma.perfil_moduloCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfil_moduloPayload>
          }
          createMany: {
            args: Prisma.perfil_moduloCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.perfil_moduloDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfil_moduloPayload>
          }
          update: {
            args: Prisma.perfil_moduloUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfil_moduloPayload>
          }
          deleteMany: {
            args: Prisma.perfil_moduloDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.perfil_moduloUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.perfil_moduloUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfil_moduloPayload>
          }
          aggregate: {
            args: Prisma.Perfil_moduloAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerfil_modulo>
          }
          groupBy: {
            args: Prisma.perfil_moduloGroupByArgs<ExtArgs>
            result: $Utils.Optional<Perfil_moduloGroupByOutputType>[]
          }
          count: {
            args: Prisma.perfil_moduloCountArgs<ExtArgs>
            result: $Utils.Optional<Perfil_moduloCountAggregateOutputType> | number
          }
        }
      }
      perfilusuario: {
        payload: Prisma.$perfilusuarioPayload<ExtArgs>
        fields: Prisma.perfilusuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.perfilusuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfilusuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.perfilusuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfilusuarioPayload>
          }
          findFirst: {
            args: Prisma.perfilusuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfilusuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.perfilusuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfilusuarioPayload>
          }
          findMany: {
            args: Prisma.perfilusuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfilusuarioPayload>[]
          }
          create: {
            args: Prisma.perfilusuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfilusuarioPayload>
          }
          createMany: {
            args: Prisma.perfilusuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.perfilusuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfilusuarioPayload>
          }
          update: {
            args: Prisma.perfilusuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfilusuarioPayload>
          }
          deleteMany: {
            args: Prisma.perfilusuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.perfilusuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.perfilusuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$perfilusuarioPayload>
          }
          aggregate: {
            args: Prisma.PerfilusuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerfilusuario>
          }
          groupBy: {
            args: Prisma.perfilusuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerfilusuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.perfilusuarioCountArgs<ExtArgs>
            result: $Utils.Optional<PerfilusuarioCountAggregateOutputType> | number
          }
        }
      }
      senhas: {
        payload: Prisma.$senhasPayload<ExtArgs>
        fields: Prisma.senhasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.senhasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$senhasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.senhasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$senhasPayload>
          }
          findFirst: {
            args: Prisma.senhasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$senhasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.senhasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$senhasPayload>
          }
          findMany: {
            args: Prisma.senhasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$senhasPayload>[]
          }
          create: {
            args: Prisma.senhasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$senhasPayload>
          }
          createMany: {
            args: Prisma.senhasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.senhasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$senhasPayload>
          }
          update: {
            args: Prisma.senhasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$senhasPayload>
          }
          deleteMany: {
            args: Prisma.senhasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.senhasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.senhasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$senhasPayload>
          }
          aggregate: {
            args: Prisma.SenhasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSenhas>
          }
          groupBy: {
            args: Prisma.senhasGroupByArgs<ExtArgs>
            result: $Utils.Optional<SenhasGroupByOutputType>[]
          }
          count: {
            args: Prisma.senhasCountArgs<ExtArgs>
            result: $Utils.Optional<SenhasCountAggregateOutputType> | number
          }
        }
      }
      situacao: {
        payload: Prisma.$situacaoPayload<ExtArgs>
        fields: Prisma.situacaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.situacaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.situacaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaoPayload>
          }
          findFirst: {
            args: Prisma.situacaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.situacaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaoPayload>
          }
          findMany: {
            args: Prisma.situacaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaoPayload>[]
          }
          create: {
            args: Prisma.situacaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaoPayload>
          }
          createMany: {
            args: Prisma.situacaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.situacaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaoPayload>
          }
          update: {
            args: Prisma.situacaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaoPayload>
          }
          deleteMany: {
            args: Prisma.situacaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.situacaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.situacaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaoPayload>
          }
          aggregate: {
            args: Prisma.SituacaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSituacao>
          }
          groupBy: {
            args: Prisma.situacaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<SituacaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.situacaoCountArgs<ExtArgs>
            result: $Utils.Optional<SituacaoCountAggregateOutputType> | number
          }
        }
      }
      situacaosolicsenha: {
        payload: Prisma.$situacaosolicsenhaPayload<ExtArgs>
        fields: Prisma.situacaosolicsenhaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.situacaosolicsenhaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaosolicsenhaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.situacaosolicsenhaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaosolicsenhaPayload>
          }
          findFirst: {
            args: Prisma.situacaosolicsenhaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaosolicsenhaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.situacaosolicsenhaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaosolicsenhaPayload>
          }
          findMany: {
            args: Prisma.situacaosolicsenhaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaosolicsenhaPayload>[]
          }
          create: {
            args: Prisma.situacaosolicsenhaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaosolicsenhaPayload>
          }
          createMany: {
            args: Prisma.situacaosolicsenhaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.situacaosolicsenhaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaosolicsenhaPayload>
          }
          update: {
            args: Prisma.situacaosolicsenhaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaosolicsenhaPayload>
          }
          deleteMany: {
            args: Prisma.situacaosolicsenhaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.situacaosolicsenhaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.situacaosolicsenhaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$situacaosolicsenhaPayload>
          }
          aggregate: {
            args: Prisma.SituacaosolicsenhaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSituacaosolicsenha>
          }
          groupBy: {
            args: Prisma.situacaosolicsenhaGroupByArgs<ExtArgs>
            result: $Utils.Optional<SituacaosolicsenhaGroupByOutputType>[]
          }
          count: {
            args: Prisma.situacaosolicsenhaCountArgs<ExtArgs>
            result: $Utils.Optional<SituacaosolicsenhaCountAggregateOutputType> | number
          }
        }
      }
      statussolicitacaoservico: {
        payload: Prisma.$statussolicitacaoservicoPayload<ExtArgs>
        fields: Prisma.statussolicitacaoservicoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.statussolicitacaoservicoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statussolicitacaoservicoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.statussolicitacaoservicoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statussolicitacaoservicoPayload>
          }
          findFirst: {
            args: Prisma.statussolicitacaoservicoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statussolicitacaoservicoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.statussolicitacaoservicoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statussolicitacaoservicoPayload>
          }
          findMany: {
            args: Prisma.statussolicitacaoservicoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statussolicitacaoservicoPayload>[]
          }
          create: {
            args: Prisma.statussolicitacaoservicoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statussolicitacaoservicoPayload>
          }
          createMany: {
            args: Prisma.statussolicitacaoservicoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.statussolicitacaoservicoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statussolicitacaoservicoPayload>
          }
          update: {
            args: Prisma.statussolicitacaoservicoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statussolicitacaoservicoPayload>
          }
          deleteMany: {
            args: Prisma.statussolicitacaoservicoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.statussolicitacaoservicoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.statussolicitacaoservicoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statussolicitacaoservicoPayload>
          }
          aggregate: {
            args: Prisma.StatussolicitacaoservicoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatussolicitacaoservico>
          }
          groupBy: {
            args: Prisma.statussolicitacaoservicoGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatussolicitacaoservicoGroupByOutputType>[]
          }
          count: {
            args: Prisma.statussolicitacaoservicoCountArgs<ExtArgs>
            result: $Utils.Optional<StatussolicitacaoservicoCountAggregateOutputType> | number
          }
        }
      }
      tiposervico: {
        payload: Prisma.$tiposervicoPayload<ExtArgs>
        fields: Prisma.tiposervicoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tiposervicoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiposervicoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tiposervicoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiposervicoPayload>
          }
          findFirst: {
            args: Prisma.tiposervicoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiposervicoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tiposervicoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiposervicoPayload>
          }
          findMany: {
            args: Prisma.tiposervicoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiposervicoPayload>[]
          }
          create: {
            args: Prisma.tiposervicoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiposervicoPayload>
          }
          createMany: {
            args: Prisma.tiposervicoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tiposervicoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiposervicoPayload>
          }
          update: {
            args: Prisma.tiposervicoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiposervicoPayload>
          }
          deleteMany: {
            args: Prisma.tiposervicoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tiposervicoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tiposervicoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiposervicoPayload>
          }
          aggregate: {
            args: Prisma.TiposervicoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTiposervico>
          }
          groupBy: {
            args: Prisma.tiposervicoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TiposervicoGroupByOutputType>[]
          }
          count: {
            args: Prisma.tiposervicoCountArgs<ExtArgs>
            result: $Utils.Optional<TiposervicoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    bancos?: bancosOmit
    configuracao?: configuracaoOmit
    consultas?: consultasOmit
    consultasoffline?: consultasofflineOmit
    consultasofflinesiape?: consultasofflinesiapeOmit
    credito?: creditoOmit
    desbloqueios?: desbloqueiosOmit
    entrantesinss?: entrantesinssOmit
    especiebeneficio?: especiebeneficioOmit
    extratooffline?: extratoofflineOmit
    extratoonline?: extratoonlineOmit
    fornecedor?: fornecedorOmit
    fornecedorservico?: fornecedorservicoOmit
    historicoconsultaapi?: historicoconsultaapiOmit
    historicocredito?: historicocreditoOmit
    in100?: in100Omit
    logins?: loginsOmit
    menu?: menuOmit
    modulos?: modulosOmit
    perfil_modulo?: perfil_moduloOmit
    perfilusuario?: perfilusuarioOmit
    senhas?: senhasOmit
    situacao?: situacaoOmit
    situacaosolicsenha?: situacaosolicsenhaOmit
    statussolicitacaoservico?: statussolicitacaoservicoOmit
    tiposervico?: tiposervicoOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ModulosCountOutputType
   */

  export type ModulosCountOutputType = {
    perfilXmodulos: number
  }

  export type ModulosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    perfilXmodulos?: boolean | ModulosCountOutputTypeCountPerfilXmodulosArgs
  }

  // Custom InputTypes
  /**
   * ModulosCountOutputType without action
   */
  export type ModulosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulosCountOutputType
     */
    select?: ModulosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModulosCountOutputType without action
   */
  export type ModulosCountOutputTypeCountPerfilXmodulosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: perfil_moduloWhereInput
  }


  /**
   * Count Type PerfilusuarioCountOutputType
   */

  export type PerfilusuarioCountOutputType = {
    logins: number
    perfilXmodulos: number
  }

  export type PerfilusuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logins?: boolean | PerfilusuarioCountOutputTypeCountLoginsArgs
    perfilXmodulos?: boolean | PerfilusuarioCountOutputTypeCountPerfilXmodulosArgs
  }

  // Custom InputTypes
  /**
   * PerfilusuarioCountOutputType without action
   */
  export type PerfilusuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilusuarioCountOutputType
     */
    select?: PerfilusuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PerfilusuarioCountOutputType without action
   */
  export type PerfilusuarioCountOutputTypeCountLoginsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: loginsWhereInput
  }

  /**
   * PerfilusuarioCountOutputType without action
   */
  export type PerfilusuarioCountOutputTypeCountPerfilXmodulosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: perfil_moduloWhereInput
  }


  /**
   * Models
   */

  /**
   * Model bancos
   */

  export type AggregateBancos = {
    _count: BancosCountAggregateOutputType | null
    _avg: BancosAvgAggregateOutputType | null
    _sum: BancosSumAggregateOutputType | null
    _min: BancosMinAggregateOutputType | null
    _max: BancosMaxAggregateOutputType | null
  }

  export type BancosAvgAggregateOutputType = {
    id: number | null
    codbanco: number | null
  }

  export type BancosSumAggregateOutputType = {
    id: number | null
    codbanco: number | null
  }

  export type BancosMinAggregateOutputType = {
    id: number | null
    codbanco: number | null
    instituicao: string | null
    segmento: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BancosMaxAggregateOutputType = {
    id: number | null
    codbanco: number | null
    instituicao: string | null
    segmento: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BancosCountAggregateOutputType = {
    id: number
    codbanco: number
    instituicao: number
    segmento: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BancosAvgAggregateInputType = {
    id?: true
    codbanco?: true
  }

  export type BancosSumAggregateInputType = {
    id?: true
    codbanco?: true
  }

  export type BancosMinAggregateInputType = {
    id?: true
    codbanco?: true
    instituicao?: true
    segmento?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BancosMaxAggregateInputType = {
    id?: true
    codbanco?: true
    instituicao?: true
    segmento?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BancosCountAggregateInputType = {
    id?: true
    codbanco?: true
    instituicao?: true
    segmento?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BancosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bancos to aggregate.
     */
    where?: bancosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bancos to fetch.
     */
    orderBy?: bancosOrderByWithRelationInput | bancosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bancosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bancos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bancos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bancos
    **/
    _count?: true | BancosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BancosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BancosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BancosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BancosMaxAggregateInputType
  }

  export type GetBancosAggregateType<T extends BancosAggregateArgs> = {
        [P in keyof T & keyof AggregateBancos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBancos[P]>
      : GetScalarType<T[P], AggregateBancos[P]>
  }




  export type bancosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bancosWhereInput
    orderBy?: bancosOrderByWithAggregationInput | bancosOrderByWithAggregationInput[]
    by: BancosScalarFieldEnum[] | BancosScalarFieldEnum
    having?: bancosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BancosCountAggregateInputType | true
    _avg?: BancosAvgAggregateInputType
    _sum?: BancosSumAggregateInputType
    _min?: BancosMinAggregateInputType
    _max?: BancosMaxAggregateInputType
  }

  export type BancosGroupByOutputType = {
    id: number
    codbanco: number
    instituicao: string
    segmento: string
    createdAt: Date
    updatedAt: Date
    _count: BancosCountAggregateOutputType | null
    _avg: BancosAvgAggregateOutputType | null
    _sum: BancosSumAggregateOutputType | null
    _min: BancosMinAggregateOutputType | null
    _max: BancosMaxAggregateOutputType | null
  }

  type GetBancosGroupByPayload<T extends bancosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BancosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BancosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BancosGroupByOutputType[P]>
            : GetScalarType<T[P], BancosGroupByOutputType[P]>
        }
      >
    >


  export type bancosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codbanco?: boolean
    instituicao?: boolean
    segmento?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bancos"]>



  export type bancosSelectScalar = {
    id?: boolean
    codbanco?: boolean
    instituicao?: boolean
    segmento?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type bancosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codbanco" | "instituicao" | "segmento" | "createdAt" | "updatedAt", ExtArgs["result"]["bancos"]>

  export type $bancosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bancos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codbanco: number
      instituicao: string
      segmento: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bancos"]>
    composites: {}
  }

  type bancosGetPayload<S extends boolean | null | undefined | bancosDefaultArgs> = $Result.GetResult<Prisma.$bancosPayload, S>

  type bancosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bancosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BancosCountAggregateInputType | true
    }

  export interface bancosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bancos'], meta: { name: 'bancos' } }
    /**
     * Find zero or one Bancos that matches the filter.
     * @param {bancosFindUniqueArgs} args - Arguments to find a Bancos
     * @example
     * // Get one Bancos
     * const bancos = await prisma.bancos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bancosFindUniqueArgs>(args: SelectSubset<T, bancosFindUniqueArgs<ExtArgs>>): Prisma__bancosClient<$Result.GetResult<Prisma.$bancosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bancos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bancosFindUniqueOrThrowArgs} args - Arguments to find a Bancos
     * @example
     * // Get one Bancos
     * const bancos = await prisma.bancos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bancosFindUniqueOrThrowArgs>(args: SelectSubset<T, bancosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bancosClient<$Result.GetResult<Prisma.$bancosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bancos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bancosFindFirstArgs} args - Arguments to find a Bancos
     * @example
     * // Get one Bancos
     * const bancos = await prisma.bancos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bancosFindFirstArgs>(args?: SelectSubset<T, bancosFindFirstArgs<ExtArgs>>): Prisma__bancosClient<$Result.GetResult<Prisma.$bancosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bancos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bancosFindFirstOrThrowArgs} args - Arguments to find a Bancos
     * @example
     * // Get one Bancos
     * const bancos = await prisma.bancos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bancosFindFirstOrThrowArgs>(args?: SelectSubset<T, bancosFindFirstOrThrowArgs<ExtArgs>>): Prisma__bancosClient<$Result.GetResult<Prisma.$bancosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bancos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bancosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bancos
     * const bancos = await prisma.bancos.findMany()
     * 
     * // Get first 10 Bancos
     * const bancos = await prisma.bancos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bancosWithIdOnly = await prisma.bancos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bancosFindManyArgs>(args?: SelectSubset<T, bancosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bancosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bancos.
     * @param {bancosCreateArgs} args - Arguments to create a Bancos.
     * @example
     * // Create one Bancos
     * const Bancos = await prisma.bancos.create({
     *   data: {
     *     // ... data to create a Bancos
     *   }
     * })
     * 
     */
    create<T extends bancosCreateArgs>(args: SelectSubset<T, bancosCreateArgs<ExtArgs>>): Prisma__bancosClient<$Result.GetResult<Prisma.$bancosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bancos.
     * @param {bancosCreateManyArgs} args - Arguments to create many Bancos.
     * @example
     * // Create many Bancos
     * const bancos = await prisma.bancos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bancosCreateManyArgs>(args?: SelectSubset<T, bancosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bancos.
     * @param {bancosDeleteArgs} args - Arguments to delete one Bancos.
     * @example
     * // Delete one Bancos
     * const Bancos = await prisma.bancos.delete({
     *   where: {
     *     // ... filter to delete one Bancos
     *   }
     * })
     * 
     */
    delete<T extends bancosDeleteArgs>(args: SelectSubset<T, bancosDeleteArgs<ExtArgs>>): Prisma__bancosClient<$Result.GetResult<Prisma.$bancosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bancos.
     * @param {bancosUpdateArgs} args - Arguments to update one Bancos.
     * @example
     * // Update one Bancos
     * const bancos = await prisma.bancos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bancosUpdateArgs>(args: SelectSubset<T, bancosUpdateArgs<ExtArgs>>): Prisma__bancosClient<$Result.GetResult<Prisma.$bancosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bancos.
     * @param {bancosDeleteManyArgs} args - Arguments to filter Bancos to delete.
     * @example
     * // Delete a few Bancos
     * const { count } = await prisma.bancos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bancosDeleteManyArgs>(args?: SelectSubset<T, bancosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bancos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bancosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bancos
     * const bancos = await prisma.bancos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bancosUpdateManyArgs>(args: SelectSubset<T, bancosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bancos.
     * @param {bancosUpsertArgs} args - Arguments to update or create a Bancos.
     * @example
     * // Update or create a Bancos
     * const bancos = await prisma.bancos.upsert({
     *   create: {
     *     // ... data to create a Bancos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bancos we want to update
     *   }
     * })
     */
    upsert<T extends bancosUpsertArgs>(args: SelectSubset<T, bancosUpsertArgs<ExtArgs>>): Prisma__bancosClient<$Result.GetResult<Prisma.$bancosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bancos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bancosCountArgs} args - Arguments to filter Bancos to count.
     * @example
     * // Count the number of Bancos
     * const count = await prisma.bancos.count({
     *   where: {
     *     // ... the filter for the Bancos we want to count
     *   }
     * })
    **/
    count<T extends bancosCountArgs>(
      args?: Subset<T, bancosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BancosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bancos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BancosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BancosAggregateArgs>(args: Subset<T, BancosAggregateArgs>): Prisma.PrismaPromise<GetBancosAggregateType<T>>

    /**
     * Group by Bancos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bancosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bancosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bancosGroupByArgs['orderBy'] }
        : { orderBy?: bancosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bancosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBancosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bancos model
   */
  readonly fields: bancosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bancos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bancosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bancos model
   */
  interface bancosFieldRefs {
    readonly id: FieldRef<"bancos", 'Int'>
    readonly codbanco: FieldRef<"bancos", 'Int'>
    readonly instituicao: FieldRef<"bancos", 'String'>
    readonly segmento: FieldRef<"bancos", 'String'>
    readonly createdAt: FieldRef<"bancos", 'DateTime'>
    readonly updatedAt: FieldRef<"bancos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * bancos findUnique
   */
  export type bancosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bancos
     */
    select?: bancosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bancos
     */
    omit?: bancosOmit<ExtArgs> | null
    /**
     * Filter, which bancos to fetch.
     */
    where: bancosWhereUniqueInput
  }

  /**
   * bancos findUniqueOrThrow
   */
  export type bancosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bancos
     */
    select?: bancosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bancos
     */
    omit?: bancosOmit<ExtArgs> | null
    /**
     * Filter, which bancos to fetch.
     */
    where: bancosWhereUniqueInput
  }

  /**
   * bancos findFirst
   */
  export type bancosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bancos
     */
    select?: bancosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bancos
     */
    omit?: bancosOmit<ExtArgs> | null
    /**
     * Filter, which bancos to fetch.
     */
    where?: bancosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bancos to fetch.
     */
    orderBy?: bancosOrderByWithRelationInput | bancosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bancos.
     */
    cursor?: bancosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bancos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bancos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bancos.
     */
    distinct?: BancosScalarFieldEnum | BancosScalarFieldEnum[]
  }

  /**
   * bancos findFirstOrThrow
   */
  export type bancosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bancos
     */
    select?: bancosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bancos
     */
    omit?: bancosOmit<ExtArgs> | null
    /**
     * Filter, which bancos to fetch.
     */
    where?: bancosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bancos to fetch.
     */
    orderBy?: bancosOrderByWithRelationInput | bancosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bancos.
     */
    cursor?: bancosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bancos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bancos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bancos.
     */
    distinct?: BancosScalarFieldEnum | BancosScalarFieldEnum[]
  }

  /**
   * bancos findMany
   */
  export type bancosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bancos
     */
    select?: bancosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bancos
     */
    omit?: bancosOmit<ExtArgs> | null
    /**
     * Filter, which bancos to fetch.
     */
    where?: bancosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bancos to fetch.
     */
    orderBy?: bancosOrderByWithRelationInput | bancosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bancos.
     */
    cursor?: bancosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bancos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bancos.
     */
    skip?: number
    distinct?: BancosScalarFieldEnum | BancosScalarFieldEnum[]
  }

  /**
   * bancos create
   */
  export type bancosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bancos
     */
    select?: bancosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bancos
     */
    omit?: bancosOmit<ExtArgs> | null
    /**
     * The data needed to create a bancos.
     */
    data: XOR<bancosCreateInput, bancosUncheckedCreateInput>
  }

  /**
   * bancos createMany
   */
  export type bancosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bancos.
     */
    data: bancosCreateManyInput | bancosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bancos update
   */
  export type bancosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bancos
     */
    select?: bancosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bancos
     */
    omit?: bancosOmit<ExtArgs> | null
    /**
     * The data needed to update a bancos.
     */
    data: XOR<bancosUpdateInput, bancosUncheckedUpdateInput>
    /**
     * Choose, which bancos to update.
     */
    where: bancosWhereUniqueInput
  }

  /**
   * bancos updateMany
   */
  export type bancosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bancos.
     */
    data: XOR<bancosUpdateManyMutationInput, bancosUncheckedUpdateManyInput>
    /**
     * Filter which bancos to update
     */
    where?: bancosWhereInput
    /**
     * Limit how many bancos to update.
     */
    limit?: number
  }

  /**
   * bancos upsert
   */
  export type bancosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bancos
     */
    select?: bancosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bancos
     */
    omit?: bancosOmit<ExtArgs> | null
    /**
     * The filter to search for the bancos to update in case it exists.
     */
    where: bancosWhereUniqueInput
    /**
     * In case the bancos found by the `where` argument doesn't exist, create a new bancos with this data.
     */
    create: XOR<bancosCreateInput, bancosUncheckedCreateInput>
    /**
     * In case the bancos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bancosUpdateInput, bancosUncheckedUpdateInput>
  }

  /**
   * bancos delete
   */
  export type bancosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bancos
     */
    select?: bancosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bancos
     */
    omit?: bancosOmit<ExtArgs> | null
    /**
     * Filter which bancos to delete.
     */
    where: bancosWhereUniqueInput
  }

  /**
   * bancos deleteMany
   */
  export type bancosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bancos to delete
     */
    where?: bancosWhereInput
    /**
     * Limit how many bancos to delete.
     */
    limit?: number
  }

  /**
   * bancos without action
   */
  export type bancosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bancos
     */
    select?: bancosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bancos
     */
    omit?: bancosOmit<ExtArgs> | null
  }


  /**
   * Model configuracao
   */

  export type AggregateConfiguracao = {
    _count: ConfiguracaoCountAggregateOutputType | null
    _avg: ConfiguracaoAvgAggregateOutputType | null
    _sum: ConfiguracaoSumAggregateOutputType | null
    _min: ConfiguracaoMinAggregateOutputType | null
    _max: ConfiguracaoMaxAggregateOutputType | null
  }

  export type ConfiguracaoAvgAggregateOutputType = {
    id: number | null
  }

  export type ConfiguracaoSumAggregateOutputType = {
    id: number | null
  }

  export type ConfiguracaoMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfiguracaoMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfiguracaoCountAggregateOutputType = {
    id: number
    descricao: number
    config: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConfiguracaoAvgAggregateInputType = {
    id?: true
  }

  export type ConfiguracaoSumAggregateInputType = {
    id?: true
  }

  export type ConfiguracaoMinAggregateInputType = {
    id?: true
    descricao?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfiguracaoMaxAggregateInputType = {
    id?: true
    descricao?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfiguracaoCountAggregateInputType = {
    id?: true
    descricao?: true
    config?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConfiguracaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configuracao to aggregate.
     */
    where?: configuracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configuracaos to fetch.
     */
    orderBy?: configuracaoOrderByWithRelationInput | configuracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: configuracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configuracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configuracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned configuracaos
    **/
    _count?: true | ConfiguracaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfiguracaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfiguracaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfiguracaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfiguracaoMaxAggregateInputType
  }

  export type GetConfiguracaoAggregateType<T extends ConfiguracaoAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguracao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguracao[P]>
      : GetScalarType<T[P], AggregateConfiguracao[P]>
  }




  export type configuracaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: configuracaoWhereInput
    orderBy?: configuracaoOrderByWithAggregationInput | configuracaoOrderByWithAggregationInput[]
    by: ConfiguracaoScalarFieldEnum[] | ConfiguracaoScalarFieldEnum
    having?: configuracaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfiguracaoCountAggregateInputType | true
    _avg?: ConfiguracaoAvgAggregateInputType
    _sum?: ConfiguracaoSumAggregateInputType
    _min?: ConfiguracaoMinAggregateInputType
    _max?: ConfiguracaoMaxAggregateInputType
  }

  export type ConfiguracaoGroupByOutputType = {
    id: number
    descricao: string
    config: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ConfiguracaoCountAggregateOutputType | null
    _avg: ConfiguracaoAvgAggregateOutputType | null
    _sum: ConfiguracaoSumAggregateOutputType | null
    _min: ConfiguracaoMinAggregateOutputType | null
    _max: ConfiguracaoMaxAggregateOutputType | null
  }

  type GetConfiguracaoGroupByPayload<T extends configuracaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfiguracaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfiguracaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfiguracaoGroupByOutputType[P]>
            : GetScalarType<T[P], ConfiguracaoGroupByOutputType[P]>
        }
      >
    >


  export type configuracaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configuracao"]>



  export type configuracaoSelectScalar = {
    id?: boolean
    descricao?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type configuracaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "config" | "createdAt" | "updatedAt", ExtArgs["result"]["configuracao"]>

  export type $configuracaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "configuracao"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      config: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["configuracao"]>
    composites: {}
  }

  type configuracaoGetPayload<S extends boolean | null | undefined | configuracaoDefaultArgs> = $Result.GetResult<Prisma.$configuracaoPayload, S>

  type configuracaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<configuracaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfiguracaoCountAggregateInputType | true
    }

  export interface configuracaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['configuracao'], meta: { name: 'configuracao' } }
    /**
     * Find zero or one Configuracao that matches the filter.
     * @param {configuracaoFindUniqueArgs} args - Arguments to find a Configuracao
     * @example
     * // Get one Configuracao
     * const configuracao = await prisma.configuracao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends configuracaoFindUniqueArgs>(args: SelectSubset<T, configuracaoFindUniqueArgs<ExtArgs>>): Prisma__configuracaoClient<$Result.GetResult<Prisma.$configuracaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Configuracao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {configuracaoFindUniqueOrThrowArgs} args - Arguments to find a Configuracao
     * @example
     * // Get one Configuracao
     * const configuracao = await prisma.configuracao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends configuracaoFindUniqueOrThrowArgs>(args: SelectSubset<T, configuracaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__configuracaoClient<$Result.GetResult<Prisma.$configuracaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Configuracao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configuracaoFindFirstArgs} args - Arguments to find a Configuracao
     * @example
     * // Get one Configuracao
     * const configuracao = await prisma.configuracao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends configuracaoFindFirstArgs>(args?: SelectSubset<T, configuracaoFindFirstArgs<ExtArgs>>): Prisma__configuracaoClient<$Result.GetResult<Prisma.$configuracaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Configuracao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configuracaoFindFirstOrThrowArgs} args - Arguments to find a Configuracao
     * @example
     * // Get one Configuracao
     * const configuracao = await prisma.configuracao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends configuracaoFindFirstOrThrowArgs>(args?: SelectSubset<T, configuracaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__configuracaoClient<$Result.GetResult<Prisma.$configuracaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Configuracaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configuracaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configuracaos
     * const configuracaos = await prisma.configuracao.findMany()
     * 
     * // Get first 10 Configuracaos
     * const configuracaos = await prisma.configuracao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configuracaoWithIdOnly = await prisma.configuracao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends configuracaoFindManyArgs>(args?: SelectSubset<T, configuracaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configuracaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Configuracao.
     * @param {configuracaoCreateArgs} args - Arguments to create a Configuracao.
     * @example
     * // Create one Configuracao
     * const Configuracao = await prisma.configuracao.create({
     *   data: {
     *     // ... data to create a Configuracao
     *   }
     * })
     * 
     */
    create<T extends configuracaoCreateArgs>(args: SelectSubset<T, configuracaoCreateArgs<ExtArgs>>): Prisma__configuracaoClient<$Result.GetResult<Prisma.$configuracaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Configuracaos.
     * @param {configuracaoCreateManyArgs} args - Arguments to create many Configuracaos.
     * @example
     * // Create many Configuracaos
     * const configuracao = await prisma.configuracao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends configuracaoCreateManyArgs>(args?: SelectSubset<T, configuracaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Configuracao.
     * @param {configuracaoDeleteArgs} args - Arguments to delete one Configuracao.
     * @example
     * // Delete one Configuracao
     * const Configuracao = await prisma.configuracao.delete({
     *   where: {
     *     // ... filter to delete one Configuracao
     *   }
     * })
     * 
     */
    delete<T extends configuracaoDeleteArgs>(args: SelectSubset<T, configuracaoDeleteArgs<ExtArgs>>): Prisma__configuracaoClient<$Result.GetResult<Prisma.$configuracaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Configuracao.
     * @param {configuracaoUpdateArgs} args - Arguments to update one Configuracao.
     * @example
     * // Update one Configuracao
     * const configuracao = await prisma.configuracao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends configuracaoUpdateArgs>(args: SelectSubset<T, configuracaoUpdateArgs<ExtArgs>>): Prisma__configuracaoClient<$Result.GetResult<Prisma.$configuracaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Configuracaos.
     * @param {configuracaoDeleteManyArgs} args - Arguments to filter Configuracaos to delete.
     * @example
     * // Delete a few Configuracaos
     * const { count } = await prisma.configuracao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends configuracaoDeleteManyArgs>(args?: SelectSubset<T, configuracaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configuracaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configuracaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configuracaos
     * const configuracao = await prisma.configuracao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends configuracaoUpdateManyArgs>(args: SelectSubset<T, configuracaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Configuracao.
     * @param {configuracaoUpsertArgs} args - Arguments to update or create a Configuracao.
     * @example
     * // Update or create a Configuracao
     * const configuracao = await prisma.configuracao.upsert({
     *   create: {
     *     // ... data to create a Configuracao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Configuracao we want to update
     *   }
     * })
     */
    upsert<T extends configuracaoUpsertArgs>(args: SelectSubset<T, configuracaoUpsertArgs<ExtArgs>>): Prisma__configuracaoClient<$Result.GetResult<Prisma.$configuracaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Configuracaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configuracaoCountArgs} args - Arguments to filter Configuracaos to count.
     * @example
     * // Count the number of Configuracaos
     * const count = await prisma.configuracao.count({
     *   where: {
     *     // ... the filter for the Configuracaos we want to count
     *   }
     * })
    **/
    count<T extends configuracaoCountArgs>(
      args?: Subset<T, configuracaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfiguracaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Configuracao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfiguracaoAggregateArgs>(args: Subset<T, ConfiguracaoAggregateArgs>): Prisma.PrismaPromise<GetConfiguracaoAggregateType<T>>

    /**
     * Group by Configuracao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configuracaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends configuracaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: configuracaoGroupByArgs['orderBy'] }
        : { orderBy?: configuracaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, configuracaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfiguracaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the configuracao model
   */
  readonly fields: configuracaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for configuracao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__configuracaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the configuracao model
   */
  interface configuracaoFieldRefs {
    readonly id: FieldRef<"configuracao", 'Int'>
    readonly descricao: FieldRef<"configuracao", 'String'>
    readonly config: FieldRef<"configuracao", 'Json'>
    readonly createdAt: FieldRef<"configuracao", 'DateTime'>
    readonly updatedAt: FieldRef<"configuracao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * configuracao findUnique
   */
  export type configuracaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracao
     */
    select?: configuracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuracao
     */
    omit?: configuracaoOmit<ExtArgs> | null
    /**
     * Filter, which configuracao to fetch.
     */
    where: configuracaoWhereUniqueInput
  }

  /**
   * configuracao findUniqueOrThrow
   */
  export type configuracaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracao
     */
    select?: configuracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuracao
     */
    omit?: configuracaoOmit<ExtArgs> | null
    /**
     * Filter, which configuracao to fetch.
     */
    where: configuracaoWhereUniqueInput
  }

  /**
   * configuracao findFirst
   */
  export type configuracaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracao
     */
    select?: configuracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuracao
     */
    omit?: configuracaoOmit<ExtArgs> | null
    /**
     * Filter, which configuracao to fetch.
     */
    where?: configuracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configuracaos to fetch.
     */
    orderBy?: configuracaoOrderByWithRelationInput | configuracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configuracaos.
     */
    cursor?: configuracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configuracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configuracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configuracaos.
     */
    distinct?: ConfiguracaoScalarFieldEnum | ConfiguracaoScalarFieldEnum[]
  }

  /**
   * configuracao findFirstOrThrow
   */
  export type configuracaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracao
     */
    select?: configuracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuracao
     */
    omit?: configuracaoOmit<ExtArgs> | null
    /**
     * Filter, which configuracao to fetch.
     */
    where?: configuracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configuracaos to fetch.
     */
    orderBy?: configuracaoOrderByWithRelationInput | configuracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configuracaos.
     */
    cursor?: configuracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configuracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configuracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configuracaos.
     */
    distinct?: ConfiguracaoScalarFieldEnum | ConfiguracaoScalarFieldEnum[]
  }

  /**
   * configuracao findMany
   */
  export type configuracaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracao
     */
    select?: configuracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuracao
     */
    omit?: configuracaoOmit<ExtArgs> | null
    /**
     * Filter, which configuracaos to fetch.
     */
    where?: configuracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configuracaos to fetch.
     */
    orderBy?: configuracaoOrderByWithRelationInput | configuracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing configuracaos.
     */
    cursor?: configuracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configuracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configuracaos.
     */
    skip?: number
    distinct?: ConfiguracaoScalarFieldEnum | ConfiguracaoScalarFieldEnum[]
  }

  /**
   * configuracao create
   */
  export type configuracaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracao
     */
    select?: configuracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuracao
     */
    omit?: configuracaoOmit<ExtArgs> | null
    /**
     * The data needed to create a configuracao.
     */
    data: XOR<configuracaoCreateInput, configuracaoUncheckedCreateInput>
  }

  /**
   * configuracao createMany
   */
  export type configuracaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many configuracaos.
     */
    data: configuracaoCreateManyInput | configuracaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * configuracao update
   */
  export type configuracaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracao
     */
    select?: configuracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuracao
     */
    omit?: configuracaoOmit<ExtArgs> | null
    /**
     * The data needed to update a configuracao.
     */
    data: XOR<configuracaoUpdateInput, configuracaoUncheckedUpdateInput>
    /**
     * Choose, which configuracao to update.
     */
    where: configuracaoWhereUniqueInput
  }

  /**
   * configuracao updateMany
   */
  export type configuracaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update configuracaos.
     */
    data: XOR<configuracaoUpdateManyMutationInput, configuracaoUncheckedUpdateManyInput>
    /**
     * Filter which configuracaos to update
     */
    where?: configuracaoWhereInput
    /**
     * Limit how many configuracaos to update.
     */
    limit?: number
  }

  /**
   * configuracao upsert
   */
  export type configuracaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracao
     */
    select?: configuracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuracao
     */
    omit?: configuracaoOmit<ExtArgs> | null
    /**
     * The filter to search for the configuracao to update in case it exists.
     */
    where: configuracaoWhereUniqueInput
    /**
     * In case the configuracao found by the `where` argument doesn't exist, create a new configuracao with this data.
     */
    create: XOR<configuracaoCreateInput, configuracaoUncheckedCreateInput>
    /**
     * In case the configuracao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<configuracaoUpdateInput, configuracaoUncheckedUpdateInput>
  }

  /**
   * configuracao delete
   */
  export type configuracaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracao
     */
    select?: configuracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuracao
     */
    omit?: configuracaoOmit<ExtArgs> | null
    /**
     * Filter which configuracao to delete.
     */
    where: configuracaoWhereUniqueInput
  }

  /**
   * configuracao deleteMany
   */
  export type configuracaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configuracaos to delete
     */
    where?: configuracaoWhereInput
    /**
     * Limit how many configuracaos to delete.
     */
    limit?: number
  }

  /**
   * configuracao without action
   */
  export type configuracaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the configuracao
     */
    select?: configuracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the configuracao
     */
    omit?: configuracaoOmit<ExtArgs> | null
  }


  /**
   * Model consultas
   */

  export type AggregateConsultas = {
    _count: ConsultasCountAggregateOutputType | null
    _avg: ConsultasAvgAggregateOutputType | null
    _sum: ConsultasSumAggregateOutputType | null
    _min: ConsultasMinAggregateOutputType | null
    _max: ConsultasMaxAggregateOutputType | null
  }

  export type ConsultasAvgAggregateOutputType = {
    id: number | null
    id_servico: number | null
    qtde: number | null
    id_usuario: number | null
    tipotransacao: number | null
    valor_unit: number | null
    tp_serv_origem: number | null
    id_extrato_off: number | null
    origem_sol: number | null
  }

  export type ConsultasSumAggregateOutputType = {
    id: number | null
    id_servico: number | null
    qtde: number | null
    id_usuario: number | null
    tipotransacao: number | null
    valor_unit: number | null
    tp_serv_origem: number | null
    id_extrato_off: number | null
    origem_sol: number | null
  }

  export type ConsultasMinAggregateOutputType = {
    id: number | null
    datahora: Date | null
    id_servico: number | null
    beneficio: string | null
    cpf: string | null
    qtde: number | null
    id_usuario: number | null
    createdAt: Date | null
    updatedAt: Date | null
    tipotransacao: number | null
    observacao: string | null
    valor_unit: number | null
    matricula_siape: string | null
    tp_serv_origem: number | null
    id_extrato_off: number | null
    origem_sol: number | null
  }

  export type ConsultasMaxAggregateOutputType = {
    id: number | null
    datahora: Date | null
    id_servico: number | null
    beneficio: string | null
    cpf: string | null
    qtde: number | null
    id_usuario: number | null
    createdAt: Date | null
    updatedAt: Date | null
    tipotransacao: number | null
    observacao: string | null
    valor_unit: number | null
    matricula_siape: string | null
    tp_serv_origem: number | null
    id_extrato_off: number | null
    origem_sol: number | null
  }

  export type ConsultasCountAggregateOutputType = {
    id: number
    datahora: number
    id_servico: number
    beneficio: number
    cpf: number
    qtde: number
    id_usuario: number
    createdAt: number
    updatedAt: number
    tipotransacao: number
    observacao: number
    valor_unit: number
    matricula_siape: number
    tp_serv_origem: number
    id_extrato_off: number
    origem_sol: number
    _all: number
  }


  export type ConsultasAvgAggregateInputType = {
    id?: true
    id_servico?: true
    qtde?: true
    id_usuario?: true
    tipotransacao?: true
    valor_unit?: true
    tp_serv_origem?: true
    id_extrato_off?: true
    origem_sol?: true
  }

  export type ConsultasSumAggregateInputType = {
    id?: true
    id_servico?: true
    qtde?: true
    id_usuario?: true
    tipotransacao?: true
    valor_unit?: true
    tp_serv_origem?: true
    id_extrato_off?: true
    origem_sol?: true
  }

  export type ConsultasMinAggregateInputType = {
    id?: true
    datahora?: true
    id_servico?: true
    beneficio?: true
    cpf?: true
    qtde?: true
    id_usuario?: true
    createdAt?: true
    updatedAt?: true
    tipotransacao?: true
    observacao?: true
    valor_unit?: true
    matricula_siape?: true
    tp_serv_origem?: true
    id_extrato_off?: true
    origem_sol?: true
  }

  export type ConsultasMaxAggregateInputType = {
    id?: true
    datahora?: true
    id_servico?: true
    beneficio?: true
    cpf?: true
    qtde?: true
    id_usuario?: true
    createdAt?: true
    updatedAt?: true
    tipotransacao?: true
    observacao?: true
    valor_unit?: true
    matricula_siape?: true
    tp_serv_origem?: true
    id_extrato_off?: true
    origem_sol?: true
  }

  export type ConsultasCountAggregateInputType = {
    id?: true
    datahora?: true
    id_servico?: true
    beneficio?: true
    cpf?: true
    qtde?: true
    id_usuario?: true
    createdAt?: true
    updatedAt?: true
    tipotransacao?: true
    observacao?: true
    valor_unit?: true
    matricula_siape?: true
    tp_serv_origem?: true
    id_extrato_off?: true
    origem_sol?: true
    _all?: true
  }

  export type ConsultasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consultas to aggregate.
     */
    where?: consultasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultas to fetch.
     */
    orderBy?: consultasOrderByWithRelationInput | consultasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consultasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consultas
    **/
    _count?: true | ConsultasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultasMaxAggregateInputType
  }

  export type GetConsultasAggregateType<T extends ConsultasAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultas[P]>
      : GetScalarType<T[P], AggregateConsultas[P]>
  }




  export type consultasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consultasWhereInput
    orderBy?: consultasOrderByWithAggregationInput | consultasOrderByWithAggregationInput[]
    by: ConsultasScalarFieldEnum[] | ConsultasScalarFieldEnum
    having?: consultasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultasCountAggregateInputType | true
    _avg?: ConsultasAvgAggregateInputType
    _sum?: ConsultasSumAggregateInputType
    _min?: ConsultasMinAggregateInputType
    _max?: ConsultasMaxAggregateInputType
  }

  export type ConsultasGroupByOutputType = {
    id: number
    datahora: Date
    id_servico: number
    beneficio: string | null
    cpf: string | null
    qtde: number
    id_usuario: number
    createdAt: Date
    updatedAt: Date
    tipotransacao: number
    observacao: string | null
    valor_unit: number
    matricula_siape: string | null
    tp_serv_origem: number
    id_extrato_off: number
    origem_sol: number
    _count: ConsultasCountAggregateOutputType | null
    _avg: ConsultasAvgAggregateOutputType | null
    _sum: ConsultasSumAggregateOutputType | null
    _min: ConsultasMinAggregateOutputType | null
    _max: ConsultasMaxAggregateOutputType | null
  }

  type GetConsultasGroupByPayload<T extends consultasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultasGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultasGroupByOutputType[P]>
        }
      >
    >


  export type consultasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datahora?: boolean
    id_servico?: boolean
    beneficio?: boolean
    cpf?: boolean
    qtde?: boolean
    id_usuario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tipotransacao?: boolean
    observacao?: boolean
    valor_unit?: boolean
    matricula_siape?: boolean
    tp_serv_origem?: boolean
    id_extrato_off?: boolean
    origem_sol?: boolean
  }, ExtArgs["result"]["consultas"]>



  export type consultasSelectScalar = {
    id?: boolean
    datahora?: boolean
    id_servico?: boolean
    beneficio?: boolean
    cpf?: boolean
    qtde?: boolean
    id_usuario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tipotransacao?: boolean
    observacao?: boolean
    valor_unit?: boolean
    matricula_siape?: boolean
    tp_serv_origem?: boolean
    id_extrato_off?: boolean
    origem_sol?: boolean
  }

  export type consultasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "datahora" | "id_servico" | "beneficio" | "cpf" | "qtde" | "id_usuario" | "createdAt" | "updatedAt" | "tipotransacao" | "observacao" | "valor_unit" | "matricula_siape" | "tp_serv_origem" | "id_extrato_off" | "origem_sol", ExtArgs["result"]["consultas"]>

  export type $consultasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consultas"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      datahora: Date
      id_servico: number
      beneficio: string | null
      cpf: string | null
      qtde: number
      id_usuario: number
      createdAt: Date
      updatedAt: Date
      tipotransacao: number
      observacao: string | null
      valor_unit: number
      matricula_siape: string | null
      tp_serv_origem: number
      id_extrato_off: number
      origem_sol: number
    }, ExtArgs["result"]["consultas"]>
    composites: {}
  }

  type consultasGetPayload<S extends boolean | null | undefined | consultasDefaultArgs> = $Result.GetResult<Prisma.$consultasPayload, S>

  type consultasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<consultasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsultasCountAggregateInputType | true
    }

  export interface consultasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consultas'], meta: { name: 'consultas' } }
    /**
     * Find zero or one Consultas that matches the filter.
     * @param {consultasFindUniqueArgs} args - Arguments to find a Consultas
     * @example
     * // Get one Consultas
     * const consultas = await prisma.consultas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consultasFindUniqueArgs>(args: SelectSubset<T, consultasFindUniqueArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consultas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {consultasFindUniqueOrThrowArgs} args - Arguments to find a Consultas
     * @example
     * // Get one Consultas
     * const consultas = await prisma.consultas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consultasFindUniqueOrThrowArgs>(args: SelectSubset<T, consultasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consultas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasFindFirstArgs} args - Arguments to find a Consultas
     * @example
     * // Get one Consultas
     * const consultas = await prisma.consultas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consultasFindFirstArgs>(args?: SelectSubset<T, consultasFindFirstArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consultas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasFindFirstOrThrowArgs} args - Arguments to find a Consultas
     * @example
     * // Get one Consultas
     * const consultas = await prisma.consultas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consultasFindFirstOrThrowArgs>(args?: SelectSubset<T, consultasFindFirstOrThrowArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consultas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consultas
     * const consultas = await prisma.consultas.findMany()
     * 
     * // Get first 10 Consultas
     * const consultas = await prisma.consultas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultasWithIdOnly = await prisma.consultas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends consultasFindManyArgs>(args?: SelectSubset<T, consultasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consultas.
     * @param {consultasCreateArgs} args - Arguments to create a Consultas.
     * @example
     * // Create one Consultas
     * const Consultas = await prisma.consultas.create({
     *   data: {
     *     // ... data to create a Consultas
     *   }
     * })
     * 
     */
    create<T extends consultasCreateArgs>(args: SelectSubset<T, consultasCreateArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consultas.
     * @param {consultasCreateManyArgs} args - Arguments to create many Consultas.
     * @example
     * // Create many Consultas
     * const consultas = await prisma.consultas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consultasCreateManyArgs>(args?: SelectSubset<T, consultasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Consultas.
     * @param {consultasDeleteArgs} args - Arguments to delete one Consultas.
     * @example
     * // Delete one Consultas
     * const Consultas = await prisma.consultas.delete({
     *   where: {
     *     // ... filter to delete one Consultas
     *   }
     * })
     * 
     */
    delete<T extends consultasDeleteArgs>(args: SelectSubset<T, consultasDeleteArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consultas.
     * @param {consultasUpdateArgs} args - Arguments to update one Consultas.
     * @example
     * // Update one Consultas
     * const consultas = await prisma.consultas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consultasUpdateArgs>(args: SelectSubset<T, consultasUpdateArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consultas.
     * @param {consultasDeleteManyArgs} args - Arguments to filter Consultas to delete.
     * @example
     * // Delete a few Consultas
     * const { count } = await prisma.consultas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consultasDeleteManyArgs>(args?: SelectSubset<T, consultasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consultas
     * const consultas = await prisma.consultas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consultasUpdateManyArgs>(args: SelectSubset<T, consultasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Consultas.
     * @param {consultasUpsertArgs} args - Arguments to update or create a Consultas.
     * @example
     * // Update or create a Consultas
     * const consultas = await prisma.consultas.upsert({
     *   create: {
     *     // ... data to create a Consultas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consultas we want to update
     *   }
     * })
     */
    upsert<T extends consultasUpsertArgs>(args: SelectSubset<T, consultasUpsertArgs<ExtArgs>>): Prisma__consultasClient<$Result.GetResult<Prisma.$consultasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Consultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasCountArgs} args - Arguments to filter Consultas to count.
     * @example
     * // Count the number of Consultas
     * const count = await prisma.consultas.count({
     *   where: {
     *     // ... the filter for the Consultas we want to count
     *   }
     * })
    **/
    count<T extends consultasCountArgs>(
      args?: Subset<T, consultasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultasAggregateArgs>(args: Subset<T, ConsultasAggregateArgs>): Prisma.PrismaPromise<GetConsultasAggregateType<T>>

    /**
     * Group by Consultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consultasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consultasGroupByArgs['orderBy'] }
        : { orderBy?: consultasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consultasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consultas model
   */
  readonly fields: consultasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consultas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consultasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consultas model
   */
  interface consultasFieldRefs {
    readonly id: FieldRef<"consultas", 'Int'>
    readonly datahora: FieldRef<"consultas", 'DateTime'>
    readonly id_servico: FieldRef<"consultas", 'Int'>
    readonly beneficio: FieldRef<"consultas", 'String'>
    readonly cpf: FieldRef<"consultas", 'String'>
    readonly qtde: FieldRef<"consultas", 'Int'>
    readonly id_usuario: FieldRef<"consultas", 'Int'>
    readonly createdAt: FieldRef<"consultas", 'DateTime'>
    readonly updatedAt: FieldRef<"consultas", 'DateTime'>
    readonly tipotransacao: FieldRef<"consultas", 'Int'>
    readonly observacao: FieldRef<"consultas", 'String'>
    readonly valor_unit: FieldRef<"consultas", 'Float'>
    readonly matricula_siape: FieldRef<"consultas", 'String'>
    readonly tp_serv_origem: FieldRef<"consultas", 'Int'>
    readonly id_extrato_off: FieldRef<"consultas", 'Int'>
    readonly origem_sol: FieldRef<"consultas", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * consultas findUnique
   */
  export type consultasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultas
     */
    omit?: consultasOmit<ExtArgs> | null
    /**
     * Filter, which consultas to fetch.
     */
    where: consultasWhereUniqueInput
  }

  /**
   * consultas findUniqueOrThrow
   */
  export type consultasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultas
     */
    omit?: consultasOmit<ExtArgs> | null
    /**
     * Filter, which consultas to fetch.
     */
    where: consultasWhereUniqueInput
  }

  /**
   * consultas findFirst
   */
  export type consultasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultas
     */
    omit?: consultasOmit<ExtArgs> | null
    /**
     * Filter, which consultas to fetch.
     */
    where?: consultasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultas to fetch.
     */
    orderBy?: consultasOrderByWithRelationInput | consultasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consultas.
     */
    cursor?: consultasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consultas.
     */
    distinct?: ConsultasScalarFieldEnum | ConsultasScalarFieldEnum[]
  }

  /**
   * consultas findFirstOrThrow
   */
  export type consultasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultas
     */
    omit?: consultasOmit<ExtArgs> | null
    /**
     * Filter, which consultas to fetch.
     */
    where?: consultasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultas to fetch.
     */
    orderBy?: consultasOrderByWithRelationInput | consultasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consultas.
     */
    cursor?: consultasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consultas.
     */
    distinct?: ConsultasScalarFieldEnum | ConsultasScalarFieldEnum[]
  }

  /**
   * consultas findMany
   */
  export type consultasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultas
     */
    omit?: consultasOmit<ExtArgs> | null
    /**
     * Filter, which consultas to fetch.
     */
    where?: consultasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultas to fetch.
     */
    orderBy?: consultasOrderByWithRelationInput | consultasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consultas.
     */
    cursor?: consultasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultas.
     */
    skip?: number
    distinct?: ConsultasScalarFieldEnum | ConsultasScalarFieldEnum[]
  }

  /**
   * consultas create
   */
  export type consultasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultas
     */
    omit?: consultasOmit<ExtArgs> | null
    /**
     * The data needed to create a consultas.
     */
    data: XOR<consultasCreateInput, consultasUncheckedCreateInput>
  }

  /**
   * consultas createMany
   */
  export type consultasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consultas.
     */
    data: consultasCreateManyInput | consultasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consultas update
   */
  export type consultasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultas
     */
    omit?: consultasOmit<ExtArgs> | null
    /**
     * The data needed to update a consultas.
     */
    data: XOR<consultasUpdateInput, consultasUncheckedUpdateInput>
    /**
     * Choose, which consultas to update.
     */
    where: consultasWhereUniqueInput
  }

  /**
   * consultas updateMany
   */
  export type consultasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consultas.
     */
    data: XOR<consultasUpdateManyMutationInput, consultasUncheckedUpdateManyInput>
    /**
     * Filter which consultas to update
     */
    where?: consultasWhereInput
    /**
     * Limit how many consultas to update.
     */
    limit?: number
  }

  /**
   * consultas upsert
   */
  export type consultasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultas
     */
    omit?: consultasOmit<ExtArgs> | null
    /**
     * The filter to search for the consultas to update in case it exists.
     */
    where: consultasWhereUniqueInput
    /**
     * In case the consultas found by the `where` argument doesn't exist, create a new consultas with this data.
     */
    create: XOR<consultasCreateInput, consultasUncheckedCreateInput>
    /**
     * In case the consultas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consultasUpdateInput, consultasUncheckedUpdateInput>
  }

  /**
   * consultas delete
   */
  export type consultasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultas
     */
    omit?: consultasOmit<ExtArgs> | null
    /**
     * Filter which consultas to delete.
     */
    where: consultasWhereUniqueInput
  }

  /**
   * consultas deleteMany
   */
  export type consultasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consultas to delete
     */
    where?: consultasWhereInput
    /**
     * Limit how many consultas to delete.
     */
    limit?: number
  }

  /**
   * consultas without action
   */
  export type consultasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultas
     */
    select?: consultasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultas
     */
    omit?: consultasOmit<ExtArgs> | null
  }


  /**
   * Model consultasoffline
   */

  export type AggregateConsultasoffline = {
    _count: ConsultasofflineCountAggregateOutputType | null
    _avg: ConsultasofflineAvgAggregateOutputType | null
    _sum: ConsultasofflineSumAggregateOutputType | null
    _min: ConsultasofflineMinAggregateOutputType | null
    _max: ConsultasofflineMaxAggregateOutputType | null
  }

  export type ConsultasofflineAvgAggregateOutputType = {
    id: number | null
    idConsulta: number | null
    idStatusSolicitacaoIn100: number | null
  }

  export type ConsultasofflineSumAggregateOutputType = {
    id: number | null
    idConsulta: number | null
    idStatusSolicitacaoIn100: number | null
  }

  export type ConsultasofflineMinAggregateOutputType = {
    id: number | null
    idConsulta: number | null
    erroID: string | null
    idStatusSolicitacaoIn100: number | null
    situacao: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultasofflineMaxAggregateOutputType = {
    id: number | null
    idConsulta: number | null
    erroID: string | null
    idStatusSolicitacaoIn100: number | null
    situacao: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultasofflineCountAggregateOutputType = {
    id: number
    idConsulta: number
    erroID: number
    idStatusSolicitacaoIn100: number
    situacao: number
    resultado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConsultasofflineAvgAggregateInputType = {
    id?: true
    idConsulta?: true
    idStatusSolicitacaoIn100?: true
  }

  export type ConsultasofflineSumAggregateInputType = {
    id?: true
    idConsulta?: true
    idStatusSolicitacaoIn100?: true
  }

  export type ConsultasofflineMinAggregateInputType = {
    id?: true
    idConsulta?: true
    erroID?: true
    idStatusSolicitacaoIn100?: true
    situacao?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultasofflineMaxAggregateInputType = {
    id?: true
    idConsulta?: true
    erroID?: true
    idStatusSolicitacaoIn100?: true
    situacao?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultasofflineCountAggregateInputType = {
    id?: true
    idConsulta?: true
    erroID?: true
    idStatusSolicitacaoIn100?: true
    situacao?: true
    resultado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConsultasofflineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consultasoffline to aggregate.
     */
    where?: consultasofflineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultasofflines to fetch.
     */
    orderBy?: consultasofflineOrderByWithRelationInput | consultasofflineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consultasofflineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultasofflines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultasofflines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consultasofflines
    **/
    _count?: true | ConsultasofflineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultasofflineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultasofflineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultasofflineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultasofflineMaxAggregateInputType
  }

  export type GetConsultasofflineAggregateType<T extends ConsultasofflineAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultasoffline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultasoffline[P]>
      : GetScalarType<T[P], AggregateConsultasoffline[P]>
  }




  export type consultasofflineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consultasofflineWhereInput
    orderBy?: consultasofflineOrderByWithAggregationInput | consultasofflineOrderByWithAggregationInput[]
    by: ConsultasofflineScalarFieldEnum[] | ConsultasofflineScalarFieldEnum
    having?: consultasofflineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultasofflineCountAggregateInputType | true
    _avg?: ConsultasofflineAvgAggregateInputType
    _sum?: ConsultasofflineSumAggregateInputType
    _min?: ConsultasofflineMinAggregateInputType
    _max?: ConsultasofflineMaxAggregateInputType
  }

  export type ConsultasofflineGroupByOutputType = {
    id: number
    idConsulta: number
    erroID: string | null
    idStatusSolicitacaoIn100: number
    situacao: string | null
    resultado: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ConsultasofflineCountAggregateOutputType | null
    _avg: ConsultasofflineAvgAggregateOutputType | null
    _sum: ConsultasofflineSumAggregateOutputType | null
    _min: ConsultasofflineMinAggregateOutputType | null
    _max: ConsultasofflineMaxAggregateOutputType | null
  }

  type GetConsultasofflineGroupByPayload<T extends consultasofflineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultasofflineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultasofflineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultasofflineGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultasofflineGroupByOutputType[P]>
        }
      >
    >


  export type consultasofflineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idConsulta?: boolean
    erroID?: boolean
    idStatusSolicitacaoIn100?: boolean
    situacao?: boolean
    resultado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["consultasoffline"]>



  export type consultasofflineSelectScalar = {
    id?: boolean
    idConsulta?: boolean
    erroID?: boolean
    idStatusSolicitacaoIn100?: boolean
    situacao?: boolean
    resultado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type consultasofflineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idConsulta" | "erroID" | "idStatusSolicitacaoIn100" | "situacao" | "resultado" | "createdAt" | "updatedAt", ExtArgs["result"]["consultasoffline"]>

  export type $consultasofflinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consultasoffline"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idConsulta: number
      erroID: string | null
      idStatusSolicitacaoIn100: number
      situacao: string | null
      resultado: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["consultasoffline"]>
    composites: {}
  }

  type consultasofflineGetPayload<S extends boolean | null | undefined | consultasofflineDefaultArgs> = $Result.GetResult<Prisma.$consultasofflinePayload, S>

  type consultasofflineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<consultasofflineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsultasofflineCountAggregateInputType | true
    }

  export interface consultasofflineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consultasoffline'], meta: { name: 'consultasoffline' } }
    /**
     * Find zero or one Consultasoffline that matches the filter.
     * @param {consultasofflineFindUniqueArgs} args - Arguments to find a Consultasoffline
     * @example
     * // Get one Consultasoffline
     * const consultasoffline = await prisma.consultasoffline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consultasofflineFindUniqueArgs>(args: SelectSubset<T, consultasofflineFindUniqueArgs<ExtArgs>>): Prisma__consultasofflineClient<$Result.GetResult<Prisma.$consultasofflinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consultasoffline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {consultasofflineFindUniqueOrThrowArgs} args - Arguments to find a Consultasoffline
     * @example
     * // Get one Consultasoffline
     * const consultasoffline = await prisma.consultasoffline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consultasofflineFindUniqueOrThrowArgs>(args: SelectSubset<T, consultasofflineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consultasofflineClient<$Result.GetResult<Prisma.$consultasofflinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consultasoffline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasofflineFindFirstArgs} args - Arguments to find a Consultasoffline
     * @example
     * // Get one Consultasoffline
     * const consultasoffline = await prisma.consultasoffline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consultasofflineFindFirstArgs>(args?: SelectSubset<T, consultasofflineFindFirstArgs<ExtArgs>>): Prisma__consultasofflineClient<$Result.GetResult<Prisma.$consultasofflinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consultasoffline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasofflineFindFirstOrThrowArgs} args - Arguments to find a Consultasoffline
     * @example
     * // Get one Consultasoffline
     * const consultasoffline = await prisma.consultasoffline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consultasofflineFindFirstOrThrowArgs>(args?: SelectSubset<T, consultasofflineFindFirstOrThrowArgs<ExtArgs>>): Prisma__consultasofflineClient<$Result.GetResult<Prisma.$consultasofflinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consultasofflines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasofflineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consultasofflines
     * const consultasofflines = await prisma.consultasoffline.findMany()
     * 
     * // Get first 10 Consultasofflines
     * const consultasofflines = await prisma.consultasoffline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultasofflineWithIdOnly = await prisma.consultasoffline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends consultasofflineFindManyArgs>(args?: SelectSubset<T, consultasofflineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consultasofflinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consultasoffline.
     * @param {consultasofflineCreateArgs} args - Arguments to create a Consultasoffline.
     * @example
     * // Create one Consultasoffline
     * const Consultasoffline = await prisma.consultasoffline.create({
     *   data: {
     *     // ... data to create a Consultasoffline
     *   }
     * })
     * 
     */
    create<T extends consultasofflineCreateArgs>(args: SelectSubset<T, consultasofflineCreateArgs<ExtArgs>>): Prisma__consultasofflineClient<$Result.GetResult<Prisma.$consultasofflinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consultasofflines.
     * @param {consultasofflineCreateManyArgs} args - Arguments to create many Consultasofflines.
     * @example
     * // Create many Consultasofflines
     * const consultasoffline = await prisma.consultasoffline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consultasofflineCreateManyArgs>(args?: SelectSubset<T, consultasofflineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Consultasoffline.
     * @param {consultasofflineDeleteArgs} args - Arguments to delete one Consultasoffline.
     * @example
     * // Delete one Consultasoffline
     * const Consultasoffline = await prisma.consultasoffline.delete({
     *   where: {
     *     // ... filter to delete one Consultasoffline
     *   }
     * })
     * 
     */
    delete<T extends consultasofflineDeleteArgs>(args: SelectSubset<T, consultasofflineDeleteArgs<ExtArgs>>): Prisma__consultasofflineClient<$Result.GetResult<Prisma.$consultasofflinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consultasoffline.
     * @param {consultasofflineUpdateArgs} args - Arguments to update one Consultasoffline.
     * @example
     * // Update one Consultasoffline
     * const consultasoffline = await prisma.consultasoffline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consultasofflineUpdateArgs>(args: SelectSubset<T, consultasofflineUpdateArgs<ExtArgs>>): Prisma__consultasofflineClient<$Result.GetResult<Prisma.$consultasofflinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consultasofflines.
     * @param {consultasofflineDeleteManyArgs} args - Arguments to filter Consultasofflines to delete.
     * @example
     * // Delete a few Consultasofflines
     * const { count } = await prisma.consultasoffline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consultasofflineDeleteManyArgs>(args?: SelectSubset<T, consultasofflineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultasofflines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasofflineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consultasofflines
     * const consultasoffline = await prisma.consultasoffline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consultasofflineUpdateManyArgs>(args: SelectSubset<T, consultasofflineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Consultasoffline.
     * @param {consultasofflineUpsertArgs} args - Arguments to update or create a Consultasoffline.
     * @example
     * // Update or create a Consultasoffline
     * const consultasoffline = await prisma.consultasoffline.upsert({
     *   create: {
     *     // ... data to create a Consultasoffline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consultasoffline we want to update
     *   }
     * })
     */
    upsert<T extends consultasofflineUpsertArgs>(args: SelectSubset<T, consultasofflineUpsertArgs<ExtArgs>>): Prisma__consultasofflineClient<$Result.GetResult<Prisma.$consultasofflinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Consultasofflines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasofflineCountArgs} args - Arguments to filter Consultasofflines to count.
     * @example
     * // Count the number of Consultasofflines
     * const count = await prisma.consultasoffline.count({
     *   where: {
     *     // ... the filter for the Consultasofflines we want to count
     *   }
     * })
    **/
    count<T extends consultasofflineCountArgs>(
      args?: Subset<T, consultasofflineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultasofflineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consultasoffline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultasofflineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultasofflineAggregateArgs>(args: Subset<T, ConsultasofflineAggregateArgs>): Prisma.PrismaPromise<GetConsultasofflineAggregateType<T>>

    /**
     * Group by Consultasoffline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasofflineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consultasofflineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consultasofflineGroupByArgs['orderBy'] }
        : { orderBy?: consultasofflineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consultasofflineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultasofflineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consultasoffline model
   */
  readonly fields: consultasofflineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consultasoffline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consultasofflineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consultasoffline model
   */
  interface consultasofflineFieldRefs {
    readonly id: FieldRef<"consultasoffline", 'Int'>
    readonly idConsulta: FieldRef<"consultasoffline", 'Int'>
    readonly erroID: FieldRef<"consultasoffline", 'String'>
    readonly idStatusSolicitacaoIn100: FieldRef<"consultasoffline", 'Int'>
    readonly situacao: FieldRef<"consultasoffline", 'String'>
    readonly resultado: FieldRef<"consultasoffline", 'Json'>
    readonly createdAt: FieldRef<"consultasoffline", 'DateTime'>
    readonly updatedAt: FieldRef<"consultasoffline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * consultasoffline findUnique
   */
  export type consultasofflineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasoffline
     */
    select?: consultasofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasoffline
     */
    omit?: consultasofflineOmit<ExtArgs> | null
    /**
     * Filter, which consultasoffline to fetch.
     */
    where: consultasofflineWhereUniqueInput
  }

  /**
   * consultasoffline findUniqueOrThrow
   */
  export type consultasofflineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasoffline
     */
    select?: consultasofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasoffline
     */
    omit?: consultasofflineOmit<ExtArgs> | null
    /**
     * Filter, which consultasoffline to fetch.
     */
    where: consultasofflineWhereUniqueInput
  }

  /**
   * consultasoffline findFirst
   */
  export type consultasofflineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasoffline
     */
    select?: consultasofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasoffline
     */
    omit?: consultasofflineOmit<ExtArgs> | null
    /**
     * Filter, which consultasoffline to fetch.
     */
    where?: consultasofflineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultasofflines to fetch.
     */
    orderBy?: consultasofflineOrderByWithRelationInput | consultasofflineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consultasofflines.
     */
    cursor?: consultasofflineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultasofflines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultasofflines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consultasofflines.
     */
    distinct?: ConsultasofflineScalarFieldEnum | ConsultasofflineScalarFieldEnum[]
  }

  /**
   * consultasoffline findFirstOrThrow
   */
  export type consultasofflineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasoffline
     */
    select?: consultasofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasoffline
     */
    omit?: consultasofflineOmit<ExtArgs> | null
    /**
     * Filter, which consultasoffline to fetch.
     */
    where?: consultasofflineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultasofflines to fetch.
     */
    orderBy?: consultasofflineOrderByWithRelationInput | consultasofflineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consultasofflines.
     */
    cursor?: consultasofflineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultasofflines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultasofflines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consultasofflines.
     */
    distinct?: ConsultasofflineScalarFieldEnum | ConsultasofflineScalarFieldEnum[]
  }

  /**
   * consultasoffline findMany
   */
  export type consultasofflineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasoffline
     */
    select?: consultasofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasoffline
     */
    omit?: consultasofflineOmit<ExtArgs> | null
    /**
     * Filter, which consultasofflines to fetch.
     */
    where?: consultasofflineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultasofflines to fetch.
     */
    orderBy?: consultasofflineOrderByWithRelationInput | consultasofflineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consultasofflines.
     */
    cursor?: consultasofflineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultasofflines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultasofflines.
     */
    skip?: number
    distinct?: ConsultasofflineScalarFieldEnum | ConsultasofflineScalarFieldEnum[]
  }

  /**
   * consultasoffline create
   */
  export type consultasofflineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasoffline
     */
    select?: consultasofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasoffline
     */
    omit?: consultasofflineOmit<ExtArgs> | null
    /**
     * The data needed to create a consultasoffline.
     */
    data: XOR<consultasofflineCreateInput, consultasofflineUncheckedCreateInput>
  }

  /**
   * consultasoffline createMany
   */
  export type consultasofflineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consultasofflines.
     */
    data: consultasofflineCreateManyInput | consultasofflineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consultasoffline update
   */
  export type consultasofflineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasoffline
     */
    select?: consultasofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasoffline
     */
    omit?: consultasofflineOmit<ExtArgs> | null
    /**
     * The data needed to update a consultasoffline.
     */
    data: XOR<consultasofflineUpdateInput, consultasofflineUncheckedUpdateInput>
    /**
     * Choose, which consultasoffline to update.
     */
    where: consultasofflineWhereUniqueInput
  }

  /**
   * consultasoffline updateMany
   */
  export type consultasofflineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consultasofflines.
     */
    data: XOR<consultasofflineUpdateManyMutationInput, consultasofflineUncheckedUpdateManyInput>
    /**
     * Filter which consultasofflines to update
     */
    where?: consultasofflineWhereInput
    /**
     * Limit how many consultasofflines to update.
     */
    limit?: number
  }

  /**
   * consultasoffline upsert
   */
  export type consultasofflineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasoffline
     */
    select?: consultasofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasoffline
     */
    omit?: consultasofflineOmit<ExtArgs> | null
    /**
     * The filter to search for the consultasoffline to update in case it exists.
     */
    where: consultasofflineWhereUniqueInput
    /**
     * In case the consultasoffline found by the `where` argument doesn't exist, create a new consultasoffline with this data.
     */
    create: XOR<consultasofflineCreateInput, consultasofflineUncheckedCreateInput>
    /**
     * In case the consultasoffline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consultasofflineUpdateInput, consultasofflineUncheckedUpdateInput>
  }

  /**
   * consultasoffline delete
   */
  export type consultasofflineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasoffline
     */
    select?: consultasofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasoffline
     */
    omit?: consultasofflineOmit<ExtArgs> | null
    /**
     * Filter which consultasoffline to delete.
     */
    where: consultasofflineWhereUniqueInput
  }

  /**
   * consultasoffline deleteMany
   */
  export type consultasofflineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consultasofflines to delete
     */
    where?: consultasofflineWhereInput
    /**
     * Limit how many consultasofflines to delete.
     */
    limit?: number
  }

  /**
   * consultasoffline without action
   */
  export type consultasofflineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasoffline
     */
    select?: consultasofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasoffline
     */
    omit?: consultasofflineOmit<ExtArgs> | null
  }


  /**
   * Model consultasofflinesiape
   */

  export type AggregateConsultasofflinesiape = {
    _count: ConsultasofflinesiapeCountAggregateOutputType | null
    _avg: ConsultasofflinesiapeAvgAggregateOutputType | null
    _sum: ConsultasofflinesiapeSumAggregateOutputType | null
    _min: ConsultasofflinesiapeMinAggregateOutputType | null
    _max: ConsultasofflinesiapeMaxAggregateOutputType | null
  }

  export type ConsultasofflinesiapeAvgAggregateOutputType = {
    id: number | null
    idConsulta: number | null
  }

  export type ConsultasofflinesiapeSumAggregateOutputType = {
    id: number | null
    idConsulta: number | null
  }

  export type ConsultasofflinesiapeMinAggregateOutputType = {
    id: number | null
    idConsulta: number | null
    situacao: string | null
    erroID: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultasofflinesiapeMaxAggregateOutputType = {
    id: number | null
    idConsulta: number | null
    situacao: string | null
    erroID: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultasofflinesiapeCountAggregateOutputType = {
    id: number
    idConsulta: number
    situacao: number
    erroID: number
    resultado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConsultasofflinesiapeAvgAggregateInputType = {
    id?: true
    idConsulta?: true
  }

  export type ConsultasofflinesiapeSumAggregateInputType = {
    id?: true
    idConsulta?: true
  }

  export type ConsultasofflinesiapeMinAggregateInputType = {
    id?: true
    idConsulta?: true
    situacao?: true
    erroID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultasofflinesiapeMaxAggregateInputType = {
    id?: true
    idConsulta?: true
    situacao?: true
    erroID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultasofflinesiapeCountAggregateInputType = {
    id?: true
    idConsulta?: true
    situacao?: true
    erroID?: true
    resultado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConsultasofflinesiapeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consultasofflinesiape to aggregate.
     */
    where?: consultasofflinesiapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultasofflinesiapes to fetch.
     */
    orderBy?: consultasofflinesiapeOrderByWithRelationInput | consultasofflinesiapeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consultasofflinesiapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultasofflinesiapes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultasofflinesiapes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consultasofflinesiapes
    **/
    _count?: true | ConsultasofflinesiapeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultasofflinesiapeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultasofflinesiapeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultasofflinesiapeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultasofflinesiapeMaxAggregateInputType
  }

  export type GetConsultasofflinesiapeAggregateType<T extends ConsultasofflinesiapeAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultasofflinesiape]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultasofflinesiape[P]>
      : GetScalarType<T[P], AggregateConsultasofflinesiape[P]>
  }




  export type consultasofflinesiapeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consultasofflinesiapeWhereInput
    orderBy?: consultasofflinesiapeOrderByWithAggregationInput | consultasofflinesiapeOrderByWithAggregationInput[]
    by: ConsultasofflinesiapeScalarFieldEnum[] | ConsultasofflinesiapeScalarFieldEnum
    having?: consultasofflinesiapeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultasofflinesiapeCountAggregateInputType | true
    _avg?: ConsultasofflinesiapeAvgAggregateInputType
    _sum?: ConsultasofflinesiapeSumAggregateInputType
    _min?: ConsultasofflinesiapeMinAggregateInputType
    _max?: ConsultasofflinesiapeMaxAggregateInputType
  }

  export type ConsultasofflinesiapeGroupByOutputType = {
    id: number
    idConsulta: number
    situacao: string | null
    erroID: string | null
    resultado: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ConsultasofflinesiapeCountAggregateOutputType | null
    _avg: ConsultasofflinesiapeAvgAggregateOutputType | null
    _sum: ConsultasofflinesiapeSumAggregateOutputType | null
    _min: ConsultasofflinesiapeMinAggregateOutputType | null
    _max: ConsultasofflinesiapeMaxAggregateOutputType | null
  }

  type GetConsultasofflinesiapeGroupByPayload<T extends consultasofflinesiapeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultasofflinesiapeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultasofflinesiapeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultasofflinesiapeGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultasofflinesiapeGroupByOutputType[P]>
        }
      >
    >


  export type consultasofflinesiapeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idConsulta?: boolean
    situacao?: boolean
    erroID?: boolean
    resultado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["consultasofflinesiape"]>



  export type consultasofflinesiapeSelectScalar = {
    id?: boolean
    idConsulta?: boolean
    situacao?: boolean
    erroID?: boolean
    resultado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type consultasofflinesiapeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idConsulta" | "situacao" | "erroID" | "resultado" | "createdAt" | "updatedAt", ExtArgs["result"]["consultasofflinesiape"]>

  export type $consultasofflinesiapePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consultasofflinesiape"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idConsulta: number
      situacao: string | null
      erroID: string | null
      resultado: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["consultasofflinesiape"]>
    composites: {}
  }

  type consultasofflinesiapeGetPayload<S extends boolean | null | undefined | consultasofflinesiapeDefaultArgs> = $Result.GetResult<Prisma.$consultasofflinesiapePayload, S>

  type consultasofflinesiapeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<consultasofflinesiapeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsultasofflinesiapeCountAggregateInputType | true
    }

  export interface consultasofflinesiapeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consultasofflinesiape'], meta: { name: 'consultasofflinesiape' } }
    /**
     * Find zero or one Consultasofflinesiape that matches the filter.
     * @param {consultasofflinesiapeFindUniqueArgs} args - Arguments to find a Consultasofflinesiape
     * @example
     * // Get one Consultasofflinesiape
     * const consultasofflinesiape = await prisma.consultasofflinesiape.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consultasofflinesiapeFindUniqueArgs>(args: SelectSubset<T, consultasofflinesiapeFindUniqueArgs<ExtArgs>>): Prisma__consultasofflinesiapeClient<$Result.GetResult<Prisma.$consultasofflinesiapePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consultasofflinesiape that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {consultasofflinesiapeFindUniqueOrThrowArgs} args - Arguments to find a Consultasofflinesiape
     * @example
     * // Get one Consultasofflinesiape
     * const consultasofflinesiape = await prisma.consultasofflinesiape.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consultasofflinesiapeFindUniqueOrThrowArgs>(args: SelectSubset<T, consultasofflinesiapeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consultasofflinesiapeClient<$Result.GetResult<Prisma.$consultasofflinesiapePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consultasofflinesiape that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasofflinesiapeFindFirstArgs} args - Arguments to find a Consultasofflinesiape
     * @example
     * // Get one Consultasofflinesiape
     * const consultasofflinesiape = await prisma.consultasofflinesiape.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consultasofflinesiapeFindFirstArgs>(args?: SelectSubset<T, consultasofflinesiapeFindFirstArgs<ExtArgs>>): Prisma__consultasofflinesiapeClient<$Result.GetResult<Prisma.$consultasofflinesiapePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consultasofflinesiape that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasofflinesiapeFindFirstOrThrowArgs} args - Arguments to find a Consultasofflinesiape
     * @example
     * // Get one Consultasofflinesiape
     * const consultasofflinesiape = await prisma.consultasofflinesiape.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consultasofflinesiapeFindFirstOrThrowArgs>(args?: SelectSubset<T, consultasofflinesiapeFindFirstOrThrowArgs<ExtArgs>>): Prisma__consultasofflinesiapeClient<$Result.GetResult<Prisma.$consultasofflinesiapePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consultasofflinesiapes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasofflinesiapeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consultasofflinesiapes
     * const consultasofflinesiapes = await prisma.consultasofflinesiape.findMany()
     * 
     * // Get first 10 Consultasofflinesiapes
     * const consultasofflinesiapes = await prisma.consultasofflinesiape.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultasofflinesiapeWithIdOnly = await prisma.consultasofflinesiape.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends consultasofflinesiapeFindManyArgs>(args?: SelectSubset<T, consultasofflinesiapeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consultasofflinesiapePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consultasofflinesiape.
     * @param {consultasofflinesiapeCreateArgs} args - Arguments to create a Consultasofflinesiape.
     * @example
     * // Create one Consultasofflinesiape
     * const Consultasofflinesiape = await prisma.consultasofflinesiape.create({
     *   data: {
     *     // ... data to create a Consultasofflinesiape
     *   }
     * })
     * 
     */
    create<T extends consultasofflinesiapeCreateArgs>(args: SelectSubset<T, consultasofflinesiapeCreateArgs<ExtArgs>>): Prisma__consultasofflinesiapeClient<$Result.GetResult<Prisma.$consultasofflinesiapePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consultasofflinesiapes.
     * @param {consultasofflinesiapeCreateManyArgs} args - Arguments to create many Consultasofflinesiapes.
     * @example
     * // Create many Consultasofflinesiapes
     * const consultasofflinesiape = await prisma.consultasofflinesiape.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consultasofflinesiapeCreateManyArgs>(args?: SelectSubset<T, consultasofflinesiapeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Consultasofflinesiape.
     * @param {consultasofflinesiapeDeleteArgs} args - Arguments to delete one Consultasofflinesiape.
     * @example
     * // Delete one Consultasofflinesiape
     * const Consultasofflinesiape = await prisma.consultasofflinesiape.delete({
     *   where: {
     *     // ... filter to delete one Consultasofflinesiape
     *   }
     * })
     * 
     */
    delete<T extends consultasofflinesiapeDeleteArgs>(args: SelectSubset<T, consultasofflinesiapeDeleteArgs<ExtArgs>>): Prisma__consultasofflinesiapeClient<$Result.GetResult<Prisma.$consultasofflinesiapePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consultasofflinesiape.
     * @param {consultasofflinesiapeUpdateArgs} args - Arguments to update one Consultasofflinesiape.
     * @example
     * // Update one Consultasofflinesiape
     * const consultasofflinesiape = await prisma.consultasofflinesiape.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consultasofflinesiapeUpdateArgs>(args: SelectSubset<T, consultasofflinesiapeUpdateArgs<ExtArgs>>): Prisma__consultasofflinesiapeClient<$Result.GetResult<Prisma.$consultasofflinesiapePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consultasofflinesiapes.
     * @param {consultasofflinesiapeDeleteManyArgs} args - Arguments to filter Consultasofflinesiapes to delete.
     * @example
     * // Delete a few Consultasofflinesiapes
     * const { count } = await prisma.consultasofflinesiape.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consultasofflinesiapeDeleteManyArgs>(args?: SelectSubset<T, consultasofflinesiapeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultasofflinesiapes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasofflinesiapeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consultasofflinesiapes
     * const consultasofflinesiape = await prisma.consultasofflinesiape.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consultasofflinesiapeUpdateManyArgs>(args: SelectSubset<T, consultasofflinesiapeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Consultasofflinesiape.
     * @param {consultasofflinesiapeUpsertArgs} args - Arguments to update or create a Consultasofflinesiape.
     * @example
     * // Update or create a Consultasofflinesiape
     * const consultasofflinesiape = await prisma.consultasofflinesiape.upsert({
     *   create: {
     *     // ... data to create a Consultasofflinesiape
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consultasofflinesiape we want to update
     *   }
     * })
     */
    upsert<T extends consultasofflinesiapeUpsertArgs>(args: SelectSubset<T, consultasofflinesiapeUpsertArgs<ExtArgs>>): Prisma__consultasofflinesiapeClient<$Result.GetResult<Prisma.$consultasofflinesiapePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Consultasofflinesiapes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasofflinesiapeCountArgs} args - Arguments to filter Consultasofflinesiapes to count.
     * @example
     * // Count the number of Consultasofflinesiapes
     * const count = await prisma.consultasofflinesiape.count({
     *   where: {
     *     // ... the filter for the Consultasofflinesiapes we want to count
     *   }
     * })
    **/
    count<T extends consultasofflinesiapeCountArgs>(
      args?: Subset<T, consultasofflinesiapeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultasofflinesiapeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consultasofflinesiape.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultasofflinesiapeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultasofflinesiapeAggregateArgs>(args: Subset<T, ConsultasofflinesiapeAggregateArgs>): Prisma.PrismaPromise<GetConsultasofflinesiapeAggregateType<T>>

    /**
     * Group by Consultasofflinesiape.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consultasofflinesiapeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consultasofflinesiapeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consultasofflinesiapeGroupByArgs['orderBy'] }
        : { orderBy?: consultasofflinesiapeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consultasofflinesiapeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultasofflinesiapeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consultasofflinesiape model
   */
  readonly fields: consultasofflinesiapeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consultasofflinesiape.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consultasofflinesiapeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consultasofflinesiape model
   */
  interface consultasofflinesiapeFieldRefs {
    readonly id: FieldRef<"consultasofflinesiape", 'Int'>
    readonly idConsulta: FieldRef<"consultasofflinesiape", 'Int'>
    readonly situacao: FieldRef<"consultasofflinesiape", 'String'>
    readonly erroID: FieldRef<"consultasofflinesiape", 'String'>
    readonly resultado: FieldRef<"consultasofflinesiape", 'Json'>
    readonly createdAt: FieldRef<"consultasofflinesiape", 'DateTime'>
    readonly updatedAt: FieldRef<"consultasofflinesiape", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * consultasofflinesiape findUnique
   */
  export type consultasofflinesiapeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasofflinesiape
     */
    select?: consultasofflinesiapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasofflinesiape
     */
    omit?: consultasofflinesiapeOmit<ExtArgs> | null
    /**
     * Filter, which consultasofflinesiape to fetch.
     */
    where: consultasofflinesiapeWhereUniqueInput
  }

  /**
   * consultasofflinesiape findUniqueOrThrow
   */
  export type consultasofflinesiapeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasofflinesiape
     */
    select?: consultasofflinesiapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasofflinesiape
     */
    omit?: consultasofflinesiapeOmit<ExtArgs> | null
    /**
     * Filter, which consultasofflinesiape to fetch.
     */
    where: consultasofflinesiapeWhereUniqueInput
  }

  /**
   * consultasofflinesiape findFirst
   */
  export type consultasofflinesiapeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasofflinesiape
     */
    select?: consultasofflinesiapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasofflinesiape
     */
    omit?: consultasofflinesiapeOmit<ExtArgs> | null
    /**
     * Filter, which consultasofflinesiape to fetch.
     */
    where?: consultasofflinesiapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultasofflinesiapes to fetch.
     */
    orderBy?: consultasofflinesiapeOrderByWithRelationInput | consultasofflinesiapeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consultasofflinesiapes.
     */
    cursor?: consultasofflinesiapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultasofflinesiapes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultasofflinesiapes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consultasofflinesiapes.
     */
    distinct?: ConsultasofflinesiapeScalarFieldEnum | ConsultasofflinesiapeScalarFieldEnum[]
  }

  /**
   * consultasofflinesiape findFirstOrThrow
   */
  export type consultasofflinesiapeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasofflinesiape
     */
    select?: consultasofflinesiapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasofflinesiape
     */
    omit?: consultasofflinesiapeOmit<ExtArgs> | null
    /**
     * Filter, which consultasofflinesiape to fetch.
     */
    where?: consultasofflinesiapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultasofflinesiapes to fetch.
     */
    orderBy?: consultasofflinesiapeOrderByWithRelationInput | consultasofflinesiapeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consultasofflinesiapes.
     */
    cursor?: consultasofflinesiapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultasofflinesiapes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultasofflinesiapes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consultasofflinesiapes.
     */
    distinct?: ConsultasofflinesiapeScalarFieldEnum | ConsultasofflinesiapeScalarFieldEnum[]
  }

  /**
   * consultasofflinesiape findMany
   */
  export type consultasofflinesiapeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasofflinesiape
     */
    select?: consultasofflinesiapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasofflinesiape
     */
    omit?: consultasofflinesiapeOmit<ExtArgs> | null
    /**
     * Filter, which consultasofflinesiapes to fetch.
     */
    where?: consultasofflinesiapeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consultasofflinesiapes to fetch.
     */
    orderBy?: consultasofflinesiapeOrderByWithRelationInput | consultasofflinesiapeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consultasofflinesiapes.
     */
    cursor?: consultasofflinesiapeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consultasofflinesiapes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consultasofflinesiapes.
     */
    skip?: number
    distinct?: ConsultasofflinesiapeScalarFieldEnum | ConsultasofflinesiapeScalarFieldEnum[]
  }

  /**
   * consultasofflinesiape create
   */
  export type consultasofflinesiapeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasofflinesiape
     */
    select?: consultasofflinesiapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasofflinesiape
     */
    omit?: consultasofflinesiapeOmit<ExtArgs> | null
    /**
     * The data needed to create a consultasofflinesiape.
     */
    data: XOR<consultasofflinesiapeCreateInput, consultasofflinesiapeUncheckedCreateInput>
  }

  /**
   * consultasofflinesiape createMany
   */
  export type consultasofflinesiapeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consultasofflinesiapes.
     */
    data: consultasofflinesiapeCreateManyInput | consultasofflinesiapeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consultasofflinesiape update
   */
  export type consultasofflinesiapeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasofflinesiape
     */
    select?: consultasofflinesiapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasofflinesiape
     */
    omit?: consultasofflinesiapeOmit<ExtArgs> | null
    /**
     * The data needed to update a consultasofflinesiape.
     */
    data: XOR<consultasofflinesiapeUpdateInput, consultasofflinesiapeUncheckedUpdateInput>
    /**
     * Choose, which consultasofflinesiape to update.
     */
    where: consultasofflinesiapeWhereUniqueInput
  }

  /**
   * consultasofflinesiape updateMany
   */
  export type consultasofflinesiapeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consultasofflinesiapes.
     */
    data: XOR<consultasofflinesiapeUpdateManyMutationInput, consultasofflinesiapeUncheckedUpdateManyInput>
    /**
     * Filter which consultasofflinesiapes to update
     */
    where?: consultasofflinesiapeWhereInput
    /**
     * Limit how many consultasofflinesiapes to update.
     */
    limit?: number
  }

  /**
   * consultasofflinesiape upsert
   */
  export type consultasofflinesiapeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasofflinesiape
     */
    select?: consultasofflinesiapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasofflinesiape
     */
    omit?: consultasofflinesiapeOmit<ExtArgs> | null
    /**
     * The filter to search for the consultasofflinesiape to update in case it exists.
     */
    where: consultasofflinesiapeWhereUniqueInput
    /**
     * In case the consultasofflinesiape found by the `where` argument doesn't exist, create a new consultasofflinesiape with this data.
     */
    create: XOR<consultasofflinesiapeCreateInput, consultasofflinesiapeUncheckedCreateInput>
    /**
     * In case the consultasofflinesiape was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consultasofflinesiapeUpdateInput, consultasofflinesiapeUncheckedUpdateInput>
  }

  /**
   * consultasofflinesiape delete
   */
  export type consultasofflinesiapeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasofflinesiape
     */
    select?: consultasofflinesiapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasofflinesiape
     */
    omit?: consultasofflinesiapeOmit<ExtArgs> | null
    /**
     * Filter which consultasofflinesiape to delete.
     */
    where: consultasofflinesiapeWhereUniqueInput
  }

  /**
   * consultasofflinesiape deleteMany
   */
  export type consultasofflinesiapeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consultasofflinesiapes to delete
     */
    where?: consultasofflinesiapeWhereInput
    /**
     * Limit how many consultasofflinesiapes to delete.
     */
    limit?: number
  }

  /**
   * consultasofflinesiape without action
   */
  export type consultasofflinesiapeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consultasofflinesiape
     */
    select?: consultasofflinesiapeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consultasofflinesiape
     */
    omit?: consultasofflinesiapeOmit<ExtArgs> | null
  }


  /**
   * Model credito
   */

  export type AggregateCredito = {
    _count: CreditoCountAggregateOutputType | null
    _avg: CreditoAvgAggregateOutputType | null
    _sum: CreditoSumAggregateOutputType | null
    _min: CreditoMinAggregateOutputType | null
    _max: CreditoMaxAggregateOutputType | null
  }

  export type CreditoAvgAggregateOutputType = {
    id: number | null
    valorun: number | null
    vendedor: number | null
    idusu_cli: number | null
    tiposervico: number | null
    qtdecreditos: number | null
    qtderestante: number | null
    qtdeutilizada: number | null
  }

  export type CreditoSumAggregateOutputType = {
    id: number | null
    valorun: number | null
    vendedor: number | null
    idusu_cli: number | null
    tiposervico: number | null
    qtdecreditos: number | null
    qtderestante: number | null
    qtdeutilizada: number | null
  }

  export type CreditoMinAggregateOutputType = {
    id: number | null
    datahora: Date | null
    valorun: number | null
    vendedor: number | null
    createdAt: Date | null
    updatedAt: Date | null
    idusu_cli: number | null
    tiposervico: number | null
    qtdecreditos: number | null
    qtderestante: number | null
    qtdeutilizada: number | null
  }

  export type CreditoMaxAggregateOutputType = {
    id: number | null
    datahora: Date | null
    valorun: number | null
    vendedor: number | null
    createdAt: Date | null
    updatedAt: Date | null
    idusu_cli: number | null
    tiposervico: number | null
    qtdecreditos: number | null
    qtderestante: number | null
    qtdeutilizada: number | null
  }

  export type CreditoCountAggregateOutputType = {
    id: number
    datahora: number
    valorun: number
    vendedor: number
    createdAt: number
    updatedAt: number
    idusu_cli: number
    tiposervico: number
    qtdecreditos: number
    qtderestante: number
    qtdeutilizada: number
    _all: number
  }


  export type CreditoAvgAggregateInputType = {
    id?: true
    valorun?: true
    vendedor?: true
    idusu_cli?: true
    tiposervico?: true
    qtdecreditos?: true
    qtderestante?: true
    qtdeutilizada?: true
  }

  export type CreditoSumAggregateInputType = {
    id?: true
    valorun?: true
    vendedor?: true
    idusu_cli?: true
    tiposervico?: true
    qtdecreditos?: true
    qtderestante?: true
    qtdeutilizada?: true
  }

  export type CreditoMinAggregateInputType = {
    id?: true
    datahora?: true
    valorun?: true
    vendedor?: true
    createdAt?: true
    updatedAt?: true
    idusu_cli?: true
    tiposervico?: true
    qtdecreditos?: true
    qtderestante?: true
    qtdeutilizada?: true
  }

  export type CreditoMaxAggregateInputType = {
    id?: true
    datahora?: true
    valorun?: true
    vendedor?: true
    createdAt?: true
    updatedAt?: true
    idusu_cli?: true
    tiposervico?: true
    qtdecreditos?: true
    qtderestante?: true
    qtdeutilizada?: true
  }

  export type CreditoCountAggregateInputType = {
    id?: true
    datahora?: true
    valorun?: true
    vendedor?: true
    createdAt?: true
    updatedAt?: true
    idusu_cli?: true
    tiposervico?: true
    qtdecreditos?: true
    qtderestante?: true
    qtdeutilizada?: true
    _all?: true
  }

  export type CreditoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credito to aggregate.
     */
    where?: creditoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of creditos to fetch.
     */
    orderBy?: creditoOrderByWithRelationInput | creditoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: creditoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` creditos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` creditos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned creditos
    **/
    _count?: true | CreditoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditoMaxAggregateInputType
  }

  export type GetCreditoAggregateType<T extends CreditoAggregateArgs> = {
        [P in keyof T & keyof AggregateCredito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredito[P]>
      : GetScalarType<T[P], AggregateCredito[P]>
  }




  export type creditoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: creditoWhereInput
    orderBy?: creditoOrderByWithAggregationInput | creditoOrderByWithAggregationInput[]
    by: CreditoScalarFieldEnum[] | CreditoScalarFieldEnum
    having?: creditoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditoCountAggregateInputType | true
    _avg?: CreditoAvgAggregateInputType
    _sum?: CreditoSumAggregateInputType
    _min?: CreditoMinAggregateInputType
    _max?: CreditoMaxAggregateInputType
  }

  export type CreditoGroupByOutputType = {
    id: number
    datahora: Date
    valorun: number | null
    vendedor: number
    createdAt: Date
    updatedAt: Date
    idusu_cli: number
    tiposervico: number
    qtdecreditos: number
    qtderestante: number
    qtdeutilizada: number
    _count: CreditoCountAggregateOutputType | null
    _avg: CreditoAvgAggregateOutputType | null
    _sum: CreditoSumAggregateOutputType | null
    _min: CreditoMinAggregateOutputType | null
    _max: CreditoMaxAggregateOutputType | null
  }

  type GetCreditoGroupByPayload<T extends creditoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditoGroupByOutputType[P]>
            : GetScalarType<T[P], CreditoGroupByOutputType[P]>
        }
      >
    >


  export type creditoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datahora?: boolean
    valorun?: boolean
    vendedor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idusu_cli?: boolean
    tiposervico?: boolean
    qtdecreditos?: boolean
    qtderestante?: boolean
    qtdeutilizada?: boolean
  }, ExtArgs["result"]["credito"]>



  export type creditoSelectScalar = {
    id?: boolean
    datahora?: boolean
    valorun?: boolean
    vendedor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idusu_cli?: boolean
    tiposervico?: boolean
    qtdecreditos?: boolean
    qtderestante?: boolean
    qtdeutilizada?: boolean
  }

  export type creditoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "datahora" | "valorun" | "vendedor" | "createdAt" | "updatedAt" | "idusu_cli" | "tiposervico" | "qtdecreditos" | "qtderestante" | "qtdeutilizada", ExtArgs["result"]["credito"]>

  export type $creditoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "credito"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      datahora: Date
      valorun: number | null
      vendedor: number
      createdAt: Date
      updatedAt: Date
      idusu_cli: number
      tiposervico: number
      qtdecreditos: number
      qtderestante: number
      qtdeutilizada: number
    }, ExtArgs["result"]["credito"]>
    composites: {}
  }

  type creditoGetPayload<S extends boolean | null | undefined | creditoDefaultArgs> = $Result.GetResult<Prisma.$creditoPayload, S>

  type creditoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<creditoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditoCountAggregateInputType | true
    }

  export interface creditoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['credito'], meta: { name: 'credito' } }
    /**
     * Find zero or one Credito that matches the filter.
     * @param {creditoFindUniqueArgs} args - Arguments to find a Credito
     * @example
     * // Get one Credito
     * const credito = await prisma.credito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends creditoFindUniqueArgs>(args: SelectSubset<T, creditoFindUniqueArgs<ExtArgs>>): Prisma__creditoClient<$Result.GetResult<Prisma.$creditoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Credito that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {creditoFindUniqueOrThrowArgs} args - Arguments to find a Credito
     * @example
     * // Get one Credito
     * const credito = await prisma.credito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends creditoFindUniqueOrThrowArgs>(args: SelectSubset<T, creditoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__creditoClient<$Result.GetResult<Prisma.$creditoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {creditoFindFirstArgs} args - Arguments to find a Credito
     * @example
     * // Get one Credito
     * const credito = await prisma.credito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends creditoFindFirstArgs>(args?: SelectSubset<T, creditoFindFirstArgs<ExtArgs>>): Prisma__creditoClient<$Result.GetResult<Prisma.$creditoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {creditoFindFirstOrThrowArgs} args - Arguments to find a Credito
     * @example
     * // Get one Credito
     * const credito = await prisma.credito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends creditoFindFirstOrThrowArgs>(args?: SelectSubset<T, creditoFindFirstOrThrowArgs<ExtArgs>>): Prisma__creditoClient<$Result.GetResult<Prisma.$creditoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Creditos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {creditoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Creditos
     * const creditos = await prisma.credito.findMany()
     * 
     * // Get first 10 Creditos
     * const creditos = await prisma.credito.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditoWithIdOnly = await prisma.credito.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends creditoFindManyArgs>(args?: SelectSubset<T, creditoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$creditoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Credito.
     * @param {creditoCreateArgs} args - Arguments to create a Credito.
     * @example
     * // Create one Credito
     * const Credito = await prisma.credito.create({
     *   data: {
     *     // ... data to create a Credito
     *   }
     * })
     * 
     */
    create<T extends creditoCreateArgs>(args: SelectSubset<T, creditoCreateArgs<ExtArgs>>): Prisma__creditoClient<$Result.GetResult<Prisma.$creditoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Creditos.
     * @param {creditoCreateManyArgs} args - Arguments to create many Creditos.
     * @example
     * // Create many Creditos
     * const credito = await prisma.credito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends creditoCreateManyArgs>(args?: SelectSubset<T, creditoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Credito.
     * @param {creditoDeleteArgs} args - Arguments to delete one Credito.
     * @example
     * // Delete one Credito
     * const Credito = await prisma.credito.delete({
     *   where: {
     *     // ... filter to delete one Credito
     *   }
     * })
     * 
     */
    delete<T extends creditoDeleteArgs>(args: SelectSubset<T, creditoDeleteArgs<ExtArgs>>): Prisma__creditoClient<$Result.GetResult<Prisma.$creditoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Credito.
     * @param {creditoUpdateArgs} args - Arguments to update one Credito.
     * @example
     * // Update one Credito
     * const credito = await prisma.credito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends creditoUpdateArgs>(args: SelectSubset<T, creditoUpdateArgs<ExtArgs>>): Prisma__creditoClient<$Result.GetResult<Prisma.$creditoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Creditos.
     * @param {creditoDeleteManyArgs} args - Arguments to filter Creditos to delete.
     * @example
     * // Delete a few Creditos
     * const { count } = await prisma.credito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends creditoDeleteManyArgs>(args?: SelectSubset<T, creditoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creditos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {creditoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Creditos
     * const credito = await prisma.credito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends creditoUpdateManyArgs>(args: SelectSubset<T, creditoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Credito.
     * @param {creditoUpsertArgs} args - Arguments to update or create a Credito.
     * @example
     * // Update or create a Credito
     * const credito = await prisma.credito.upsert({
     *   create: {
     *     // ... data to create a Credito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credito we want to update
     *   }
     * })
     */
    upsert<T extends creditoUpsertArgs>(args: SelectSubset<T, creditoUpsertArgs<ExtArgs>>): Prisma__creditoClient<$Result.GetResult<Prisma.$creditoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Creditos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {creditoCountArgs} args - Arguments to filter Creditos to count.
     * @example
     * // Count the number of Creditos
     * const count = await prisma.credito.count({
     *   where: {
     *     // ... the filter for the Creditos we want to count
     *   }
     * })
    **/
    count<T extends creditoCountArgs>(
      args?: Subset<T, creditoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditoAggregateArgs>(args: Subset<T, CreditoAggregateArgs>): Prisma.PrismaPromise<GetCreditoAggregateType<T>>

    /**
     * Group by Credito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {creditoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends creditoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: creditoGroupByArgs['orderBy'] }
        : { orderBy?: creditoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, creditoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the credito model
   */
  readonly fields: creditoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for credito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__creditoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the credito model
   */
  interface creditoFieldRefs {
    readonly id: FieldRef<"credito", 'Int'>
    readonly datahora: FieldRef<"credito", 'DateTime'>
    readonly valorun: FieldRef<"credito", 'Float'>
    readonly vendedor: FieldRef<"credito", 'Int'>
    readonly createdAt: FieldRef<"credito", 'DateTime'>
    readonly updatedAt: FieldRef<"credito", 'DateTime'>
    readonly idusu_cli: FieldRef<"credito", 'Int'>
    readonly tiposervico: FieldRef<"credito", 'Int'>
    readonly qtdecreditos: FieldRef<"credito", 'Int'>
    readonly qtderestante: FieldRef<"credito", 'Int'>
    readonly qtdeutilizada: FieldRef<"credito", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * credito findUnique
   */
  export type creditoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credito
     */
    select?: creditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credito
     */
    omit?: creditoOmit<ExtArgs> | null
    /**
     * Filter, which credito to fetch.
     */
    where: creditoWhereUniqueInput
  }

  /**
   * credito findUniqueOrThrow
   */
  export type creditoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credito
     */
    select?: creditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credito
     */
    omit?: creditoOmit<ExtArgs> | null
    /**
     * Filter, which credito to fetch.
     */
    where: creditoWhereUniqueInput
  }

  /**
   * credito findFirst
   */
  export type creditoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credito
     */
    select?: creditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credito
     */
    omit?: creditoOmit<ExtArgs> | null
    /**
     * Filter, which credito to fetch.
     */
    where?: creditoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of creditos to fetch.
     */
    orderBy?: creditoOrderByWithRelationInput | creditoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for creditos.
     */
    cursor?: creditoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` creditos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` creditos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of creditos.
     */
    distinct?: CreditoScalarFieldEnum | CreditoScalarFieldEnum[]
  }

  /**
   * credito findFirstOrThrow
   */
  export type creditoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credito
     */
    select?: creditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credito
     */
    omit?: creditoOmit<ExtArgs> | null
    /**
     * Filter, which credito to fetch.
     */
    where?: creditoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of creditos to fetch.
     */
    orderBy?: creditoOrderByWithRelationInput | creditoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for creditos.
     */
    cursor?: creditoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` creditos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` creditos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of creditos.
     */
    distinct?: CreditoScalarFieldEnum | CreditoScalarFieldEnum[]
  }

  /**
   * credito findMany
   */
  export type creditoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credito
     */
    select?: creditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credito
     */
    omit?: creditoOmit<ExtArgs> | null
    /**
     * Filter, which creditos to fetch.
     */
    where?: creditoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of creditos to fetch.
     */
    orderBy?: creditoOrderByWithRelationInput | creditoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing creditos.
     */
    cursor?: creditoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` creditos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` creditos.
     */
    skip?: number
    distinct?: CreditoScalarFieldEnum | CreditoScalarFieldEnum[]
  }

  /**
   * credito create
   */
  export type creditoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credito
     */
    select?: creditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credito
     */
    omit?: creditoOmit<ExtArgs> | null
    /**
     * The data needed to create a credito.
     */
    data: XOR<creditoCreateInput, creditoUncheckedCreateInput>
  }

  /**
   * credito createMany
   */
  export type creditoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many creditos.
     */
    data: creditoCreateManyInput | creditoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * credito update
   */
  export type creditoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credito
     */
    select?: creditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credito
     */
    omit?: creditoOmit<ExtArgs> | null
    /**
     * The data needed to update a credito.
     */
    data: XOR<creditoUpdateInput, creditoUncheckedUpdateInput>
    /**
     * Choose, which credito to update.
     */
    where: creditoWhereUniqueInput
  }

  /**
   * credito updateMany
   */
  export type creditoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update creditos.
     */
    data: XOR<creditoUpdateManyMutationInput, creditoUncheckedUpdateManyInput>
    /**
     * Filter which creditos to update
     */
    where?: creditoWhereInput
    /**
     * Limit how many creditos to update.
     */
    limit?: number
  }

  /**
   * credito upsert
   */
  export type creditoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credito
     */
    select?: creditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credito
     */
    omit?: creditoOmit<ExtArgs> | null
    /**
     * The filter to search for the credito to update in case it exists.
     */
    where: creditoWhereUniqueInput
    /**
     * In case the credito found by the `where` argument doesn't exist, create a new credito with this data.
     */
    create: XOR<creditoCreateInput, creditoUncheckedCreateInput>
    /**
     * In case the credito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<creditoUpdateInput, creditoUncheckedUpdateInput>
  }

  /**
   * credito delete
   */
  export type creditoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credito
     */
    select?: creditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credito
     */
    omit?: creditoOmit<ExtArgs> | null
    /**
     * Filter which credito to delete.
     */
    where: creditoWhereUniqueInput
  }

  /**
   * credito deleteMany
   */
  export type creditoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which creditos to delete
     */
    where?: creditoWhereInput
    /**
     * Limit how many creditos to delete.
     */
    limit?: number
  }

  /**
   * credito without action
   */
  export type creditoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credito
     */
    select?: creditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credito
     */
    omit?: creditoOmit<ExtArgs> | null
  }


  /**
   * Model desbloqueios
   */

  export type AggregateDesbloqueios = {
    _count: DesbloqueiosCountAggregateOutputType | null
    _avg: DesbloqueiosAvgAggregateOutputType | null
    _sum: DesbloqueiosSumAggregateOutputType | null
    _min: DesbloqueiosMinAggregateOutputType | null
    _max: DesbloqueiosMaxAggregateOutputType | null
  }

  export type DesbloqueiosAvgAggregateOutputType = {
    id: number | null
    status: number | null
    id_usuario: number | null
    id_usu_desbloqueio: number | null
  }

  export type DesbloqueiosSumAggregateOutputType = {
    id: number | null
    status: number | null
    id_usuario: number | null
    id_usu_desbloqueio: number | null
  }

  export type DesbloqueiosMinAggregateOutputType = {
    id: number | null
    datahora: Date | null
    beneficio: string | null
    cpf: string | null
    protocolo: string | null
    requerente: string | null
    unidade: string | null
    status: number | null
    id_usuario: number | null
    createdAt: Date | null
    updatedAt: Date | null
    id_usu_desbloqueio: number | null
    ddb: string | null
  }

  export type DesbloqueiosMaxAggregateOutputType = {
    id: number | null
    datahora: Date | null
    beneficio: string | null
    cpf: string | null
    protocolo: string | null
    requerente: string | null
    unidade: string | null
    status: number | null
    id_usuario: number | null
    createdAt: Date | null
    updatedAt: Date | null
    id_usu_desbloqueio: number | null
    ddb: string | null
  }

  export type DesbloqueiosCountAggregateOutputType = {
    id: number
    datahora: number
    beneficio: number
    cpf: number
    protocolo: number
    requerente: number
    unidade: number
    status: number
    id_usuario: number
    createdAt: number
    updatedAt: number
    id_usu_desbloqueio: number
    ddb: number
    _all: number
  }


  export type DesbloqueiosAvgAggregateInputType = {
    id?: true
    status?: true
    id_usuario?: true
    id_usu_desbloqueio?: true
  }

  export type DesbloqueiosSumAggregateInputType = {
    id?: true
    status?: true
    id_usuario?: true
    id_usu_desbloqueio?: true
  }

  export type DesbloqueiosMinAggregateInputType = {
    id?: true
    datahora?: true
    beneficio?: true
    cpf?: true
    protocolo?: true
    requerente?: true
    unidade?: true
    status?: true
    id_usuario?: true
    createdAt?: true
    updatedAt?: true
    id_usu_desbloqueio?: true
    ddb?: true
  }

  export type DesbloqueiosMaxAggregateInputType = {
    id?: true
    datahora?: true
    beneficio?: true
    cpf?: true
    protocolo?: true
    requerente?: true
    unidade?: true
    status?: true
    id_usuario?: true
    createdAt?: true
    updatedAt?: true
    id_usu_desbloqueio?: true
    ddb?: true
  }

  export type DesbloqueiosCountAggregateInputType = {
    id?: true
    datahora?: true
    beneficio?: true
    cpf?: true
    protocolo?: true
    requerente?: true
    unidade?: true
    status?: true
    id_usuario?: true
    createdAt?: true
    updatedAt?: true
    id_usu_desbloqueio?: true
    ddb?: true
    _all?: true
  }

  export type DesbloqueiosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which desbloqueios to aggregate.
     */
    where?: desbloqueiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of desbloqueios to fetch.
     */
    orderBy?: desbloqueiosOrderByWithRelationInput | desbloqueiosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: desbloqueiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` desbloqueios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` desbloqueios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned desbloqueios
    **/
    _count?: true | DesbloqueiosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DesbloqueiosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DesbloqueiosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesbloqueiosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesbloqueiosMaxAggregateInputType
  }

  export type GetDesbloqueiosAggregateType<T extends DesbloqueiosAggregateArgs> = {
        [P in keyof T & keyof AggregateDesbloqueios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesbloqueios[P]>
      : GetScalarType<T[P], AggregateDesbloqueios[P]>
  }




  export type desbloqueiosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: desbloqueiosWhereInput
    orderBy?: desbloqueiosOrderByWithAggregationInput | desbloqueiosOrderByWithAggregationInput[]
    by: DesbloqueiosScalarFieldEnum[] | DesbloqueiosScalarFieldEnum
    having?: desbloqueiosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesbloqueiosCountAggregateInputType | true
    _avg?: DesbloqueiosAvgAggregateInputType
    _sum?: DesbloqueiosSumAggregateInputType
    _min?: DesbloqueiosMinAggregateInputType
    _max?: DesbloqueiosMaxAggregateInputType
  }

  export type DesbloqueiosGroupByOutputType = {
    id: number
    datahora: Date
    beneficio: string
    cpf: string
    protocolo: string | null
    requerente: string | null
    unidade: string | null
    status: number
    id_usuario: number
    createdAt: Date
    updatedAt: Date
    id_usu_desbloqueio: number
    ddb: string | null
    _count: DesbloqueiosCountAggregateOutputType | null
    _avg: DesbloqueiosAvgAggregateOutputType | null
    _sum: DesbloqueiosSumAggregateOutputType | null
    _min: DesbloqueiosMinAggregateOutputType | null
    _max: DesbloqueiosMaxAggregateOutputType | null
  }

  type GetDesbloqueiosGroupByPayload<T extends desbloqueiosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesbloqueiosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesbloqueiosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesbloqueiosGroupByOutputType[P]>
            : GetScalarType<T[P], DesbloqueiosGroupByOutputType[P]>
        }
      >
    >


  export type desbloqueiosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datahora?: boolean
    beneficio?: boolean
    cpf?: boolean
    protocolo?: boolean
    requerente?: boolean
    unidade?: boolean
    status?: boolean
    id_usuario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id_usu_desbloqueio?: boolean
    ddb?: boolean
  }, ExtArgs["result"]["desbloqueios"]>



  export type desbloqueiosSelectScalar = {
    id?: boolean
    datahora?: boolean
    beneficio?: boolean
    cpf?: boolean
    protocolo?: boolean
    requerente?: boolean
    unidade?: boolean
    status?: boolean
    id_usuario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id_usu_desbloqueio?: boolean
    ddb?: boolean
  }

  export type desbloqueiosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "datahora" | "beneficio" | "cpf" | "protocolo" | "requerente" | "unidade" | "status" | "id_usuario" | "createdAt" | "updatedAt" | "id_usu_desbloqueio" | "ddb", ExtArgs["result"]["desbloqueios"]>

  export type $desbloqueiosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "desbloqueios"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      datahora: Date
      beneficio: string
      cpf: string
      protocolo: string | null
      requerente: string | null
      unidade: string | null
      status: number
      id_usuario: number
      createdAt: Date
      updatedAt: Date
      id_usu_desbloqueio: number
      ddb: string | null
    }, ExtArgs["result"]["desbloqueios"]>
    composites: {}
  }

  type desbloqueiosGetPayload<S extends boolean | null | undefined | desbloqueiosDefaultArgs> = $Result.GetResult<Prisma.$desbloqueiosPayload, S>

  type desbloqueiosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<desbloqueiosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DesbloqueiosCountAggregateInputType | true
    }

  export interface desbloqueiosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['desbloqueios'], meta: { name: 'desbloqueios' } }
    /**
     * Find zero or one Desbloqueios that matches the filter.
     * @param {desbloqueiosFindUniqueArgs} args - Arguments to find a Desbloqueios
     * @example
     * // Get one Desbloqueios
     * const desbloqueios = await prisma.desbloqueios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends desbloqueiosFindUniqueArgs>(args: SelectSubset<T, desbloqueiosFindUniqueArgs<ExtArgs>>): Prisma__desbloqueiosClient<$Result.GetResult<Prisma.$desbloqueiosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Desbloqueios that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {desbloqueiosFindUniqueOrThrowArgs} args - Arguments to find a Desbloqueios
     * @example
     * // Get one Desbloqueios
     * const desbloqueios = await prisma.desbloqueios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends desbloqueiosFindUniqueOrThrowArgs>(args: SelectSubset<T, desbloqueiosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__desbloqueiosClient<$Result.GetResult<Prisma.$desbloqueiosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Desbloqueios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {desbloqueiosFindFirstArgs} args - Arguments to find a Desbloqueios
     * @example
     * // Get one Desbloqueios
     * const desbloqueios = await prisma.desbloqueios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends desbloqueiosFindFirstArgs>(args?: SelectSubset<T, desbloqueiosFindFirstArgs<ExtArgs>>): Prisma__desbloqueiosClient<$Result.GetResult<Prisma.$desbloqueiosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Desbloqueios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {desbloqueiosFindFirstOrThrowArgs} args - Arguments to find a Desbloqueios
     * @example
     * // Get one Desbloqueios
     * const desbloqueios = await prisma.desbloqueios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends desbloqueiosFindFirstOrThrowArgs>(args?: SelectSubset<T, desbloqueiosFindFirstOrThrowArgs<ExtArgs>>): Prisma__desbloqueiosClient<$Result.GetResult<Prisma.$desbloqueiosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Desbloqueios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {desbloqueiosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Desbloqueios
     * const desbloqueios = await prisma.desbloqueios.findMany()
     * 
     * // Get first 10 Desbloqueios
     * const desbloqueios = await prisma.desbloqueios.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const desbloqueiosWithIdOnly = await prisma.desbloqueios.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends desbloqueiosFindManyArgs>(args?: SelectSubset<T, desbloqueiosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$desbloqueiosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Desbloqueios.
     * @param {desbloqueiosCreateArgs} args - Arguments to create a Desbloqueios.
     * @example
     * // Create one Desbloqueios
     * const Desbloqueios = await prisma.desbloqueios.create({
     *   data: {
     *     // ... data to create a Desbloqueios
     *   }
     * })
     * 
     */
    create<T extends desbloqueiosCreateArgs>(args: SelectSubset<T, desbloqueiosCreateArgs<ExtArgs>>): Prisma__desbloqueiosClient<$Result.GetResult<Prisma.$desbloqueiosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Desbloqueios.
     * @param {desbloqueiosCreateManyArgs} args - Arguments to create many Desbloqueios.
     * @example
     * // Create many Desbloqueios
     * const desbloqueios = await prisma.desbloqueios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends desbloqueiosCreateManyArgs>(args?: SelectSubset<T, desbloqueiosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Desbloqueios.
     * @param {desbloqueiosDeleteArgs} args - Arguments to delete one Desbloqueios.
     * @example
     * // Delete one Desbloqueios
     * const Desbloqueios = await prisma.desbloqueios.delete({
     *   where: {
     *     // ... filter to delete one Desbloqueios
     *   }
     * })
     * 
     */
    delete<T extends desbloqueiosDeleteArgs>(args: SelectSubset<T, desbloqueiosDeleteArgs<ExtArgs>>): Prisma__desbloqueiosClient<$Result.GetResult<Prisma.$desbloqueiosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Desbloqueios.
     * @param {desbloqueiosUpdateArgs} args - Arguments to update one Desbloqueios.
     * @example
     * // Update one Desbloqueios
     * const desbloqueios = await prisma.desbloqueios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends desbloqueiosUpdateArgs>(args: SelectSubset<T, desbloqueiosUpdateArgs<ExtArgs>>): Prisma__desbloqueiosClient<$Result.GetResult<Prisma.$desbloqueiosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Desbloqueios.
     * @param {desbloqueiosDeleteManyArgs} args - Arguments to filter Desbloqueios to delete.
     * @example
     * // Delete a few Desbloqueios
     * const { count } = await prisma.desbloqueios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends desbloqueiosDeleteManyArgs>(args?: SelectSubset<T, desbloqueiosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Desbloqueios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {desbloqueiosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Desbloqueios
     * const desbloqueios = await prisma.desbloqueios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends desbloqueiosUpdateManyArgs>(args: SelectSubset<T, desbloqueiosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Desbloqueios.
     * @param {desbloqueiosUpsertArgs} args - Arguments to update or create a Desbloqueios.
     * @example
     * // Update or create a Desbloqueios
     * const desbloqueios = await prisma.desbloqueios.upsert({
     *   create: {
     *     // ... data to create a Desbloqueios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Desbloqueios we want to update
     *   }
     * })
     */
    upsert<T extends desbloqueiosUpsertArgs>(args: SelectSubset<T, desbloqueiosUpsertArgs<ExtArgs>>): Prisma__desbloqueiosClient<$Result.GetResult<Prisma.$desbloqueiosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Desbloqueios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {desbloqueiosCountArgs} args - Arguments to filter Desbloqueios to count.
     * @example
     * // Count the number of Desbloqueios
     * const count = await prisma.desbloqueios.count({
     *   where: {
     *     // ... the filter for the Desbloqueios we want to count
     *   }
     * })
    **/
    count<T extends desbloqueiosCountArgs>(
      args?: Subset<T, desbloqueiosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesbloqueiosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Desbloqueios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesbloqueiosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesbloqueiosAggregateArgs>(args: Subset<T, DesbloqueiosAggregateArgs>): Prisma.PrismaPromise<GetDesbloqueiosAggregateType<T>>

    /**
     * Group by Desbloqueios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {desbloqueiosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends desbloqueiosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: desbloqueiosGroupByArgs['orderBy'] }
        : { orderBy?: desbloqueiosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, desbloqueiosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesbloqueiosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the desbloqueios model
   */
  readonly fields: desbloqueiosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for desbloqueios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__desbloqueiosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the desbloqueios model
   */
  interface desbloqueiosFieldRefs {
    readonly id: FieldRef<"desbloqueios", 'Int'>
    readonly datahora: FieldRef<"desbloqueios", 'DateTime'>
    readonly beneficio: FieldRef<"desbloqueios", 'String'>
    readonly cpf: FieldRef<"desbloqueios", 'String'>
    readonly protocolo: FieldRef<"desbloqueios", 'String'>
    readonly requerente: FieldRef<"desbloqueios", 'String'>
    readonly unidade: FieldRef<"desbloqueios", 'String'>
    readonly status: FieldRef<"desbloqueios", 'Int'>
    readonly id_usuario: FieldRef<"desbloqueios", 'Int'>
    readonly createdAt: FieldRef<"desbloqueios", 'DateTime'>
    readonly updatedAt: FieldRef<"desbloqueios", 'DateTime'>
    readonly id_usu_desbloqueio: FieldRef<"desbloqueios", 'Int'>
    readonly ddb: FieldRef<"desbloqueios", 'String'>
  }
    

  // Custom InputTypes
  /**
   * desbloqueios findUnique
   */
  export type desbloqueiosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the desbloqueios
     */
    select?: desbloqueiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the desbloqueios
     */
    omit?: desbloqueiosOmit<ExtArgs> | null
    /**
     * Filter, which desbloqueios to fetch.
     */
    where: desbloqueiosWhereUniqueInput
  }

  /**
   * desbloqueios findUniqueOrThrow
   */
  export type desbloqueiosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the desbloqueios
     */
    select?: desbloqueiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the desbloqueios
     */
    omit?: desbloqueiosOmit<ExtArgs> | null
    /**
     * Filter, which desbloqueios to fetch.
     */
    where: desbloqueiosWhereUniqueInput
  }

  /**
   * desbloqueios findFirst
   */
  export type desbloqueiosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the desbloqueios
     */
    select?: desbloqueiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the desbloqueios
     */
    omit?: desbloqueiosOmit<ExtArgs> | null
    /**
     * Filter, which desbloqueios to fetch.
     */
    where?: desbloqueiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of desbloqueios to fetch.
     */
    orderBy?: desbloqueiosOrderByWithRelationInput | desbloqueiosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for desbloqueios.
     */
    cursor?: desbloqueiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` desbloqueios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` desbloqueios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of desbloqueios.
     */
    distinct?: DesbloqueiosScalarFieldEnum | DesbloqueiosScalarFieldEnum[]
  }

  /**
   * desbloqueios findFirstOrThrow
   */
  export type desbloqueiosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the desbloqueios
     */
    select?: desbloqueiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the desbloqueios
     */
    omit?: desbloqueiosOmit<ExtArgs> | null
    /**
     * Filter, which desbloqueios to fetch.
     */
    where?: desbloqueiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of desbloqueios to fetch.
     */
    orderBy?: desbloqueiosOrderByWithRelationInput | desbloqueiosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for desbloqueios.
     */
    cursor?: desbloqueiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` desbloqueios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` desbloqueios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of desbloqueios.
     */
    distinct?: DesbloqueiosScalarFieldEnum | DesbloqueiosScalarFieldEnum[]
  }

  /**
   * desbloqueios findMany
   */
  export type desbloqueiosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the desbloqueios
     */
    select?: desbloqueiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the desbloqueios
     */
    omit?: desbloqueiosOmit<ExtArgs> | null
    /**
     * Filter, which desbloqueios to fetch.
     */
    where?: desbloqueiosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of desbloqueios to fetch.
     */
    orderBy?: desbloqueiosOrderByWithRelationInput | desbloqueiosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing desbloqueios.
     */
    cursor?: desbloqueiosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` desbloqueios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` desbloqueios.
     */
    skip?: number
    distinct?: DesbloqueiosScalarFieldEnum | DesbloqueiosScalarFieldEnum[]
  }

  /**
   * desbloqueios create
   */
  export type desbloqueiosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the desbloqueios
     */
    select?: desbloqueiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the desbloqueios
     */
    omit?: desbloqueiosOmit<ExtArgs> | null
    /**
     * The data needed to create a desbloqueios.
     */
    data: XOR<desbloqueiosCreateInput, desbloqueiosUncheckedCreateInput>
  }

  /**
   * desbloqueios createMany
   */
  export type desbloqueiosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many desbloqueios.
     */
    data: desbloqueiosCreateManyInput | desbloqueiosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * desbloqueios update
   */
  export type desbloqueiosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the desbloqueios
     */
    select?: desbloqueiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the desbloqueios
     */
    omit?: desbloqueiosOmit<ExtArgs> | null
    /**
     * The data needed to update a desbloqueios.
     */
    data: XOR<desbloqueiosUpdateInput, desbloqueiosUncheckedUpdateInput>
    /**
     * Choose, which desbloqueios to update.
     */
    where: desbloqueiosWhereUniqueInput
  }

  /**
   * desbloqueios updateMany
   */
  export type desbloqueiosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update desbloqueios.
     */
    data: XOR<desbloqueiosUpdateManyMutationInput, desbloqueiosUncheckedUpdateManyInput>
    /**
     * Filter which desbloqueios to update
     */
    where?: desbloqueiosWhereInput
    /**
     * Limit how many desbloqueios to update.
     */
    limit?: number
  }

  /**
   * desbloqueios upsert
   */
  export type desbloqueiosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the desbloqueios
     */
    select?: desbloqueiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the desbloqueios
     */
    omit?: desbloqueiosOmit<ExtArgs> | null
    /**
     * The filter to search for the desbloqueios to update in case it exists.
     */
    where: desbloqueiosWhereUniqueInput
    /**
     * In case the desbloqueios found by the `where` argument doesn't exist, create a new desbloqueios with this data.
     */
    create: XOR<desbloqueiosCreateInput, desbloqueiosUncheckedCreateInput>
    /**
     * In case the desbloqueios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<desbloqueiosUpdateInput, desbloqueiosUncheckedUpdateInput>
  }

  /**
   * desbloqueios delete
   */
  export type desbloqueiosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the desbloqueios
     */
    select?: desbloqueiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the desbloqueios
     */
    omit?: desbloqueiosOmit<ExtArgs> | null
    /**
     * Filter which desbloqueios to delete.
     */
    where: desbloqueiosWhereUniqueInput
  }

  /**
   * desbloqueios deleteMany
   */
  export type desbloqueiosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which desbloqueios to delete
     */
    where?: desbloqueiosWhereInput
    /**
     * Limit how many desbloqueios to delete.
     */
    limit?: number
  }

  /**
   * desbloqueios without action
   */
  export type desbloqueiosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the desbloqueios
     */
    select?: desbloqueiosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the desbloqueios
     */
    omit?: desbloqueiosOmit<ExtArgs> | null
  }


  /**
   * Model entrantesinss
   */

  export type AggregateEntrantesinss = {
    _count: EntrantesinssCountAggregateOutputType | null
    _avg: EntrantesinssAvgAggregateOutputType | null
    _sum: EntrantesinssSumAggregateOutputType | null
    _min: EntrantesinssMinAggregateOutputType | null
    _max: EntrantesinssMaxAggregateOutputType | null
  }

  export type EntrantesinssAvgAggregateOutputType = {
    id: number | null
    idade: number | null
    beneficio: number | null
    especie: number | null
    salario: number | null
  }

  export type EntrantesinssSumAggregateOutputType = {
    id: number | null
    idade: number | null
    beneficio: number | null
    especie: number | null
    salario: number | null
  }

  export type EntrantesinssMinAggregateOutputType = {
    id: number | null
    cpf: string | null
    nome: string | null
    nascimento: Date | null
    idade: number | null
    beneficio: number | null
    especie: number | null
    salario: number | null
    dib: Date | null
    cidade: string | null
    uf: string | null
    bairro: string | null
    cep: string | null
    fone: string | null
    fone1: string | null
    fone2: string | null
    fone3: string | null
    fone4: string | null
    fone5: string | null
    fone6: string | null
    fone7: string | null
    fone8: string | null
    fone9: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EntrantesinssMaxAggregateOutputType = {
    id: number | null
    cpf: string | null
    nome: string | null
    nascimento: Date | null
    idade: number | null
    beneficio: number | null
    especie: number | null
    salario: number | null
    dib: Date | null
    cidade: string | null
    uf: string | null
    bairro: string | null
    cep: string | null
    fone: string | null
    fone1: string | null
    fone2: string | null
    fone3: string | null
    fone4: string | null
    fone5: string | null
    fone6: string | null
    fone7: string | null
    fone8: string | null
    fone9: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EntrantesinssCountAggregateOutputType = {
    id: number
    cpf: number
    nome: number
    nascimento: number
    idade: number
    beneficio: number
    especie: number
    salario: number
    dib: number
    cidade: number
    uf: number
    bairro: number
    cep: number
    fone: number
    fone1: number
    fone2: number
    fone3: number
    fone4: number
    fone5: number
    fone6: number
    fone7: number
    fone8: number
    fone9: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EntrantesinssAvgAggregateInputType = {
    id?: true
    idade?: true
    beneficio?: true
    especie?: true
    salario?: true
  }

  export type EntrantesinssSumAggregateInputType = {
    id?: true
    idade?: true
    beneficio?: true
    especie?: true
    salario?: true
  }

  export type EntrantesinssMinAggregateInputType = {
    id?: true
    cpf?: true
    nome?: true
    nascimento?: true
    idade?: true
    beneficio?: true
    especie?: true
    salario?: true
    dib?: true
    cidade?: true
    uf?: true
    bairro?: true
    cep?: true
    fone?: true
    fone1?: true
    fone2?: true
    fone3?: true
    fone4?: true
    fone5?: true
    fone6?: true
    fone7?: true
    fone8?: true
    fone9?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EntrantesinssMaxAggregateInputType = {
    id?: true
    cpf?: true
    nome?: true
    nascimento?: true
    idade?: true
    beneficio?: true
    especie?: true
    salario?: true
    dib?: true
    cidade?: true
    uf?: true
    bairro?: true
    cep?: true
    fone?: true
    fone1?: true
    fone2?: true
    fone3?: true
    fone4?: true
    fone5?: true
    fone6?: true
    fone7?: true
    fone8?: true
    fone9?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EntrantesinssCountAggregateInputType = {
    id?: true
    cpf?: true
    nome?: true
    nascimento?: true
    idade?: true
    beneficio?: true
    especie?: true
    salario?: true
    dib?: true
    cidade?: true
    uf?: true
    bairro?: true
    cep?: true
    fone?: true
    fone1?: true
    fone2?: true
    fone3?: true
    fone4?: true
    fone5?: true
    fone6?: true
    fone7?: true
    fone8?: true
    fone9?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EntrantesinssAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entrantesinss to aggregate.
     */
    where?: entrantesinssWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entrantesinsses to fetch.
     */
    orderBy?: entrantesinssOrderByWithRelationInput | entrantesinssOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: entrantesinssWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entrantesinsses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entrantesinsses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned entrantesinsses
    **/
    _count?: true | EntrantesinssCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntrantesinssAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntrantesinssSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntrantesinssMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntrantesinssMaxAggregateInputType
  }

  export type GetEntrantesinssAggregateType<T extends EntrantesinssAggregateArgs> = {
        [P in keyof T & keyof AggregateEntrantesinss]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntrantesinss[P]>
      : GetScalarType<T[P], AggregateEntrantesinss[P]>
  }




  export type entrantesinssGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entrantesinssWhereInput
    orderBy?: entrantesinssOrderByWithAggregationInput | entrantesinssOrderByWithAggregationInput[]
    by: EntrantesinssScalarFieldEnum[] | EntrantesinssScalarFieldEnum
    having?: entrantesinssScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntrantesinssCountAggregateInputType | true
    _avg?: EntrantesinssAvgAggregateInputType
    _sum?: EntrantesinssSumAggregateInputType
    _min?: EntrantesinssMinAggregateInputType
    _max?: EntrantesinssMaxAggregateInputType
  }

  export type EntrantesinssGroupByOutputType = {
    id: number
    cpf: string | null
    nome: string | null
    nascimento: Date | null
    idade: number | null
    beneficio: number | null
    especie: number | null
    salario: number | null
    dib: Date | null
    cidade: string | null
    uf: string | null
    bairro: string | null
    cep: string | null
    fone: string | null
    fone1: string | null
    fone2: string | null
    fone3: string | null
    fone4: string | null
    fone5: string | null
    fone6: string | null
    fone7: string | null
    fone8: string | null
    fone9: string | null
    email: string | null
    createdAt: Date
    updatedAt: Date
    _count: EntrantesinssCountAggregateOutputType | null
    _avg: EntrantesinssAvgAggregateOutputType | null
    _sum: EntrantesinssSumAggregateOutputType | null
    _min: EntrantesinssMinAggregateOutputType | null
    _max: EntrantesinssMaxAggregateOutputType | null
  }

  type GetEntrantesinssGroupByPayload<T extends entrantesinssGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntrantesinssGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntrantesinssGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntrantesinssGroupByOutputType[P]>
            : GetScalarType<T[P], EntrantesinssGroupByOutputType[P]>
        }
      >
    >


  export type entrantesinssSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cpf?: boolean
    nome?: boolean
    nascimento?: boolean
    idade?: boolean
    beneficio?: boolean
    especie?: boolean
    salario?: boolean
    dib?: boolean
    cidade?: boolean
    uf?: boolean
    bairro?: boolean
    cep?: boolean
    fone?: boolean
    fone1?: boolean
    fone2?: boolean
    fone3?: boolean
    fone4?: boolean
    fone5?: boolean
    fone6?: boolean
    fone7?: boolean
    fone8?: boolean
    fone9?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["entrantesinss"]>



  export type entrantesinssSelectScalar = {
    id?: boolean
    cpf?: boolean
    nome?: boolean
    nascimento?: boolean
    idade?: boolean
    beneficio?: boolean
    especie?: boolean
    salario?: boolean
    dib?: boolean
    cidade?: boolean
    uf?: boolean
    bairro?: boolean
    cep?: boolean
    fone?: boolean
    fone1?: boolean
    fone2?: boolean
    fone3?: boolean
    fone4?: boolean
    fone5?: boolean
    fone6?: boolean
    fone7?: boolean
    fone8?: boolean
    fone9?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type entrantesinssOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cpf" | "nome" | "nascimento" | "idade" | "beneficio" | "especie" | "salario" | "dib" | "cidade" | "uf" | "bairro" | "cep" | "fone" | "fone1" | "fone2" | "fone3" | "fone4" | "fone5" | "fone6" | "fone7" | "fone8" | "fone9" | "email" | "createdAt" | "updatedAt", ExtArgs["result"]["entrantesinss"]>

  export type $entrantesinssPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "entrantesinss"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cpf: string | null
      nome: string | null
      nascimento: Date | null
      idade: number | null
      beneficio: number | null
      especie: number | null
      salario: number | null
      dib: Date | null
      cidade: string | null
      uf: string | null
      bairro: string | null
      cep: string | null
      fone: string | null
      fone1: string | null
      fone2: string | null
      fone3: string | null
      fone4: string | null
      fone5: string | null
      fone6: string | null
      fone7: string | null
      fone8: string | null
      fone9: string | null
      email: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["entrantesinss"]>
    composites: {}
  }

  type entrantesinssGetPayload<S extends boolean | null | undefined | entrantesinssDefaultArgs> = $Result.GetResult<Prisma.$entrantesinssPayload, S>

  type entrantesinssCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<entrantesinssFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EntrantesinssCountAggregateInputType | true
    }

  export interface entrantesinssDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['entrantesinss'], meta: { name: 'entrantesinss' } }
    /**
     * Find zero or one Entrantesinss that matches the filter.
     * @param {entrantesinssFindUniqueArgs} args - Arguments to find a Entrantesinss
     * @example
     * // Get one Entrantesinss
     * const entrantesinss = await prisma.entrantesinss.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends entrantesinssFindUniqueArgs>(args: SelectSubset<T, entrantesinssFindUniqueArgs<ExtArgs>>): Prisma__entrantesinssClient<$Result.GetResult<Prisma.$entrantesinssPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Entrantesinss that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {entrantesinssFindUniqueOrThrowArgs} args - Arguments to find a Entrantesinss
     * @example
     * // Get one Entrantesinss
     * const entrantesinss = await prisma.entrantesinss.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends entrantesinssFindUniqueOrThrowArgs>(args: SelectSubset<T, entrantesinssFindUniqueOrThrowArgs<ExtArgs>>): Prisma__entrantesinssClient<$Result.GetResult<Prisma.$entrantesinssPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entrantesinss that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entrantesinssFindFirstArgs} args - Arguments to find a Entrantesinss
     * @example
     * // Get one Entrantesinss
     * const entrantesinss = await prisma.entrantesinss.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends entrantesinssFindFirstArgs>(args?: SelectSubset<T, entrantesinssFindFirstArgs<ExtArgs>>): Prisma__entrantesinssClient<$Result.GetResult<Prisma.$entrantesinssPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entrantesinss that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entrantesinssFindFirstOrThrowArgs} args - Arguments to find a Entrantesinss
     * @example
     * // Get one Entrantesinss
     * const entrantesinss = await prisma.entrantesinss.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends entrantesinssFindFirstOrThrowArgs>(args?: SelectSubset<T, entrantesinssFindFirstOrThrowArgs<ExtArgs>>): Prisma__entrantesinssClient<$Result.GetResult<Prisma.$entrantesinssPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Entrantesinsses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entrantesinssFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entrantesinsses
     * const entrantesinsses = await prisma.entrantesinss.findMany()
     * 
     * // Get first 10 Entrantesinsses
     * const entrantesinsses = await prisma.entrantesinss.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entrantesinssWithIdOnly = await prisma.entrantesinss.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends entrantesinssFindManyArgs>(args?: SelectSubset<T, entrantesinssFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entrantesinssPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Entrantesinss.
     * @param {entrantesinssCreateArgs} args - Arguments to create a Entrantesinss.
     * @example
     * // Create one Entrantesinss
     * const Entrantesinss = await prisma.entrantesinss.create({
     *   data: {
     *     // ... data to create a Entrantesinss
     *   }
     * })
     * 
     */
    create<T extends entrantesinssCreateArgs>(args: SelectSubset<T, entrantesinssCreateArgs<ExtArgs>>): Prisma__entrantesinssClient<$Result.GetResult<Prisma.$entrantesinssPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Entrantesinsses.
     * @param {entrantesinssCreateManyArgs} args - Arguments to create many Entrantesinsses.
     * @example
     * // Create many Entrantesinsses
     * const entrantesinss = await prisma.entrantesinss.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends entrantesinssCreateManyArgs>(args?: SelectSubset<T, entrantesinssCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entrantesinss.
     * @param {entrantesinssDeleteArgs} args - Arguments to delete one Entrantesinss.
     * @example
     * // Delete one Entrantesinss
     * const Entrantesinss = await prisma.entrantesinss.delete({
     *   where: {
     *     // ... filter to delete one Entrantesinss
     *   }
     * })
     * 
     */
    delete<T extends entrantesinssDeleteArgs>(args: SelectSubset<T, entrantesinssDeleteArgs<ExtArgs>>): Prisma__entrantesinssClient<$Result.GetResult<Prisma.$entrantesinssPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Entrantesinss.
     * @param {entrantesinssUpdateArgs} args - Arguments to update one Entrantesinss.
     * @example
     * // Update one Entrantesinss
     * const entrantesinss = await prisma.entrantesinss.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends entrantesinssUpdateArgs>(args: SelectSubset<T, entrantesinssUpdateArgs<ExtArgs>>): Prisma__entrantesinssClient<$Result.GetResult<Prisma.$entrantesinssPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Entrantesinsses.
     * @param {entrantesinssDeleteManyArgs} args - Arguments to filter Entrantesinsses to delete.
     * @example
     * // Delete a few Entrantesinsses
     * const { count } = await prisma.entrantesinss.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends entrantesinssDeleteManyArgs>(args?: SelectSubset<T, entrantesinssDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entrantesinsses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entrantesinssUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entrantesinsses
     * const entrantesinss = await prisma.entrantesinss.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends entrantesinssUpdateManyArgs>(args: SelectSubset<T, entrantesinssUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entrantesinss.
     * @param {entrantesinssUpsertArgs} args - Arguments to update or create a Entrantesinss.
     * @example
     * // Update or create a Entrantesinss
     * const entrantesinss = await prisma.entrantesinss.upsert({
     *   create: {
     *     // ... data to create a Entrantesinss
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entrantesinss we want to update
     *   }
     * })
     */
    upsert<T extends entrantesinssUpsertArgs>(args: SelectSubset<T, entrantesinssUpsertArgs<ExtArgs>>): Prisma__entrantesinssClient<$Result.GetResult<Prisma.$entrantesinssPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Entrantesinsses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entrantesinssCountArgs} args - Arguments to filter Entrantesinsses to count.
     * @example
     * // Count the number of Entrantesinsses
     * const count = await prisma.entrantesinss.count({
     *   where: {
     *     // ... the filter for the Entrantesinsses we want to count
     *   }
     * })
    **/
    count<T extends entrantesinssCountArgs>(
      args?: Subset<T, entrantesinssCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntrantesinssCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entrantesinss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrantesinssAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntrantesinssAggregateArgs>(args: Subset<T, EntrantesinssAggregateArgs>): Prisma.PrismaPromise<GetEntrantesinssAggregateType<T>>

    /**
     * Group by Entrantesinss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entrantesinssGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends entrantesinssGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: entrantesinssGroupByArgs['orderBy'] }
        : { orderBy?: entrantesinssGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, entrantesinssGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntrantesinssGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the entrantesinss model
   */
  readonly fields: entrantesinssFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for entrantesinss.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__entrantesinssClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the entrantesinss model
   */
  interface entrantesinssFieldRefs {
    readonly id: FieldRef<"entrantesinss", 'Int'>
    readonly cpf: FieldRef<"entrantesinss", 'String'>
    readonly nome: FieldRef<"entrantesinss", 'String'>
    readonly nascimento: FieldRef<"entrantesinss", 'DateTime'>
    readonly idade: FieldRef<"entrantesinss", 'Int'>
    readonly beneficio: FieldRef<"entrantesinss", 'Int'>
    readonly especie: FieldRef<"entrantesinss", 'Int'>
    readonly salario: FieldRef<"entrantesinss", 'Float'>
    readonly dib: FieldRef<"entrantesinss", 'DateTime'>
    readonly cidade: FieldRef<"entrantesinss", 'String'>
    readonly uf: FieldRef<"entrantesinss", 'String'>
    readonly bairro: FieldRef<"entrantesinss", 'String'>
    readonly cep: FieldRef<"entrantesinss", 'String'>
    readonly fone: FieldRef<"entrantesinss", 'String'>
    readonly fone1: FieldRef<"entrantesinss", 'String'>
    readonly fone2: FieldRef<"entrantesinss", 'String'>
    readonly fone3: FieldRef<"entrantesinss", 'String'>
    readonly fone4: FieldRef<"entrantesinss", 'String'>
    readonly fone5: FieldRef<"entrantesinss", 'String'>
    readonly fone6: FieldRef<"entrantesinss", 'String'>
    readonly fone7: FieldRef<"entrantesinss", 'String'>
    readonly fone8: FieldRef<"entrantesinss", 'String'>
    readonly fone9: FieldRef<"entrantesinss", 'String'>
    readonly email: FieldRef<"entrantesinss", 'String'>
    readonly createdAt: FieldRef<"entrantesinss", 'DateTime'>
    readonly updatedAt: FieldRef<"entrantesinss", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * entrantesinss findUnique
   */
  export type entrantesinssFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrantesinss
     */
    select?: entrantesinssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrantesinss
     */
    omit?: entrantesinssOmit<ExtArgs> | null
    /**
     * Filter, which entrantesinss to fetch.
     */
    where: entrantesinssWhereUniqueInput
  }

  /**
   * entrantesinss findUniqueOrThrow
   */
  export type entrantesinssFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrantesinss
     */
    select?: entrantesinssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrantesinss
     */
    omit?: entrantesinssOmit<ExtArgs> | null
    /**
     * Filter, which entrantesinss to fetch.
     */
    where: entrantesinssWhereUniqueInput
  }

  /**
   * entrantesinss findFirst
   */
  export type entrantesinssFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrantesinss
     */
    select?: entrantesinssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrantesinss
     */
    omit?: entrantesinssOmit<ExtArgs> | null
    /**
     * Filter, which entrantesinss to fetch.
     */
    where?: entrantesinssWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entrantesinsses to fetch.
     */
    orderBy?: entrantesinssOrderByWithRelationInput | entrantesinssOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entrantesinsses.
     */
    cursor?: entrantesinssWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entrantesinsses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entrantesinsses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entrantesinsses.
     */
    distinct?: EntrantesinssScalarFieldEnum | EntrantesinssScalarFieldEnum[]
  }

  /**
   * entrantesinss findFirstOrThrow
   */
  export type entrantesinssFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrantesinss
     */
    select?: entrantesinssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrantesinss
     */
    omit?: entrantesinssOmit<ExtArgs> | null
    /**
     * Filter, which entrantesinss to fetch.
     */
    where?: entrantesinssWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entrantesinsses to fetch.
     */
    orderBy?: entrantesinssOrderByWithRelationInput | entrantesinssOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entrantesinsses.
     */
    cursor?: entrantesinssWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entrantesinsses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entrantesinsses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entrantesinsses.
     */
    distinct?: EntrantesinssScalarFieldEnum | EntrantesinssScalarFieldEnum[]
  }

  /**
   * entrantesinss findMany
   */
  export type entrantesinssFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrantesinss
     */
    select?: entrantesinssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrantesinss
     */
    omit?: entrantesinssOmit<ExtArgs> | null
    /**
     * Filter, which entrantesinsses to fetch.
     */
    where?: entrantesinssWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entrantesinsses to fetch.
     */
    orderBy?: entrantesinssOrderByWithRelationInput | entrantesinssOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing entrantesinsses.
     */
    cursor?: entrantesinssWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entrantesinsses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entrantesinsses.
     */
    skip?: number
    distinct?: EntrantesinssScalarFieldEnum | EntrantesinssScalarFieldEnum[]
  }

  /**
   * entrantesinss create
   */
  export type entrantesinssCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrantesinss
     */
    select?: entrantesinssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrantesinss
     */
    omit?: entrantesinssOmit<ExtArgs> | null
    /**
     * The data needed to create a entrantesinss.
     */
    data: XOR<entrantesinssCreateInput, entrantesinssUncheckedCreateInput>
  }

  /**
   * entrantesinss createMany
   */
  export type entrantesinssCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many entrantesinsses.
     */
    data: entrantesinssCreateManyInput | entrantesinssCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * entrantesinss update
   */
  export type entrantesinssUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrantesinss
     */
    select?: entrantesinssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrantesinss
     */
    omit?: entrantesinssOmit<ExtArgs> | null
    /**
     * The data needed to update a entrantesinss.
     */
    data: XOR<entrantesinssUpdateInput, entrantesinssUncheckedUpdateInput>
    /**
     * Choose, which entrantesinss to update.
     */
    where: entrantesinssWhereUniqueInput
  }

  /**
   * entrantesinss updateMany
   */
  export type entrantesinssUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update entrantesinsses.
     */
    data: XOR<entrantesinssUpdateManyMutationInput, entrantesinssUncheckedUpdateManyInput>
    /**
     * Filter which entrantesinsses to update
     */
    where?: entrantesinssWhereInput
    /**
     * Limit how many entrantesinsses to update.
     */
    limit?: number
  }

  /**
   * entrantesinss upsert
   */
  export type entrantesinssUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrantesinss
     */
    select?: entrantesinssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrantesinss
     */
    omit?: entrantesinssOmit<ExtArgs> | null
    /**
     * The filter to search for the entrantesinss to update in case it exists.
     */
    where: entrantesinssWhereUniqueInput
    /**
     * In case the entrantesinss found by the `where` argument doesn't exist, create a new entrantesinss with this data.
     */
    create: XOR<entrantesinssCreateInput, entrantesinssUncheckedCreateInput>
    /**
     * In case the entrantesinss was found with the provided `where` argument, update it with this data.
     */
    update: XOR<entrantesinssUpdateInput, entrantesinssUncheckedUpdateInput>
  }

  /**
   * entrantesinss delete
   */
  export type entrantesinssDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrantesinss
     */
    select?: entrantesinssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrantesinss
     */
    omit?: entrantesinssOmit<ExtArgs> | null
    /**
     * Filter which entrantesinss to delete.
     */
    where: entrantesinssWhereUniqueInput
  }

  /**
   * entrantesinss deleteMany
   */
  export type entrantesinssDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entrantesinsses to delete
     */
    where?: entrantesinssWhereInput
    /**
     * Limit how many entrantesinsses to delete.
     */
    limit?: number
  }

  /**
   * entrantesinss without action
   */
  export type entrantesinssDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entrantesinss
     */
    select?: entrantesinssSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entrantesinss
     */
    omit?: entrantesinssOmit<ExtArgs> | null
  }


  /**
   * Model especiebeneficio
   */

  export type AggregateEspeciebeneficio = {
    _count: EspeciebeneficioCountAggregateOutputType | null
    _avg: EspeciebeneficioAvgAggregateOutputType | null
    _sum: EspeciebeneficioSumAggregateOutputType | null
    _min: EspeciebeneficioMinAggregateOutputType | null
    _max: EspeciebeneficioMaxAggregateOutputType | null
  }

  export type EspeciebeneficioAvgAggregateOutputType = {
    id: number | null
    codigo: number | null
  }

  export type EspeciebeneficioSumAggregateOutputType = {
    id: number | null
    codigo: number | null
  }

  export type EspeciebeneficioMinAggregateOutputType = {
    id: number | null
    codigo: number | null
    descEspecieBeneficio: string | null
    gruposEspecie: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EspeciebeneficioMaxAggregateOutputType = {
    id: number | null
    codigo: number | null
    descEspecieBeneficio: string | null
    gruposEspecie: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EspeciebeneficioCountAggregateOutputType = {
    id: number
    codigo: number
    descEspecieBeneficio: number
    gruposEspecie: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EspeciebeneficioAvgAggregateInputType = {
    id?: true
    codigo?: true
  }

  export type EspeciebeneficioSumAggregateInputType = {
    id?: true
    codigo?: true
  }

  export type EspeciebeneficioMinAggregateInputType = {
    id?: true
    codigo?: true
    descEspecieBeneficio?: true
    gruposEspecie?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EspeciebeneficioMaxAggregateInputType = {
    id?: true
    codigo?: true
    descEspecieBeneficio?: true
    gruposEspecie?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EspeciebeneficioCountAggregateInputType = {
    id?: true
    codigo?: true
    descEspecieBeneficio?: true
    gruposEspecie?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EspeciebeneficioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which especiebeneficio to aggregate.
     */
    where?: especiebeneficioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especiebeneficios to fetch.
     */
    orderBy?: especiebeneficioOrderByWithRelationInput | especiebeneficioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: especiebeneficioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especiebeneficios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especiebeneficios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned especiebeneficios
    **/
    _count?: true | EspeciebeneficioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EspeciebeneficioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EspeciebeneficioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EspeciebeneficioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EspeciebeneficioMaxAggregateInputType
  }

  export type GetEspeciebeneficioAggregateType<T extends EspeciebeneficioAggregateArgs> = {
        [P in keyof T & keyof AggregateEspeciebeneficio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEspeciebeneficio[P]>
      : GetScalarType<T[P], AggregateEspeciebeneficio[P]>
  }




  export type especiebeneficioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: especiebeneficioWhereInput
    orderBy?: especiebeneficioOrderByWithAggregationInput | especiebeneficioOrderByWithAggregationInput[]
    by: EspeciebeneficioScalarFieldEnum[] | EspeciebeneficioScalarFieldEnum
    having?: especiebeneficioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EspeciebeneficioCountAggregateInputType | true
    _avg?: EspeciebeneficioAvgAggregateInputType
    _sum?: EspeciebeneficioSumAggregateInputType
    _min?: EspeciebeneficioMinAggregateInputType
    _max?: EspeciebeneficioMaxAggregateInputType
  }

  export type EspeciebeneficioGroupByOutputType = {
    id: number
    codigo: number
    descEspecieBeneficio: string
    gruposEspecie: string
    createdAt: Date
    updatedAt: Date
    _count: EspeciebeneficioCountAggregateOutputType | null
    _avg: EspeciebeneficioAvgAggregateOutputType | null
    _sum: EspeciebeneficioSumAggregateOutputType | null
    _min: EspeciebeneficioMinAggregateOutputType | null
    _max: EspeciebeneficioMaxAggregateOutputType | null
  }

  type GetEspeciebeneficioGroupByPayload<T extends especiebeneficioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EspeciebeneficioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EspeciebeneficioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EspeciebeneficioGroupByOutputType[P]>
            : GetScalarType<T[P], EspeciebeneficioGroupByOutputType[P]>
        }
      >
    >


  export type especiebeneficioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    descEspecieBeneficio?: boolean
    gruposEspecie?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["especiebeneficio"]>



  export type especiebeneficioSelectScalar = {
    id?: boolean
    codigo?: boolean
    descEspecieBeneficio?: boolean
    gruposEspecie?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type especiebeneficioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codigo" | "descEspecieBeneficio" | "gruposEspecie" | "createdAt" | "updatedAt", ExtArgs["result"]["especiebeneficio"]>

  export type $especiebeneficioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "especiebeneficio"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigo: number
      descEspecieBeneficio: string
      gruposEspecie: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["especiebeneficio"]>
    composites: {}
  }

  type especiebeneficioGetPayload<S extends boolean | null | undefined | especiebeneficioDefaultArgs> = $Result.GetResult<Prisma.$especiebeneficioPayload, S>

  type especiebeneficioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<especiebeneficioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EspeciebeneficioCountAggregateInputType | true
    }

  export interface especiebeneficioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['especiebeneficio'], meta: { name: 'especiebeneficio' } }
    /**
     * Find zero or one Especiebeneficio that matches the filter.
     * @param {especiebeneficioFindUniqueArgs} args - Arguments to find a Especiebeneficio
     * @example
     * // Get one Especiebeneficio
     * const especiebeneficio = await prisma.especiebeneficio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends especiebeneficioFindUniqueArgs>(args: SelectSubset<T, especiebeneficioFindUniqueArgs<ExtArgs>>): Prisma__especiebeneficioClient<$Result.GetResult<Prisma.$especiebeneficioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Especiebeneficio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {especiebeneficioFindUniqueOrThrowArgs} args - Arguments to find a Especiebeneficio
     * @example
     * // Get one Especiebeneficio
     * const especiebeneficio = await prisma.especiebeneficio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends especiebeneficioFindUniqueOrThrowArgs>(args: SelectSubset<T, especiebeneficioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__especiebeneficioClient<$Result.GetResult<Prisma.$especiebeneficioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Especiebeneficio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especiebeneficioFindFirstArgs} args - Arguments to find a Especiebeneficio
     * @example
     * // Get one Especiebeneficio
     * const especiebeneficio = await prisma.especiebeneficio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends especiebeneficioFindFirstArgs>(args?: SelectSubset<T, especiebeneficioFindFirstArgs<ExtArgs>>): Prisma__especiebeneficioClient<$Result.GetResult<Prisma.$especiebeneficioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Especiebeneficio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especiebeneficioFindFirstOrThrowArgs} args - Arguments to find a Especiebeneficio
     * @example
     * // Get one Especiebeneficio
     * const especiebeneficio = await prisma.especiebeneficio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends especiebeneficioFindFirstOrThrowArgs>(args?: SelectSubset<T, especiebeneficioFindFirstOrThrowArgs<ExtArgs>>): Prisma__especiebeneficioClient<$Result.GetResult<Prisma.$especiebeneficioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Especiebeneficios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especiebeneficioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Especiebeneficios
     * const especiebeneficios = await prisma.especiebeneficio.findMany()
     * 
     * // Get first 10 Especiebeneficios
     * const especiebeneficios = await prisma.especiebeneficio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const especiebeneficioWithIdOnly = await prisma.especiebeneficio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends especiebeneficioFindManyArgs>(args?: SelectSubset<T, especiebeneficioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$especiebeneficioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Especiebeneficio.
     * @param {especiebeneficioCreateArgs} args - Arguments to create a Especiebeneficio.
     * @example
     * // Create one Especiebeneficio
     * const Especiebeneficio = await prisma.especiebeneficio.create({
     *   data: {
     *     // ... data to create a Especiebeneficio
     *   }
     * })
     * 
     */
    create<T extends especiebeneficioCreateArgs>(args: SelectSubset<T, especiebeneficioCreateArgs<ExtArgs>>): Prisma__especiebeneficioClient<$Result.GetResult<Prisma.$especiebeneficioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Especiebeneficios.
     * @param {especiebeneficioCreateManyArgs} args - Arguments to create many Especiebeneficios.
     * @example
     * // Create many Especiebeneficios
     * const especiebeneficio = await prisma.especiebeneficio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends especiebeneficioCreateManyArgs>(args?: SelectSubset<T, especiebeneficioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Especiebeneficio.
     * @param {especiebeneficioDeleteArgs} args - Arguments to delete one Especiebeneficio.
     * @example
     * // Delete one Especiebeneficio
     * const Especiebeneficio = await prisma.especiebeneficio.delete({
     *   where: {
     *     // ... filter to delete one Especiebeneficio
     *   }
     * })
     * 
     */
    delete<T extends especiebeneficioDeleteArgs>(args: SelectSubset<T, especiebeneficioDeleteArgs<ExtArgs>>): Prisma__especiebeneficioClient<$Result.GetResult<Prisma.$especiebeneficioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Especiebeneficio.
     * @param {especiebeneficioUpdateArgs} args - Arguments to update one Especiebeneficio.
     * @example
     * // Update one Especiebeneficio
     * const especiebeneficio = await prisma.especiebeneficio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends especiebeneficioUpdateArgs>(args: SelectSubset<T, especiebeneficioUpdateArgs<ExtArgs>>): Prisma__especiebeneficioClient<$Result.GetResult<Prisma.$especiebeneficioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Especiebeneficios.
     * @param {especiebeneficioDeleteManyArgs} args - Arguments to filter Especiebeneficios to delete.
     * @example
     * // Delete a few Especiebeneficios
     * const { count } = await prisma.especiebeneficio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends especiebeneficioDeleteManyArgs>(args?: SelectSubset<T, especiebeneficioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Especiebeneficios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especiebeneficioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Especiebeneficios
     * const especiebeneficio = await prisma.especiebeneficio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends especiebeneficioUpdateManyArgs>(args: SelectSubset<T, especiebeneficioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Especiebeneficio.
     * @param {especiebeneficioUpsertArgs} args - Arguments to update or create a Especiebeneficio.
     * @example
     * // Update or create a Especiebeneficio
     * const especiebeneficio = await prisma.especiebeneficio.upsert({
     *   create: {
     *     // ... data to create a Especiebeneficio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Especiebeneficio we want to update
     *   }
     * })
     */
    upsert<T extends especiebeneficioUpsertArgs>(args: SelectSubset<T, especiebeneficioUpsertArgs<ExtArgs>>): Prisma__especiebeneficioClient<$Result.GetResult<Prisma.$especiebeneficioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Especiebeneficios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especiebeneficioCountArgs} args - Arguments to filter Especiebeneficios to count.
     * @example
     * // Count the number of Especiebeneficios
     * const count = await prisma.especiebeneficio.count({
     *   where: {
     *     // ... the filter for the Especiebeneficios we want to count
     *   }
     * })
    **/
    count<T extends especiebeneficioCountArgs>(
      args?: Subset<T, especiebeneficioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EspeciebeneficioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Especiebeneficio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspeciebeneficioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EspeciebeneficioAggregateArgs>(args: Subset<T, EspeciebeneficioAggregateArgs>): Prisma.PrismaPromise<GetEspeciebeneficioAggregateType<T>>

    /**
     * Group by Especiebeneficio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especiebeneficioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends especiebeneficioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: especiebeneficioGroupByArgs['orderBy'] }
        : { orderBy?: especiebeneficioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, especiebeneficioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEspeciebeneficioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the especiebeneficio model
   */
  readonly fields: especiebeneficioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for especiebeneficio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__especiebeneficioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the especiebeneficio model
   */
  interface especiebeneficioFieldRefs {
    readonly id: FieldRef<"especiebeneficio", 'Int'>
    readonly codigo: FieldRef<"especiebeneficio", 'Int'>
    readonly descEspecieBeneficio: FieldRef<"especiebeneficio", 'String'>
    readonly gruposEspecie: FieldRef<"especiebeneficio", 'String'>
    readonly createdAt: FieldRef<"especiebeneficio", 'DateTime'>
    readonly updatedAt: FieldRef<"especiebeneficio", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * especiebeneficio findUnique
   */
  export type especiebeneficioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especiebeneficio
     */
    select?: especiebeneficioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especiebeneficio
     */
    omit?: especiebeneficioOmit<ExtArgs> | null
    /**
     * Filter, which especiebeneficio to fetch.
     */
    where: especiebeneficioWhereUniqueInput
  }

  /**
   * especiebeneficio findUniqueOrThrow
   */
  export type especiebeneficioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especiebeneficio
     */
    select?: especiebeneficioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especiebeneficio
     */
    omit?: especiebeneficioOmit<ExtArgs> | null
    /**
     * Filter, which especiebeneficio to fetch.
     */
    where: especiebeneficioWhereUniqueInput
  }

  /**
   * especiebeneficio findFirst
   */
  export type especiebeneficioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especiebeneficio
     */
    select?: especiebeneficioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especiebeneficio
     */
    omit?: especiebeneficioOmit<ExtArgs> | null
    /**
     * Filter, which especiebeneficio to fetch.
     */
    where?: especiebeneficioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especiebeneficios to fetch.
     */
    orderBy?: especiebeneficioOrderByWithRelationInput | especiebeneficioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for especiebeneficios.
     */
    cursor?: especiebeneficioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especiebeneficios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especiebeneficios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of especiebeneficios.
     */
    distinct?: EspeciebeneficioScalarFieldEnum | EspeciebeneficioScalarFieldEnum[]
  }

  /**
   * especiebeneficio findFirstOrThrow
   */
  export type especiebeneficioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especiebeneficio
     */
    select?: especiebeneficioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especiebeneficio
     */
    omit?: especiebeneficioOmit<ExtArgs> | null
    /**
     * Filter, which especiebeneficio to fetch.
     */
    where?: especiebeneficioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especiebeneficios to fetch.
     */
    orderBy?: especiebeneficioOrderByWithRelationInput | especiebeneficioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for especiebeneficios.
     */
    cursor?: especiebeneficioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especiebeneficios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especiebeneficios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of especiebeneficios.
     */
    distinct?: EspeciebeneficioScalarFieldEnum | EspeciebeneficioScalarFieldEnum[]
  }

  /**
   * especiebeneficio findMany
   */
  export type especiebeneficioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especiebeneficio
     */
    select?: especiebeneficioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especiebeneficio
     */
    omit?: especiebeneficioOmit<ExtArgs> | null
    /**
     * Filter, which especiebeneficios to fetch.
     */
    where?: especiebeneficioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especiebeneficios to fetch.
     */
    orderBy?: especiebeneficioOrderByWithRelationInput | especiebeneficioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing especiebeneficios.
     */
    cursor?: especiebeneficioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especiebeneficios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especiebeneficios.
     */
    skip?: number
    distinct?: EspeciebeneficioScalarFieldEnum | EspeciebeneficioScalarFieldEnum[]
  }

  /**
   * especiebeneficio create
   */
  export type especiebeneficioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especiebeneficio
     */
    select?: especiebeneficioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especiebeneficio
     */
    omit?: especiebeneficioOmit<ExtArgs> | null
    /**
     * The data needed to create a especiebeneficio.
     */
    data: XOR<especiebeneficioCreateInput, especiebeneficioUncheckedCreateInput>
  }

  /**
   * especiebeneficio createMany
   */
  export type especiebeneficioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many especiebeneficios.
     */
    data: especiebeneficioCreateManyInput | especiebeneficioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * especiebeneficio update
   */
  export type especiebeneficioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especiebeneficio
     */
    select?: especiebeneficioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especiebeneficio
     */
    omit?: especiebeneficioOmit<ExtArgs> | null
    /**
     * The data needed to update a especiebeneficio.
     */
    data: XOR<especiebeneficioUpdateInput, especiebeneficioUncheckedUpdateInput>
    /**
     * Choose, which especiebeneficio to update.
     */
    where: especiebeneficioWhereUniqueInput
  }

  /**
   * especiebeneficio updateMany
   */
  export type especiebeneficioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update especiebeneficios.
     */
    data: XOR<especiebeneficioUpdateManyMutationInput, especiebeneficioUncheckedUpdateManyInput>
    /**
     * Filter which especiebeneficios to update
     */
    where?: especiebeneficioWhereInput
    /**
     * Limit how many especiebeneficios to update.
     */
    limit?: number
  }

  /**
   * especiebeneficio upsert
   */
  export type especiebeneficioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especiebeneficio
     */
    select?: especiebeneficioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especiebeneficio
     */
    omit?: especiebeneficioOmit<ExtArgs> | null
    /**
     * The filter to search for the especiebeneficio to update in case it exists.
     */
    where: especiebeneficioWhereUniqueInput
    /**
     * In case the especiebeneficio found by the `where` argument doesn't exist, create a new especiebeneficio with this data.
     */
    create: XOR<especiebeneficioCreateInput, especiebeneficioUncheckedCreateInput>
    /**
     * In case the especiebeneficio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<especiebeneficioUpdateInput, especiebeneficioUncheckedUpdateInput>
  }

  /**
   * especiebeneficio delete
   */
  export type especiebeneficioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especiebeneficio
     */
    select?: especiebeneficioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especiebeneficio
     */
    omit?: especiebeneficioOmit<ExtArgs> | null
    /**
     * Filter which especiebeneficio to delete.
     */
    where: especiebeneficioWhereUniqueInput
  }

  /**
   * especiebeneficio deleteMany
   */
  export type especiebeneficioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which especiebeneficios to delete
     */
    where?: especiebeneficioWhereInput
    /**
     * Limit how many especiebeneficios to delete.
     */
    limit?: number
  }

  /**
   * especiebeneficio without action
   */
  export type especiebeneficioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especiebeneficio
     */
    select?: especiebeneficioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the especiebeneficio
     */
    omit?: especiebeneficioOmit<ExtArgs> | null
  }


  /**
   * Model extratooffline
   */

  export type AggregateExtratooffline = {
    _count: ExtratoofflineCountAggregateOutputType | null
    _avg: ExtratoofflineAvgAggregateOutputType | null
    _sum: ExtratoofflineSumAggregateOutputType | null
    _min: ExtratoofflineMinAggregateOutputType | null
    _max: ExtratoofflineMaxAggregateOutputType | null
  }

  export type ExtratoofflineAvgAggregateOutputType = {
    id: number | null
    idFornecedor: number | null
    idConsulta: number | null
    idUsuario: number | null
  }

  export type ExtratoofflineSumAggregateOutputType = {
    id: number | null
    idFornecedor: number | null
    idConsulta: number | null
    idUsuario: number | null
  }

  export type ExtratoofflineMinAggregateOutputType = {
    id: number | null
    cpf: string | null
    beneficio: string | null
    createdAt: Date | null
    updatedAt: Date | null
    idFornecedor: number | null
    idConsulta: number | null
    idUsuario: number | null
  }

  export type ExtratoofflineMaxAggregateOutputType = {
    id: number | null
    cpf: string | null
    beneficio: string | null
    createdAt: Date | null
    updatedAt: Date | null
    idFornecedor: number | null
    idConsulta: number | null
    idUsuario: number | null
  }

  export type ExtratoofflineCountAggregateOutputType = {
    id: number
    cpf: number
    beneficio: number
    jsonResult: number
    createdAt: number
    updatedAt: number
    idFornecedor: number
    idConsulta: number
    idUsuario: number
    _all: number
  }


  export type ExtratoofflineAvgAggregateInputType = {
    id?: true
    idFornecedor?: true
    idConsulta?: true
    idUsuario?: true
  }

  export type ExtratoofflineSumAggregateInputType = {
    id?: true
    idFornecedor?: true
    idConsulta?: true
    idUsuario?: true
  }

  export type ExtratoofflineMinAggregateInputType = {
    id?: true
    cpf?: true
    beneficio?: true
    createdAt?: true
    updatedAt?: true
    idFornecedor?: true
    idConsulta?: true
    idUsuario?: true
  }

  export type ExtratoofflineMaxAggregateInputType = {
    id?: true
    cpf?: true
    beneficio?: true
    createdAt?: true
    updatedAt?: true
    idFornecedor?: true
    idConsulta?: true
    idUsuario?: true
  }

  export type ExtratoofflineCountAggregateInputType = {
    id?: true
    cpf?: true
    beneficio?: true
    jsonResult?: true
    createdAt?: true
    updatedAt?: true
    idFornecedor?: true
    idConsulta?: true
    idUsuario?: true
    _all?: true
  }

  export type ExtratoofflineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which extratooffline to aggregate.
     */
    where?: extratoofflineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extratoofflines to fetch.
     */
    orderBy?: extratoofflineOrderByWithRelationInput | extratoofflineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: extratoofflineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extratoofflines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extratoofflines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned extratoofflines
    **/
    _count?: true | ExtratoofflineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExtratoofflineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExtratoofflineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExtratoofflineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExtratoofflineMaxAggregateInputType
  }

  export type GetExtratoofflineAggregateType<T extends ExtratoofflineAggregateArgs> = {
        [P in keyof T & keyof AggregateExtratooffline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtratooffline[P]>
      : GetScalarType<T[P], AggregateExtratooffline[P]>
  }




  export type extratoofflineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: extratoofflineWhereInput
    orderBy?: extratoofflineOrderByWithAggregationInput | extratoofflineOrderByWithAggregationInput[]
    by: ExtratoofflineScalarFieldEnum[] | ExtratoofflineScalarFieldEnum
    having?: extratoofflineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExtratoofflineCountAggregateInputType | true
    _avg?: ExtratoofflineAvgAggregateInputType
    _sum?: ExtratoofflineSumAggregateInputType
    _min?: ExtratoofflineMinAggregateInputType
    _max?: ExtratoofflineMaxAggregateInputType
  }

  export type ExtratoofflineGroupByOutputType = {
    id: number
    cpf: string | null
    beneficio: string | null
    jsonResult: JsonValue | null
    createdAt: Date
    updatedAt: Date
    idFornecedor: number
    idConsulta: number
    idUsuario: number
    _count: ExtratoofflineCountAggregateOutputType | null
    _avg: ExtratoofflineAvgAggregateOutputType | null
    _sum: ExtratoofflineSumAggregateOutputType | null
    _min: ExtratoofflineMinAggregateOutputType | null
    _max: ExtratoofflineMaxAggregateOutputType | null
  }

  type GetExtratoofflineGroupByPayload<T extends extratoofflineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExtratoofflineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExtratoofflineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExtratoofflineGroupByOutputType[P]>
            : GetScalarType<T[P], ExtratoofflineGroupByOutputType[P]>
        }
      >
    >


  export type extratoofflineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cpf?: boolean
    beneficio?: boolean
    jsonResult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idFornecedor?: boolean
    idConsulta?: boolean
    idUsuario?: boolean
  }, ExtArgs["result"]["extratooffline"]>



  export type extratoofflineSelectScalar = {
    id?: boolean
    cpf?: boolean
    beneficio?: boolean
    jsonResult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idFornecedor?: boolean
    idConsulta?: boolean
    idUsuario?: boolean
  }

  export type extratoofflineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cpf" | "beneficio" | "jsonResult" | "createdAt" | "updatedAt" | "idFornecedor" | "idConsulta" | "idUsuario", ExtArgs["result"]["extratooffline"]>

  export type $extratoofflinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "extratooffline"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cpf: string | null
      beneficio: string | null
      jsonResult: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      idFornecedor: number
      idConsulta: number
      idUsuario: number
    }, ExtArgs["result"]["extratooffline"]>
    composites: {}
  }

  type extratoofflineGetPayload<S extends boolean | null | undefined | extratoofflineDefaultArgs> = $Result.GetResult<Prisma.$extratoofflinePayload, S>

  type extratoofflineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<extratoofflineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExtratoofflineCountAggregateInputType | true
    }

  export interface extratoofflineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['extratooffline'], meta: { name: 'extratooffline' } }
    /**
     * Find zero or one Extratooffline that matches the filter.
     * @param {extratoofflineFindUniqueArgs} args - Arguments to find a Extratooffline
     * @example
     * // Get one Extratooffline
     * const extratooffline = await prisma.extratooffline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends extratoofflineFindUniqueArgs>(args: SelectSubset<T, extratoofflineFindUniqueArgs<ExtArgs>>): Prisma__extratoofflineClient<$Result.GetResult<Prisma.$extratoofflinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Extratooffline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {extratoofflineFindUniqueOrThrowArgs} args - Arguments to find a Extratooffline
     * @example
     * // Get one Extratooffline
     * const extratooffline = await prisma.extratooffline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends extratoofflineFindUniqueOrThrowArgs>(args: SelectSubset<T, extratoofflineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__extratoofflineClient<$Result.GetResult<Prisma.$extratoofflinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Extratooffline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extratoofflineFindFirstArgs} args - Arguments to find a Extratooffline
     * @example
     * // Get one Extratooffline
     * const extratooffline = await prisma.extratooffline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends extratoofflineFindFirstArgs>(args?: SelectSubset<T, extratoofflineFindFirstArgs<ExtArgs>>): Prisma__extratoofflineClient<$Result.GetResult<Prisma.$extratoofflinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Extratooffline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extratoofflineFindFirstOrThrowArgs} args - Arguments to find a Extratooffline
     * @example
     * // Get one Extratooffline
     * const extratooffline = await prisma.extratooffline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends extratoofflineFindFirstOrThrowArgs>(args?: SelectSubset<T, extratoofflineFindFirstOrThrowArgs<ExtArgs>>): Prisma__extratoofflineClient<$Result.GetResult<Prisma.$extratoofflinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Extratoofflines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extratoofflineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Extratoofflines
     * const extratoofflines = await prisma.extratooffline.findMany()
     * 
     * // Get first 10 Extratoofflines
     * const extratoofflines = await prisma.extratooffline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const extratoofflineWithIdOnly = await prisma.extratooffline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends extratoofflineFindManyArgs>(args?: SelectSubset<T, extratoofflineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$extratoofflinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Extratooffline.
     * @param {extratoofflineCreateArgs} args - Arguments to create a Extratooffline.
     * @example
     * // Create one Extratooffline
     * const Extratooffline = await prisma.extratooffline.create({
     *   data: {
     *     // ... data to create a Extratooffline
     *   }
     * })
     * 
     */
    create<T extends extratoofflineCreateArgs>(args: SelectSubset<T, extratoofflineCreateArgs<ExtArgs>>): Prisma__extratoofflineClient<$Result.GetResult<Prisma.$extratoofflinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Extratoofflines.
     * @param {extratoofflineCreateManyArgs} args - Arguments to create many Extratoofflines.
     * @example
     * // Create many Extratoofflines
     * const extratooffline = await prisma.extratooffline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends extratoofflineCreateManyArgs>(args?: SelectSubset<T, extratoofflineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Extratooffline.
     * @param {extratoofflineDeleteArgs} args - Arguments to delete one Extratooffline.
     * @example
     * // Delete one Extratooffline
     * const Extratooffline = await prisma.extratooffline.delete({
     *   where: {
     *     // ... filter to delete one Extratooffline
     *   }
     * })
     * 
     */
    delete<T extends extratoofflineDeleteArgs>(args: SelectSubset<T, extratoofflineDeleteArgs<ExtArgs>>): Prisma__extratoofflineClient<$Result.GetResult<Prisma.$extratoofflinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Extratooffline.
     * @param {extratoofflineUpdateArgs} args - Arguments to update one Extratooffline.
     * @example
     * // Update one Extratooffline
     * const extratooffline = await prisma.extratooffline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends extratoofflineUpdateArgs>(args: SelectSubset<T, extratoofflineUpdateArgs<ExtArgs>>): Prisma__extratoofflineClient<$Result.GetResult<Prisma.$extratoofflinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Extratoofflines.
     * @param {extratoofflineDeleteManyArgs} args - Arguments to filter Extratoofflines to delete.
     * @example
     * // Delete a few Extratoofflines
     * const { count } = await prisma.extratooffline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends extratoofflineDeleteManyArgs>(args?: SelectSubset<T, extratoofflineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Extratoofflines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extratoofflineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Extratoofflines
     * const extratooffline = await prisma.extratooffline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends extratoofflineUpdateManyArgs>(args: SelectSubset<T, extratoofflineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Extratooffline.
     * @param {extratoofflineUpsertArgs} args - Arguments to update or create a Extratooffline.
     * @example
     * // Update or create a Extratooffline
     * const extratooffline = await prisma.extratooffline.upsert({
     *   create: {
     *     // ... data to create a Extratooffline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Extratooffline we want to update
     *   }
     * })
     */
    upsert<T extends extratoofflineUpsertArgs>(args: SelectSubset<T, extratoofflineUpsertArgs<ExtArgs>>): Prisma__extratoofflineClient<$Result.GetResult<Prisma.$extratoofflinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Extratoofflines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extratoofflineCountArgs} args - Arguments to filter Extratoofflines to count.
     * @example
     * // Count the number of Extratoofflines
     * const count = await prisma.extratooffline.count({
     *   where: {
     *     // ... the filter for the Extratoofflines we want to count
     *   }
     * })
    **/
    count<T extends extratoofflineCountArgs>(
      args?: Subset<T, extratoofflineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExtratoofflineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Extratooffline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtratoofflineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExtratoofflineAggregateArgs>(args: Subset<T, ExtratoofflineAggregateArgs>): Prisma.PrismaPromise<GetExtratoofflineAggregateType<T>>

    /**
     * Group by Extratooffline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extratoofflineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends extratoofflineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: extratoofflineGroupByArgs['orderBy'] }
        : { orderBy?: extratoofflineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, extratoofflineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExtratoofflineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the extratooffline model
   */
  readonly fields: extratoofflineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for extratooffline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__extratoofflineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the extratooffline model
   */
  interface extratoofflineFieldRefs {
    readonly id: FieldRef<"extratooffline", 'Int'>
    readonly cpf: FieldRef<"extratooffline", 'String'>
    readonly beneficio: FieldRef<"extratooffline", 'String'>
    readonly jsonResult: FieldRef<"extratooffline", 'Json'>
    readonly createdAt: FieldRef<"extratooffline", 'DateTime'>
    readonly updatedAt: FieldRef<"extratooffline", 'DateTime'>
    readonly idFornecedor: FieldRef<"extratooffline", 'Int'>
    readonly idConsulta: FieldRef<"extratooffline", 'Int'>
    readonly idUsuario: FieldRef<"extratooffline", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * extratooffline findUnique
   */
  export type extratoofflineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratooffline
     */
    select?: extratoofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratooffline
     */
    omit?: extratoofflineOmit<ExtArgs> | null
    /**
     * Filter, which extratooffline to fetch.
     */
    where: extratoofflineWhereUniqueInput
  }

  /**
   * extratooffline findUniqueOrThrow
   */
  export type extratoofflineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratooffline
     */
    select?: extratoofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratooffline
     */
    omit?: extratoofflineOmit<ExtArgs> | null
    /**
     * Filter, which extratooffline to fetch.
     */
    where: extratoofflineWhereUniqueInput
  }

  /**
   * extratooffline findFirst
   */
  export type extratoofflineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratooffline
     */
    select?: extratoofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratooffline
     */
    omit?: extratoofflineOmit<ExtArgs> | null
    /**
     * Filter, which extratooffline to fetch.
     */
    where?: extratoofflineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extratoofflines to fetch.
     */
    orderBy?: extratoofflineOrderByWithRelationInput | extratoofflineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for extratoofflines.
     */
    cursor?: extratoofflineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extratoofflines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extratoofflines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of extratoofflines.
     */
    distinct?: ExtratoofflineScalarFieldEnum | ExtratoofflineScalarFieldEnum[]
  }

  /**
   * extratooffline findFirstOrThrow
   */
  export type extratoofflineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratooffline
     */
    select?: extratoofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratooffline
     */
    omit?: extratoofflineOmit<ExtArgs> | null
    /**
     * Filter, which extratooffline to fetch.
     */
    where?: extratoofflineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extratoofflines to fetch.
     */
    orderBy?: extratoofflineOrderByWithRelationInput | extratoofflineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for extratoofflines.
     */
    cursor?: extratoofflineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extratoofflines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extratoofflines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of extratoofflines.
     */
    distinct?: ExtratoofflineScalarFieldEnum | ExtratoofflineScalarFieldEnum[]
  }

  /**
   * extratooffline findMany
   */
  export type extratoofflineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratooffline
     */
    select?: extratoofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratooffline
     */
    omit?: extratoofflineOmit<ExtArgs> | null
    /**
     * Filter, which extratoofflines to fetch.
     */
    where?: extratoofflineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extratoofflines to fetch.
     */
    orderBy?: extratoofflineOrderByWithRelationInput | extratoofflineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing extratoofflines.
     */
    cursor?: extratoofflineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extratoofflines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extratoofflines.
     */
    skip?: number
    distinct?: ExtratoofflineScalarFieldEnum | ExtratoofflineScalarFieldEnum[]
  }

  /**
   * extratooffline create
   */
  export type extratoofflineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratooffline
     */
    select?: extratoofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratooffline
     */
    omit?: extratoofflineOmit<ExtArgs> | null
    /**
     * The data needed to create a extratooffline.
     */
    data: XOR<extratoofflineCreateInput, extratoofflineUncheckedCreateInput>
  }

  /**
   * extratooffline createMany
   */
  export type extratoofflineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many extratoofflines.
     */
    data: extratoofflineCreateManyInput | extratoofflineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * extratooffline update
   */
  export type extratoofflineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratooffline
     */
    select?: extratoofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratooffline
     */
    omit?: extratoofflineOmit<ExtArgs> | null
    /**
     * The data needed to update a extratooffline.
     */
    data: XOR<extratoofflineUpdateInput, extratoofflineUncheckedUpdateInput>
    /**
     * Choose, which extratooffline to update.
     */
    where: extratoofflineWhereUniqueInput
  }

  /**
   * extratooffline updateMany
   */
  export type extratoofflineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update extratoofflines.
     */
    data: XOR<extratoofflineUpdateManyMutationInput, extratoofflineUncheckedUpdateManyInput>
    /**
     * Filter which extratoofflines to update
     */
    where?: extratoofflineWhereInput
    /**
     * Limit how many extratoofflines to update.
     */
    limit?: number
  }

  /**
   * extratooffline upsert
   */
  export type extratoofflineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratooffline
     */
    select?: extratoofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratooffline
     */
    omit?: extratoofflineOmit<ExtArgs> | null
    /**
     * The filter to search for the extratooffline to update in case it exists.
     */
    where: extratoofflineWhereUniqueInput
    /**
     * In case the extratooffline found by the `where` argument doesn't exist, create a new extratooffline with this data.
     */
    create: XOR<extratoofflineCreateInput, extratoofflineUncheckedCreateInput>
    /**
     * In case the extratooffline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<extratoofflineUpdateInput, extratoofflineUncheckedUpdateInput>
  }

  /**
   * extratooffline delete
   */
  export type extratoofflineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratooffline
     */
    select?: extratoofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratooffline
     */
    omit?: extratoofflineOmit<ExtArgs> | null
    /**
     * Filter which extratooffline to delete.
     */
    where: extratoofflineWhereUniqueInput
  }

  /**
   * extratooffline deleteMany
   */
  export type extratoofflineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which extratoofflines to delete
     */
    where?: extratoofflineWhereInput
    /**
     * Limit how many extratoofflines to delete.
     */
    limit?: number
  }

  /**
   * extratooffline without action
   */
  export type extratoofflineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratooffline
     */
    select?: extratoofflineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratooffline
     */
    omit?: extratoofflineOmit<ExtArgs> | null
  }


  /**
   * Model extratoonline
   */

  export type AggregateExtratoonline = {
    _count: ExtratoonlineCountAggregateOutputType | null
    _avg: ExtratoonlineAvgAggregateOutputType | null
    _sum: ExtratoonlineSumAggregateOutputType | null
    _min: ExtratoonlineMinAggregateOutputType | null
    _max: ExtratoonlineMaxAggregateOutputType | null
  }

  export type ExtratoonlineAvgAggregateOutputType = {
    id: number | null
    idConsulta: number | null
    id_fornecedor: number | null
    statusConsulta: number | null
    idConsultaOffline: number | null
    idUsuario: number | null
  }

  export type ExtratoonlineSumAggregateOutputType = {
    id: number | null
    idConsulta: number | null
    id_fornecedor: number | null
    statusConsulta: number | null
    idConsultaOffline: number | null
    idUsuario: number | null
  }

  export type ExtratoonlineMinAggregateOutputType = {
    id: number | null
    idConsulta: number | null
    id_fornecedor: number | null
    beneficio: string | null
    filePdf: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    isCache: boolean | null
    statusConsulta: number | null
    idConsultaOffline: number | null
    errorResult: string | null
    idUsuario: number | null
  }

  export type ExtratoonlineMaxAggregateOutputType = {
    id: number | null
    idConsulta: number | null
    id_fornecedor: number | null
    beneficio: string | null
    filePdf: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    isCache: boolean | null
    statusConsulta: number | null
    idConsultaOffline: number | null
    errorResult: string | null
    idUsuario: number | null
  }

  export type ExtratoonlineCountAggregateOutputType = {
    id: number
    idConsulta: number
    id_fornecedor: number
    beneficio: number
    jsonResult: number
    filePdf: number
    createdAt: number
    updatedAt: number
    isCache: number
    statusConsulta: number
    idConsultaOffline: number
    errorResult: number
    idUsuario: number
    _all: number
  }


  export type ExtratoonlineAvgAggregateInputType = {
    id?: true
    idConsulta?: true
    id_fornecedor?: true
    statusConsulta?: true
    idConsultaOffline?: true
    idUsuario?: true
  }

  export type ExtratoonlineSumAggregateInputType = {
    id?: true
    idConsulta?: true
    id_fornecedor?: true
    statusConsulta?: true
    idConsultaOffline?: true
    idUsuario?: true
  }

  export type ExtratoonlineMinAggregateInputType = {
    id?: true
    idConsulta?: true
    id_fornecedor?: true
    beneficio?: true
    filePdf?: true
    createdAt?: true
    updatedAt?: true
    isCache?: true
    statusConsulta?: true
    idConsultaOffline?: true
    errorResult?: true
    idUsuario?: true
  }

  export type ExtratoonlineMaxAggregateInputType = {
    id?: true
    idConsulta?: true
    id_fornecedor?: true
    beneficio?: true
    filePdf?: true
    createdAt?: true
    updatedAt?: true
    isCache?: true
    statusConsulta?: true
    idConsultaOffline?: true
    errorResult?: true
    idUsuario?: true
  }

  export type ExtratoonlineCountAggregateInputType = {
    id?: true
    idConsulta?: true
    id_fornecedor?: true
    beneficio?: true
    jsonResult?: true
    filePdf?: true
    createdAt?: true
    updatedAt?: true
    isCache?: true
    statusConsulta?: true
    idConsultaOffline?: true
    errorResult?: true
    idUsuario?: true
    _all?: true
  }

  export type ExtratoonlineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which extratoonline to aggregate.
     */
    where?: extratoonlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extratoonlines to fetch.
     */
    orderBy?: extratoonlineOrderByWithRelationInput | extratoonlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: extratoonlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extratoonlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extratoonlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned extratoonlines
    **/
    _count?: true | ExtratoonlineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExtratoonlineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExtratoonlineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExtratoonlineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExtratoonlineMaxAggregateInputType
  }

  export type GetExtratoonlineAggregateType<T extends ExtratoonlineAggregateArgs> = {
        [P in keyof T & keyof AggregateExtratoonline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtratoonline[P]>
      : GetScalarType<T[P], AggregateExtratoonline[P]>
  }




  export type extratoonlineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: extratoonlineWhereInput
    orderBy?: extratoonlineOrderByWithAggregationInput | extratoonlineOrderByWithAggregationInput[]
    by: ExtratoonlineScalarFieldEnum[] | ExtratoonlineScalarFieldEnum
    having?: extratoonlineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExtratoonlineCountAggregateInputType | true
    _avg?: ExtratoonlineAvgAggregateInputType
    _sum?: ExtratoonlineSumAggregateInputType
    _min?: ExtratoonlineMinAggregateInputType
    _max?: ExtratoonlineMaxAggregateInputType
  }

  export type ExtratoonlineGroupByOutputType = {
    id: number
    idConsulta: number
    id_fornecedor: number
    beneficio: string
    jsonResult: JsonValue | null
    filePdf: Uint8Array | null
    createdAt: Date
    updatedAt: Date
    isCache: boolean | null
    statusConsulta: number | null
    idConsultaOffline: number
    errorResult: string | null
    idUsuario: number
    _count: ExtratoonlineCountAggregateOutputType | null
    _avg: ExtratoonlineAvgAggregateOutputType | null
    _sum: ExtratoonlineSumAggregateOutputType | null
    _min: ExtratoonlineMinAggregateOutputType | null
    _max: ExtratoonlineMaxAggregateOutputType | null
  }

  type GetExtratoonlineGroupByPayload<T extends extratoonlineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExtratoonlineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExtratoonlineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExtratoonlineGroupByOutputType[P]>
            : GetScalarType<T[P], ExtratoonlineGroupByOutputType[P]>
        }
      >
    >


  export type extratoonlineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idConsulta?: boolean
    id_fornecedor?: boolean
    beneficio?: boolean
    jsonResult?: boolean
    filePdf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isCache?: boolean
    statusConsulta?: boolean
    idConsultaOffline?: boolean
    errorResult?: boolean
    idUsuario?: boolean
  }, ExtArgs["result"]["extratoonline"]>



  export type extratoonlineSelectScalar = {
    id?: boolean
    idConsulta?: boolean
    id_fornecedor?: boolean
    beneficio?: boolean
    jsonResult?: boolean
    filePdf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isCache?: boolean
    statusConsulta?: boolean
    idConsultaOffline?: boolean
    errorResult?: boolean
    idUsuario?: boolean
  }

  export type extratoonlineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idConsulta" | "id_fornecedor" | "beneficio" | "jsonResult" | "filePdf" | "createdAt" | "updatedAt" | "isCache" | "statusConsulta" | "idConsultaOffline" | "errorResult" | "idUsuario", ExtArgs["result"]["extratoonline"]>

  export type $extratoonlinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "extratoonline"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idConsulta: number
      id_fornecedor: number
      beneficio: string
      jsonResult: Prisma.JsonValue | null
      filePdf: Uint8Array | null
      createdAt: Date
      updatedAt: Date
      isCache: boolean | null
      statusConsulta: number | null
      idConsultaOffline: number
      errorResult: string | null
      idUsuario: number
    }, ExtArgs["result"]["extratoonline"]>
    composites: {}
  }

  type extratoonlineGetPayload<S extends boolean | null | undefined | extratoonlineDefaultArgs> = $Result.GetResult<Prisma.$extratoonlinePayload, S>

  type extratoonlineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<extratoonlineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExtratoonlineCountAggregateInputType | true
    }

  export interface extratoonlineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['extratoonline'], meta: { name: 'extratoonline' } }
    /**
     * Find zero or one Extratoonline that matches the filter.
     * @param {extratoonlineFindUniqueArgs} args - Arguments to find a Extratoonline
     * @example
     * // Get one Extratoonline
     * const extratoonline = await prisma.extratoonline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends extratoonlineFindUniqueArgs>(args: SelectSubset<T, extratoonlineFindUniqueArgs<ExtArgs>>): Prisma__extratoonlineClient<$Result.GetResult<Prisma.$extratoonlinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Extratoonline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {extratoonlineFindUniqueOrThrowArgs} args - Arguments to find a Extratoonline
     * @example
     * // Get one Extratoonline
     * const extratoonline = await prisma.extratoonline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends extratoonlineFindUniqueOrThrowArgs>(args: SelectSubset<T, extratoonlineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__extratoonlineClient<$Result.GetResult<Prisma.$extratoonlinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Extratoonline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extratoonlineFindFirstArgs} args - Arguments to find a Extratoonline
     * @example
     * // Get one Extratoonline
     * const extratoonline = await prisma.extratoonline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends extratoonlineFindFirstArgs>(args?: SelectSubset<T, extratoonlineFindFirstArgs<ExtArgs>>): Prisma__extratoonlineClient<$Result.GetResult<Prisma.$extratoonlinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Extratoonline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extratoonlineFindFirstOrThrowArgs} args - Arguments to find a Extratoonline
     * @example
     * // Get one Extratoonline
     * const extratoonline = await prisma.extratoonline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends extratoonlineFindFirstOrThrowArgs>(args?: SelectSubset<T, extratoonlineFindFirstOrThrowArgs<ExtArgs>>): Prisma__extratoonlineClient<$Result.GetResult<Prisma.$extratoonlinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Extratoonlines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extratoonlineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Extratoonlines
     * const extratoonlines = await prisma.extratoonline.findMany()
     * 
     * // Get first 10 Extratoonlines
     * const extratoonlines = await prisma.extratoonline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const extratoonlineWithIdOnly = await prisma.extratoonline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends extratoonlineFindManyArgs>(args?: SelectSubset<T, extratoonlineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$extratoonlinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Extratoonline.
     * @param {extratoonlineCreateArgs} args - Arguments to create a Extratoonline.
     * @example
     * // Create one Extratoonline
     * const Extratoonline = await prisma.extratoonline.create({
     *   data: {
     *     // ... data to create a Extratoonline
     *   }
     * })
     * 
     */
    create<T extends extratoonlineCreateArgs>(args: SelectSubset<T, extratoonlineCreateArgs<ExtArgs>>): Prisma__extratoonlineClient<$Result.GetResult<Prisma.$extratoonlinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Extratoonlines.
     * @param {extratoonlineCreateManyArgs} args - Arguments to create many Extratoonlines.
     * @example
     * // Create many Extratoonlines
     * const extratoonline = await prisma.extratoonline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends extratoonlineCreateManyArgs>(args?: SelectSubset<T, extratoonlineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Extratoonline.
     * @param {extratoonlineDeleteArgs} args - Arguments to delete one Extratoonline.
     * @example
     * // Delete one Extratoonline
     * const Extratoonline = await prisma.extratoonline.delete({
     *   where: {
     *     // ... filter to delete one Extratoonline
     *   }
     * })
     * 
     */
    delete<T extends extratoonlineDeleteArgs>(args: SelectSubset<T, extratoonlineDeleteArgs<ExtArgs>>): Prisma__extratoonlineClient<$Result.GetResult<Prisma.$extratoonlinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Extratoonline.
     * @param {extratoonlineUpdateArgs} args - Arguments to update one Extratoonline.
     * @example
     * // Update one Extratoonline
     * const extratoonline = await prisma.extratoonline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends extratoonlineUpdateArgs>(args: SelectSubset<T, extratoonlineUpdateArgs<ExtArgs>>): Prisma__extratoonlineClient<$Result.GetResult<Prisma.$extratoonlinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Extratoonlines.
     * @param {extratoonlineDeleteManyArgs} args - Arguments to filter Extratoonlines to delete.
     * @example
     * // Delete a few Extratoonlines
     * const { count } = await prisma.extratoonline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends extratoonlineDeleteManyArgs>(args?: SelectSubset<T, extratoonlineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Extratoonlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extratoonlineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Extratoonlines
     * const extratoonline = await prisma.extratoonline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends extratoonlineUpdateManyArgs>(args: SelectSubset<T, extratoonlineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Extratoonline.
     * @param {extratoonlineUpsertArgs} args - Arguments to update or create a Extratoonline.
     * @example
     * // Update or create a Extratoonline
     * const extratoonline = await prisma.extratoonline.upsert({
     *   create: {
     *     // ... data to create a Extratoonline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Extratoonline we want to update
     *   }
     * })
     */
    upsert<T extends extratoonlineUpsertArgs>(args: SelectSubset<T, extratoonlineUpsertArgs<ExtArgs>>): Prisma__extratoonlineClient<$Result.GetResult<Prisma.$extratoonlinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Extratoonlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extratoonlineCountArgs} args - Arguments to filter Extratoonlines to count.
     * @example
     * // Count the number of Extratoonlines
     * const count = await prisma.extratoonline.count({
     *   where: {
     *     // ... the filter for the Extratoonlines we want to count
     *   }
     * })
    **/
    count<T extends extratoonlineCountArgs>(
      args?: Subset<T, extratoonlineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExtratoonlineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Extratoonline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtratoonlineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExtratoonlineAggregateArgs>(args: Subset<T, ExtratoonlineAggregateArgs>): Prisma.PrismaPromise<GetExtratoonlineAggregateType<T>>

    /**
     * Group by Extratoonline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extratoonlineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends extratoonlineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: extratoonlineGroupByArgs['orderBy'] }
        : { orderBy?: extratoonlineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, extratoonlineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExtratoonlineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the extratoonline model
   */
  readonly fields: extratoonlineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for extratoonline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__extratoonlineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the extratoonline model
   */
  interface extratoonlineFieldRefs {
    readonly id: FieldRef<"extratoonline", 'Int'>
    readonly idConsulta: FieldRef<"extratoonline", 'Int'>
    readonly id_fornecedor: FieldRef<"extratoonline", 'Int'>
    readonly beneficio: FieldRef<"extratoonline", 'String'>
    readonly jsonResult: FieldRef<"extratoonline", 'Json'>
    readonly filePdf: FieldRef<"extratoonline", 'Bytes'>
    readonly createdAt: FieldRef<"extratoonline", 'DateTime'>
    readonly updatedAt: FieldRef<"extratoonline", 'DateTime'>
    readonly isCache: FieldRef<"extratoonline", 'Boolean'>
    readonly statusConsulta: FieldRef<"extratoonline", 'Int'>
    readonly idConsultaOffline: FieldRef<"extratoonline", 'Int'>
    readonly errorResult: FieldRef<"extratoonline", 'String'>
    readonly idUsuario: FieldRef<"extratoonline", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * extratoonline findUnique
   */
  export type extratoonlineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratoonline
     */
    select?: extratoonlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratoonline
     */
    omit?: extratoonlineOmit<ExtArgs> | null
    /**
     * Filter, which extratoonline to fetch.
     */
    where: extratoonlineWhereUniqueInput
  }

  /**
   * extratoonline findUniqueOrThrow
   */
  export type extratoonlineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratoonline
     */
    select?: extratoonlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratoonline
     */
    omit?: extratoonlineOmit<ExtArgs> | null
    /**
     * Filter, which extratoonline to fetch.
     */
    where: extratoonlineWhereUniqueInput
  }

  /**
   * extratoonline findFirst
   */
  export type extratoonlineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratoonline
     */
    select?: extratoonlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratoonline
     */
    omit?: extratoonlineOmit<ExtArgs> | null
    /**
     * Filter, which extratoonline to fetch.
     */
    where?: extratoonlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extratoonlines to fetch.
     */
    orderBy?: extratoonlineOrderByWithRelationInput | extratoonlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for extratoonlines.
     */
    cursor?: extratoonlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extratoonlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extratoonlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of extratoonlines.
     */
    distinct?: ExtratoonlineScalarFieldEnum | ExtratoonlineScalarFieldEnum[]
  }

  /**
   * extratoonline findFirstOrThrow
   */
  export type extratoonlineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratoonline
     */
    select?: extratoonlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratoonline
     */
    omit?: extratoonlineOmit<ExtArgs> | null
    /**
     * Filter, which extratoonline to fetch.
     */
    where?: extratoonlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extratoonlines to fetch.
     */
    orderBy?: extratoonlineOrderByWithRelationInput | extratoonlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for extratoonlines.
     */
    cursor?: extratoonlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extratoonlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extratoonlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of extratoonlines.
     */
    distinct?: ExtratoonlineScalarFieldEnum | ExtratoonlineScalarFieldEnum[]
  }

  /**
   * extratoonline findMany
   */
  export type extratoonlineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratoonline
     */
    select?: extratoonlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratoonline
     */
    omit?: extratoonlineOmit<ExtArgs> | null
    /**
     * Filter, which extratoonlines to fetch.
     */
    where?: extratoonlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extratoonlines to fetch.
     */
    orderBy?: extratoonlineOrderByWithRelationInput | extratoonlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing extratoonlines.
     */
    cursor?: extratoonlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extratoonlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extratoonlines.
     */
    skip?: number
    distinct?: ExtratoonlineScalarFieldEnum | ExtratoonlineScalarFieldEnum[]
  }

  /**
   * extratoonline create
   */
  export type extratoonlineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratoonline
     */
    select?: extratoonlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratoonline
     */
    omit?: extratoonlineOmit<ExtArgs> | null
    /**
     * The data needed to create a extratoonline.
     */
    data: XOR<extratoonlineCreateInput, extratoonlineUncheckedCreateInput>
  }

  /**
   * extratoonline createMany
   */
  export type extratoonlineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many extratoonlines.
     */
    data: extratoonlineCreateManyInput | extratoonlineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * extratoonline update
   */
  export type extratoonlineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratoonline
     */
    select?: extratoonlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratoonline
     */
    omit?: extratoonlineOmit<ExtArgs> | null
    /**
     * The data needed to update a extratoonline.
     */
    data: XOR<extratoonlineUpdateInput, extratoonlineUncheckedUpdateInput>
    /**
     * Choose, which extratoonline to update.
     */
    where: extratoonlineWhereUniqueInput
  }

  /**
   * extratoonline updateMany
   */
  export type extratoonlineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update extratoonlines.
     */
    data: XOR<extratoonlineUpdateManyMutationInput, extratoonlineUncheckedUpdateManyInput>
    /**
     * Filter which extratoonlines to update
     */
    where?: extratoonlineWhereInput
    /**
     * Limit how many extratoonlines to update.
     */
    limit?: number
  }

  /**
   * extratoonline upsert
   */
  export type extratoonlineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratoonline
     */
    select?: extratoonlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratoonline
     */
    omit?: extratoonlineOmit<ExtArgs> | null
    /**
     * The filter to search for the extratoonline to update in case it exists.
     */
    where: extratoonlineWhereUniqueInput
    /**
     * In case the extratoonline found by the `where` argument doesn't exist, create a new extratoonline with this data.
     */
    create: XOR<extratoonlineCreateInput, extratoonlineUncheckedCreateInput>
    /**
     * In case the extratoonline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<extratoonlineUpdateInput, extratoonlineUncheckedUpdateInput>
  }

  /**
   * extratoonline delete
   */
  export type extratoonlineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratoonline
     */
    select?: extratoonlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratoonline
     */
    omit?: extratoonlineOmit<ExtArgs> | null
    /**
     * Filter which extratoonline to delete.
     */
    where: extratoonlineWhereUniqueInput
  }

  /**
   * extratoonline deleteMany
   */
  export type extratoonlineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which extratoonlines to delete
     */
    where?: extratoonlineWhereInput
    /**
     * Limit how many extratoonlines to delete.
     */
    limit?: number
  }

  /**
   * extratoonline without action
   */
  export type extratoonlineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extratoonline
     */
    select?: extratoonlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extratoonline
     */
    omit?: extratoonlineOmit<ExtArgs> | null
  }


  /**
   * Model fornecedor
   */

  export type AggregateFornecedor = {
    _count: FornecedorCountAggregateOutputType | null
    _avg: FornecedorAvgAggregateOutputType | null
    _sum: FornecedorSumAggregateOutputType | null
    _min: FornecedorMinAggregateOutputType | null
    _max: FornecedorMaxAggregateOutputType | null
  }

  export type FornecedorAvgAggregateOutputType = {
    id: number | null
    numero: number | null
  }

  export type FornecedorSumAggregateOutputType = {
    id: number | null
    numero: number | null
  }

  export type FornecedorMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    cnpj: string | null
    logradouro: string | null
    numero: number | null
    complemento: string | null
    cep: string | null
    cidade: string | null
    estado: string | null
    apikey: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    urlapi: string | null
    usuarioApi: string | null
    senhaApi: string | null
    dataHoraValidacaoApiKey: Date | null
  }

  export type FornecedorMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    cnpj: string | null
    logradouro: string | null
    numero: number | null
    complemento: string | null
    cep: string | null
    cidade: string | null
    estado: string | null
    apikey: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    urlapi: string | null
    usuarioApi: string | null
    senhaApi: string | null
    dataHoraValidacaoApiKey: Date | null
  }

  export type FornecedorCountAggregateOutputType = {
    id: number
    descricao: number
    cnpj: number
    logradouro: number
    numero: number
    complemento: number
    cep: number
    cidade: number
    estado: number
    apikey: number
    ativo: number
    createdAt: number
    updatedAt: number
    urlapi: number
    usuarioApi: number
    senhaApi: number
    dataHoraValidacaoApiKey: number
    _all: number
  }


  export type FornecedorAvgAggregateInputType = {
    id?: true
    numero?: true
  }

  export type FornecedorSumAggregateInputType = {
    id?: true
    numero?: true
  }

  export type FornecedorMinAggregateInputType = {
    id?: true
    descricao?: true
    cnpj?: true
    logradouro?: true
    numero?: true
    complemento?: true
    cep?: true
    cidade?: true
    estado?: true
    apikey?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    urlapi?: true
    usuarioApi?: true
    senhaApi?: true
    dataHoraValidacaoApiKey?: true
  }

  export type FornecedorMaxAggregateInputType = {
    id?: true
    descricao?: true
    cnpj?: true
    logradouro?: true
    numero?: true
    complemento?: true
    cep?: true
    cidade?: true
    estado?: true
    apikey?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    urlapi?: true
    usuarioApi?: true
    senhaApi?: true
    dataHoraValidacaoApiKey?: true
  }

  export type FornecedorCountAggregateInputType = {
    id?: true
    descricao?: true
    cnpj?: true
    logradouro?: true
    numero?: true
    complemento?: true
    cep?: true
    cidade?: true
    estado?: true
    apikey?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    urlapi?: true
    usuarioApi?: true
    senhaApi?: true
    dataHoraValidacaoApiKey?: true
    _all?: true
  }

  export type FornecedorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fornecedor to aggregate.
     */
    where?: fornecedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fornecedors to fetch.
     */
    orderBy?: fornecedorOrderByWithRelationInput | fornecedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fornecedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fornecedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fornecedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fornecedors
    **/
    _count?: true | FornecedorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FornecedorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FornecedorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FornecedorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FornecedorMaxAggregateInputType
  }

  export type GetFornecedorAggregateType<T extends FornecedorAggregateArgs> = {
        [P in keyof T & keyof AggregateFornecedor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFornecedor[P]>
      : GetScalarType<T[P], AggregateFornecedor[P]>
  }




  export type fornecedorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fornecedorWhereInput
    orderBy?: fornecedorOrderByWithAggregationInput | fornecedorOrderByWithAggregationInput[]
    by: FornecedorScalarFieldEnum[] | FornecedorScalarFieldEnum
    having?: fornecedorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FornecedorCountAggregateInputType | true
    _avg?: FornecedorAvgAggregateInputType
    _sum?: FornecedorSumAggregateInputType
    _min?: FornecedorMinAggregateInputType
    _max?: FornecedorMaxAggregateInputType
  }

  export type FornecedorGroupByOutputType = {
    id: number
    descricao: string
    cnpj: string | null
    logradouro: string | null
    numero: number | null
    complemento: string | null
    cep: string | null
    cidade: string | null
    estado: string | null
    apikey: string | null
    ativo: boolean
    createdAt: Date
    updatedAt: Date
    urlapi: string | null
    usuarioApi: string | null
    senhaApi: string | null
    dataHoraValidacaoApiKey: Date | null
    _count: FornecedorCountAggregateOutputType | null
    _avg: FornecedorAvgAggregateOutputType | null
    _sum: FornecedorSumAggregateOutputType | null
    _min: FornecedorMinAggregateOutputType | null
    _max: FornecedorMaxAggregateOutputType | null
  }

  type GetFornecedorGroupByPayload<T extends fornecedorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FornecedorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FornecedorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FornecedorGroupByOutputType[P]>
            : GetScalarType<T[P], FornecedorGroupByOutputType[P]>
        }
      >
    >


  export type fornecedorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    cnpj?: boolean
    logradouro?: boolean
    numero?: boolean
    complemento?: boolean
    cep?: boolean
    cidade?: boolean
    estado?: boolean
    apikey?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    urlapi?: boolean
    usuarioApi?: boolean
    senhaApi?: boolean
    dataHoraValidacaoApiKey?: boolean
  }, ExtArgs["result"]["fornecedor"]>



  export type fornecedorSelectScalar = {
    id?: boolean
    descricao?: boolean
    cnpj?: boolean
    logradouro?: boolean
    numero?: boolean
    complemento?: boolean
    cep?: boolean
    cidade?: boolean
    estado?: boolean
    apikey?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    urlapi?: boolean
    usuarioApi?: boolean
    senhaApi?: boolean
    dataHoraValidacaoApiKey?: boolean
  }

  export type fornecedorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "cnpj" | "logradouro" | "numero" | "complemento" | "cep" | "cidade" | "estado" | "apikey" | "ativo" | "createdAt" | "updatedAt" | "urlapi" | "usuarioApi" | "senhaApi" | "dataHoraValidacaoApiKey", ExtArgs["result"]["fornecedor"]>

  export type $fornecedorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fornecedor"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      cnpj: string | null
      logradouro: string | null
      numero: number | null
      complemento: string | null
      cep: string | null
      cidade: string | null
      estado: string | null
      apikey: string | null
      ativo: boolean
      createdAt: Date
      updatedAt: Date
      urlapi: string | null
      usuarioApi: string | null
      senhaApi: string | null
      dataHoraValidacaoApiKey: Date | null
    }, ExtArgs["result"]["fornecedor"]>
    composites: {}
  }

  type fornecedorGetPayload<S extends boolean | null | undefined | fornecedorDefaultArgs> = $Result.GetResult<Prisma.$fornecedorPayload, S>

  type fornecedorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<fornecedorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FornecedorCountAggregateInputType | true
    }

  export interface fornecedorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fornecedor'], meta: { name: 'fornecedor' } }
    /**
     * Find zero or one Fornecedor that matches the filter.
     * @param {fornecedorFindUniqueArgs} args - Arguments to find a Fornecedor
     * @example
     * // Get one Fornecedor
     * const fornecedor = await prisma.fornecedor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends fornecedorFindUniqueArgs>(args: SelectSubset<T, fornecedorFindUniqueArgs<ExtArgs>>): Prisma__fornecedorClient<$Result.GetResult<Prisma.$fornecedorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fornecedor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {fornecedorFindUniqueOrThrowArgs} args - Arguments to find a Fornecedor
     * @example
     * // Get one Fornecedor
     * const fornecedor = await prisma.fornecedor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends fornecedorFindUniqueOrThrowArgs>(args: SelectSubset<T, fornecedorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__fornecedorClient<$Result.GetResult<Prisma.$fornecedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fornecedor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fornecedorFindFirstArgs} args - Arguments to find a Fornecedor
     * @example
     * // Get one Fornecedor
     * const fornecedor = await prisma.fornecedor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends fornecedorFindFirstArgs>(args?: SelectSubset<T, fornecedorFindFirstArgs<ExtArgs>>): Prisma__fornecedorClient<$Result.GetResult<Prisma.$fornecedorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fornecedor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fornecedorFindFirstOrThrowArgs} args - Arguments to find a Fornecedor
     * @example
     * // Get one Fornecedor
     * const fornecedor = await prisma.fornecedor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends fornecedorFindFirstOrThrowArgs>(args?: SelectSubset<T, fornecedorFindFirstOrThrowArgs<ExtArgs>>): Prisma__fornecedorClient<$Result.GetResult<Prisma.$fornecedorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fornecedors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fornecedorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fornecedors
     * const fornecedors = await prisma.fornecedor.findMany()
     * 
     * // Get first 10 Fornecedors
     * const fornecedors = await prisma.fornecedor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fornecedorWithIdOnly = await prisma.fornecedor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends fornecedorFindManyArgs>(args?: SelectSubset<T, fornecedorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fornecedorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fornecedor.
     * @param {fornecedorCreateArgs} args - Arguments to create a Fornecedor.
     * @example
     * // Create one Fornecedor
     * const Fornecedor = await prisma.fornecedor.create({
     *   data: {
     *     // ... data to create a Fornecedor
     *   }
     * })
     * 
     */
    create<T extends fornecedorCreateArgs>(args: SelectSubset<T, fornecedorCreateArgs<ExtArgs>>): Prisma__fornecedorClient<$Result.GetResult<Prisma.$fornecedorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fornecedors.
     * @param {fornecedorCreateManyArgs} args - Arguments to create many Fornecedors.
     * @example
     * // Create many Fornecedors
     * const fornecedor = await prisma.fornecedor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends fornecedorCreateManyArgs>(args?: SelectSubset<T, fornecedorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fornecedor.
     * @param {fornecedorDeleteArgs} args - Arguments to delete one Fornecedor.
     * @example
     * // Delete one Fornecedor
     * const Fornecedor = await prisma.fornecedor.delete({
     *   where: {
     *     // ... filter to delete one Fornecedor
     *   }
     * })
     * 
     */
    delete<T extends fornecedorDeleteArgs>(args: SelectSubset<T, fornecedorDeleteArgs<ExtArgs>>): Prisma__fornecedorClient<$Result.GetResult<Prisma.$fornecedorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fornecedor.
     * @param {fornecedorUpdateArgs} args - Arguments to update one Fornecedor.
     * @example
     * // Update one Fornecedor
     * const fornecedor = await prisma.fornecedor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends fornecedorUpdateArgs>(args: SelectSubset<T, fornecedorUpdateArgs<ExtArgs>>): Prisma__fornecedorClient<$Result.GetResult<Prisma.$fornecedorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fornecedors.
     * @param {fornecedorDeleteManyArgs} args - Arguments to filter Fornecedors to delete.
     * @example
     * // Delete a few Fornecedors
     * const { count } = await prisma.fornecedor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends fornecedorDeleteManyArgs>(args?: SelectSubset<T, fornecedorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fornecedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fornecedorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fornecedors
     * const fornecedor = await prisma.fornecedor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends fornecedorUpdateManyArgs>(args: SelectSubset<T, fornecedorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fornecedor.
     * @param {fornecedorUpsertArgs} args - Arguments to update or create a Fornecedor.
     * @example
     * // Update or create a Fornecedor
     * const fornecedor = await prisma.fornecedor.upsert({
     *   create: {
     *     // ... data to create a Fornecedor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fornecedor we want to update
     *   }
     * })
     */
    upsert<T extends fornecedorUpsertArgs>(args: SelectSubset<T, fornecedorUpsertArgs<ExtArgs>>): Prisma__fornecedorClient<$Result.GetResult<Prisma.$fornecedorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fornecedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fornecedorCountArgs} args - Arguments to filter Fornecedors to count.
     * @example
     * // Count the number of Fornecedors
     * const count = await prisma.fornecedor.count({
     *   where: {
     *     // ... the filter for the Fornecedors we want to count
     *   }
     * })
    **/
    count<T extends fornecedorCountArgs>(
      args?: Subset<T, fornecedorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FornecedorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fornecedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FornecedorAggregateArgs>(args: Subset<T, FornecedorAggregateArgs>): Prisma.PrismaPromise<GetFornecedorAggregateType<T>>

    /**
     * Group by Fornecedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fornecedorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fornecedorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fornecedorGroupByArgs['orderBy'] }
        : { orderBy?: fornecedorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fornecedorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFornecedorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fornecedor model
   */
  readonly fields: fornecedorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fornecedor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fornecedorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the fornecedor model
   */
  interface fornecedorFieldRefs {
    readonly id: FieldRef<"fornecedor", 'Int'>
    readonly descricao: FieldRef<"fornecedor", 'String'>
    readonly cnpj: FieldRef<"fornecedor", 'String'>
    readonly logradouro: FieldRef<"fornecedor", 'String'>
    readonly numero: FieldRef<"fornecedor", 'Int'>
    readonly complemento: FieldRef<"fornecedor", 'String'>
    readonly cep: FieldRef<"fornecedor", 'String'>
    readonly cidade: FieldRef<"fornecedor", 'String'>
    readonly estado: FieldRef<"fornecedor", 'String'>
    readonly apikey: FieldRef<"fornecedor", 'String'>
    readonly ativo: FieldRef<"fornecedor", 'Boolean'>
    readonly createdAt: FieldRef<"fornecedor", 'DateTime'>
    readonly updatedAt: FieldRef<"fornecedor", 'DateTime'>
    readonly urlapi: FieldRef<"fornecedor", 'String'>
    readonly usuarioApi: FieldRef<"fornecedor", 'String'>
    readonly senhaApi: FieldRef<"fornecedor", 'String'>
    readonly dataHoraValidacaoApiKey: FieldRef<"fornecedor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * fornecedor findUnique
   */
  export type fornecedorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedor
     */
    select?: fornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedor
     */
    omit?: fornecedorOmit<ExtArgs> | null
    /**
     * Filter, which fornecedor to fetch.
     */
    where: fornecedorWhereUniqueInput
  }

  /**
   * fornecedor findUniqueOrThrow
   */
  export type fornecedorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedor
     */
    select?: fornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedor
     */
    omit?: fornecedorOmit<ExtArgs> | null
    /**
     * Filter, which fornecedor to fetch.
     */
    where: fornecedorWhereUniqueInput
  }

  /**
   * fornecedor findFirst
   */
  export type fornecedorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedor
     */
    select?: fornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedor
     */
    omit?: fornecedorOmit<ExtArgs> | null
    /**
     * Filter, which fornecedor to fetch.
     */
    where?: fornecedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fornecedors to fetch.
     */
    orderBy?: fornecedorOrderByWithRelationInput | fornecedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fornecedors.
     */
    cursor?: fornecedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fornecedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fornecedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fornecedors.
     */
    distinct?: FornecedorScalarFieldEnum | FornecedorScalarFieldEnum[]
  }

  /**
   * fornecedor findFirstOrThrow
   */
  export type fornecedorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedor
     */
    select?: fornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedor
     */
    omit?: fornecedorOmit<ExtArgs> | null
    /**
     * Filter, which fornecedor to fetch.
     */
    where?: fornecedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fornecedors to fetch.
     */
    orderBy?: fornecedorOrderByWithRelationInput | fornecedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fornecedors.
     */
    cursor?: fornecedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fornecedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fornecedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fornecedors.
     */
    distinct?: FornecedorScalarFieldEnum | FornecedorScalarFieldEnum[]
  }

  /**
   * fornecedor findMany
   */
  export type fornecedorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedor
     */
    select?: fornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedor
     */
    omit?: fornecedorOmit<ExtArgs> | null
    /**
     * Filter, which fornecedors to fetch.
     */
    where?: fornecedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fornecedors to fetch.
     */
    orderBy?: fornecedorOrderByWithRelationInput | fornecedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fornecedors.
     */
    cursor?: fornecedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fornecedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fornecedors.
     */
    skip?: number
    distinct?: FornecedorScalarFieldEnum | FornecedorScalarFieldEnum[]
  }

  /**
   * fornecedor create
   */
  export type fornecedorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedor
     */
    select?: fornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedor
     */
    omit?: fornecedorOmit<ExtArgs> | null
    /**
     * The data needed to create a fornecedor.
     */
    data: XOR<fornecedorCreateInput, fornecedorUncheckedCreateInput>
  }

  /**
   * fornecedor createMany
   */
  export type fornecedorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fornecedors.
     */
    data: fornecedorCreateManyInput | fornecedorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * fornecedor update
   */
  export type fornecedorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedor
     */
    select?: fornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedor
     */
    omit?: fornecedorOmit<ExtArgs> | null
    /**
     * The data needed to update a fornecedor.
     */
    data: XOR<fornecedorUpdateInput, fornecedorUncheckedUpdateInput>
    /**
     * Choose, which fornecedor to update.
     */
    where: fornecedorWhereUniqueInput
  }

  /**
   * fornecedor updateMany
   */
  export type fornecedorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fornecedors.
     */
    data: XOR<fornecedorUpdateManyMutationInput, fornecedorUncheckedUpdateManyInput>
    /**
     * Filter which fornecedors to update
     */
    where?: fornecedorWhereInput
    /**
     * Limit how many fornecedors to update.
     */
    limit?: number
  }

  /**
   * fornecedor upsert
   */
  export type fornecedorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedor
     */
    select?: fornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedor
     */
    omit?: fornecedorOmit<ExtArgs> | null
    /**
     * The filter to search for the fornecedor to update in case it exists.
     */
    where: fornecedorWhereUniqueInput
    /**
     * In case the fornecedor found by the `where` argument doesn't exist, create a new fornecedor with this data.
     */
    create: XOR<fornecedorCreateInput, fornecedorUncheckedCreateInput>
    /**
     * In case the fornecedor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fornecedorUpdateInput, fornecedorUncheckedUpdateInput>
  }

  /**
   * fornecedor delete
   */
  export type fornecedorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedor
     */
    select?: fornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedor
     */
    omit?: fornecedorOmit<ExtArgs> | null
    /**
     * Filter which fornecedor to delete.
     */
    where: fornecedorWhereUniqueInput
  }

  /**
   * fornecedor deleteMany
   */
  export type fornecedorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fornecedors to delete
     */
    where?: fornecedorWhereInput
    /**
     * Limit how many fornecedors to delete.
     */
    limit?: number
  }

  /**
   * fornecedor without action
   */
  export type fornecedorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedor
     */
    select?: fornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedor
     */
    omit?: fornecedorOmit<ExtArgs> | null
  }


  /**
   * Model fornecedorservico
   */

  export type AggregateFornecedorservico = {
    _count: FornecedorservicoCountAggregateOutputType | null
    _avg: FornecedorservicoAvgAggregateOutputType | null
    _sum: FornecedorservicoSumAggregateOutputType | null
    _min: FornecedorservicoMinAggregateOutputType | null
    _max: FornecedorservicoMaxAggregateOutputType | null
  }

  export type FornecedorservicoAvgAggregateOutputType = {
    id: number | null
    idServico: number | null
    idFornecedor: number | null
  }

  export type FornecedorservicoSumAggregateOutputType = {
    id: number | null
    idServico: number | null
    idFornecedor: number | null
  }

  export type FornecedorservicoMinAggregateOutputType = {
    id: number | null
    idServico: number | null
    idFornecedor: number | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FornecedorservicoMaxAggregateOutputType = {
    id: number | null
    idServico: number | null
    idFornecedor: number | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FornecedorservicoCountAggregateOutputType = {
    id: number
    idServico: number
    idFornecedor: number
    ativo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FornecedorservicoAvgAggregateInputType = {
    id?: true
    idServico?: true
    idFornecedor?: true
  }

  export type FornecedorservicoSumAggregateInputType = {
    id?: true
    idServico?: true
    idFornecedor?: true
  }

  export type FornecedorservicoMinAggregateInputType = {
    id?: true
    idServico?: true
    idFornecedor?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FornecedorservicoMaxAggregateInputType = {
    id?: true
    idServico?: true
    idFornecedor?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FornecedorservicoCountAggregateInputType = {
    id?: true
    idServico?: true
    idFornecedor?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FornecedorservicoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fornecedorservico to aggregate.
     */
    where?: fornecedorservicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fornecedorservicos to fetch.
     */
    orderBy?: fornecedorservicoOrderByWithRelationInput | fornecedorservicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fornecedorservicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fornecedorservicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fornecedorservicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fornecedorservicos
    **/
    _count?: true | FornecedorservicoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FornecedorservicoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FornecedorservicoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FornecedorservicoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FornecedorservicoMaxAggregateInputType
  }

  export type GetFornecedorservicoAggregateType<T extends FornecedorservicoAggregateArgs> = {
        [P in keyof T & keyof AggregateFornecedorservico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFornecedorservico[P]>
      : GetScalarType<T[P], AggregateFornecedorservico[P]>
  }




  export type fornecedorservicoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fornecedorservicoWhereInput
    orderBy?: fornecedorservicoOrderByWithAggregationInput | fornecedorservicoOrderByWithAggregationInput[]
    by: FornecedorservicoScalarFieldEnum[] | FornecedorservicoScalarFieldEnum
    having?: fornecedorservicoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FornecedorservicoCountAggregateInputType | true
    _avg?: FornecedorservicoAvgAggregateInputType
    _sum?: FornecedorservicoSumAggregateInputType
    _min?: FornecedorservicoMinAggregateInputType
    _max?: FornecedorservicoMaxAggregateInputType
  }

  export type FornecedorservicoGroupByOutputType = {
    id: number
    idServico: number
    idFornecedor: number
    ativo: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: FornecedorservicoCountAggregateOutputType | null
    _avg: FornecedorservicoAvgAggregateOutputType | null
    _sum: FornecedorservicoSumAggregateOutputType | null
    _min: FornecedorservicoMinAggregateOutputType | null
    _max: FornecedorservicoMaxAggregateOutputType | null
  }

  type GetFornecedorservicoGroupByPayload<T extends fornecedorservicoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FornecedorservicoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FornecedorservicoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FornecedorservicoGroupByOutputType[P]>
            : GetScalarType<T[P], FornecedorservicoGroupByOutputType[P]>
        }
      >
    >


  export type fornecedorservicoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idServico?: boolean
    idFornecedor?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fornecedorservico"]>



  export type fornecedorservicoSelectScalar = {
    id?: boolean
    idServico?: boolean
    idFornecedor?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type fornecedorservicoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idServico" | "idFornecedor" | "ativo" | "createdAt" | "updatedAt", ExtArgs["result"]["fornecedorservico"]>

  export type $fornecedorservicoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fornecedorservico"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idServico: number
      idFornecedor: number
      ativo: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fornecedorservico"]>
    composites: {}
  }

  type fornecedorservicoGetPayload<S extends boolean | null | undefined | fornecedorservicoDefaultArgs> = $Result.GetResult<Prisma.$fornecedorservicoPayload, S>

  type fornecedorservicoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<fornecedorservicoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FornecedorservicoCountAggregateInputType | true
    }

  export interface fornecedorservicoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fornecedorservico'], meta: { name: 'fornecedorservico' } }
    /**
     * Find zero or one Fornecedorservico that matches the filter.
     * @param {fornecedorservicoFindUniqueArgs} args - Arguments to find a Fornecedorservico
     * @example
     * // Get one Fornecedorservico
     * const fornecedorservico = await prisma.fornecedorservico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends fornecedorservicoFindUniqueArgs>(args: SelectSubset<T, fornecedorservicoFindUniqueArgs<ExtArgs>>): Prisma__fornecedorservicoClient<$Result.GetResult<Prisma.$fornecedorservicoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fornecedorservico that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {fornecedorservicoFindUniqueOrThrowArgs} args - Arguments to find a Fornecedorservico
     * @example
     * // Get one Fornecedorservico
     * const fornecedorservico = await prisma.fornecedorservico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends fornecedorservicoFindUniqueOrThrowArgs>(args: SelectSubset<T, fornecedorservicoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__fornecedorservicoClient<$Result.GetResult<Prisma.$fornecedorservicoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fornecedorservico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fornecedorservicoFindFirstArgs} args - Arguments to find a Fornecedorservico
     * @example
     * // Get one Fornecedorservico
     * const fornecedorservico = await prisma.fornecedorservico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends fornecedorservicoFindFirstArgs>(args?: SelectSubset<T, fornecedorservicoFindFirstArgs<ExtArgs>>): Prisma__fornecedorservicoClient<$Result.GetResult<Prisma.$fornecedorservicoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fornecedorservico that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fornecedorservicoFindFirstOrThrowArgs} args - Arguments to find a Fornecedorservico
     * @example
     * // Get one Fornecedorservico
     * const fornecedorservico = await prisma.fornecedorservico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends fornecedorservicoFindFirstOrThrowArgs>(args?: SelectSubset<T, fornecedorservicoFindFirstOrThrowArgs<ExtArgs>>): Prisma__fornecedorservicoClient<$Result.GetResult<Prisma.$fornecedorservicoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fornecedorservicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fornecedorservicoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fornecedorservicos
     * const fornecedorservicos = await prisma.fornecedorservico.findMany()
     * 
     * // Get first 10 Fornecedorservicos
     * const fornecedorservicos = await prisma.fornecedorservico.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fornecedorservicoWithIdOnly = await prisma.fornecedorservico.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends fornecedorservicoFindManyArgs>(args?: SelectSubset<T, fornecedorservicoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fornecedorservicoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fornecedorservico.
     * @param {fornecedorservicoCreateArgs} args - Arguments to create a Fornecedorservico.
     * @example
     * // Create one Fornecedorservico
     * const Fornecedorservico = await prisma.fornecedorservico.create({
     *   data: {
     *     // ... data to create a Fornecedorservico
     *   }
     * })
     * 
     */
    create<T extends fornecedorservicoCreateArgs>(args: SelectSubset<T, fornecedorservicoCreateArgs<ExtArgs>>): Prisma__fornecedorservicoClient<$Result.GetResult<Prisma.$fornecedorservicoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fornecedorservicos.
     * @param {fornecedorservicoCreateManyArgs} args - Arguments to create many Fornecedorservicos.
     * @example
     * // Create many Fornecedorservicos
     * const fornecedorservico = await prisma.fornecedorservico.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends fornecedorservicoCreateManyArgs>(args?: SelectSubset<T, fornecedorservicoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fornecedorservico.
     * @param {fornecedorservicoDeleteArgs} args - Arguments to delete one Fornecedorservico.
     * @example
     * // Delete one Fornecedorservico
     * const Fornecedorservico = await prisma.fornecedorservico.delete({
     *   where: {
     *     // ... filter to delete one Fornecedorservico
     *   }
     * })
     * 
     */
    delete<T extends fornecedorservicoDeleteArgs>(args: SelectSubset<T, fornecedorservicoDeleteArgs<ExtArgs>>): Prisma__fornecedorservicoClient<$Result.GetResult<Prisma.$fornecedorservicoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fornecedorservico.
     * @param {fornecedorservicoUpdateArgs} args - Arguments to update one Fornecedorservico.
     * @example
     * // Update one Fornecedorservico
     * const fornecedorservico = await prisma.fornecedorservico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends fornecedorservicoUpdateArgs>(args: SelectSubset<T, fornecedorservicoUpdateArgs<ExtArgs>>): Prisma__fornecedorservicoClient<$Result.GetResult<Prisma.$fornecedorservicoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fornecedorservicos.
     * @param {fornecedorservicoDeleteManyArgs} args - Arguments to filter Fornecedorservicos to delete.
     * @example
     * // Delete a few Fornecedorservicos
     * const { count } = await prisma.fornecedorservico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends fornecedorservicoDeleteManyArgs>(args?: SelectSubset<T, fornecedorservicoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fornecedorservicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fornecedorservicoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fornecedorservicos
     * const fornecedorservico = await prisma.fornecedorservico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends fornecedorservicoUpdateManyArgs>(args: SelectSubset<T, fornecedorservicoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fornecedorservico.
     * @param {fornecedorservicoUpsertArgs} args - Arguments to update or create a Fornecedorservico.
     * @example
     * // Update or create a Fornecedorservico
     * const fornecedorservico = await prisma.fornecedorservico.upsert({
     *   create: {
     *     // ... data to create a Fornecedorservico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fornecedorservico we want to update
     *   }
     * })
     */
    upsert<T extends fornecedorservicoUpsertArgs>(args: SelectSubset<T, fornecedorservicoUpsertArgs<ExtArgs>>): Prisma__fornecedorservicoClient<$Result.GetResult<Prisma.$fornecedorservicoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fornecedorservicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fornecedorservicoCountArgs} args - Arguments to filter Fornecedorservicos to count.
     * @example
     * // Count the number of Fornecedorservicos
     * const count = await prisma.fornecedorservico.count({
     *   where: {
     *     // ... the filter for the Fornecedorservicos we want to count
     *   }
     * })
    **/
    count<T extends fornecedorservicoCountArgs>(
      args?: Subset<T, fornecedorservicoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FornecedorservicoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fornecedorservico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorservicoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FornecedorservicoAggregateArgs>(args: Subset<T, FornecedorservicoAggregateArgs>): Prisma.PrismaPromise<GetFornecedorservicoAggregateType<T>>

    /**
     * Group by Fornecedorservico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fornecedorservicoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fornecedorservicoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fornecedorservicoGroupByArgs['orderBy'] }
        : { orderBy?: fornecedorservicoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fornecedorservicoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFornecedorservicoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fornecedorservico model
   */
  readonly fields: fornecedorservicoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fornecedorservico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fornecedorservicoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the fornecedorservico model
   */
  interface fornecedorservicoFieldRefs {
    readonly id: FieldRef<"fornecedorservico", 'Int'>
    readonly idServico: FieldRef<"fornecedorservico", 'Int'>
    readonly idFornecedor: FieldRef<"fornecedorservico", 'Int'>
    readonly ativo: FieldRef<"fornecedorservico", 'Boolean'>
    readonly createdAt: FieldRef<"fornecedorservico", 'DateTime'>
    readonly updatedAt: FieldRef<"fornecedorservico", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * fornecedorservico findUnique
   */
  export type fornecedorservicoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedorservico
     */
    select?: fornecedorservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedorservico
     */
    omit?: fornecedorservicoOmit<ExtArgs> | null
    /**
     * Filter, which fornecedorservico to fetch.
     */
    where: fornecedorservicoWhereUniqueInput
  }

  /**
   * fornecedorservico findUniqueOrThrow
   */
  export type fornecedorservicoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedorservico
     */
    select?: fornecedorservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedorservico
     */
    omit?: fornecedorservicoOmit<ExtArgs> | null
    /**
     * Filter, which fornecedorservico to fetch.
     */
    where: fornecedorservicoWhereUniqueInput
  }

  /**
   * fornecedorservico findFirst
   */
  export type fornecedorservicoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedorservico
     */
    select?: fornecedorservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedorservico
     */
    omit?: fornecedorservicoOmit<ExtArgs> | null
    /**
     * Filter, which fornecedorservico to fetch.
     */
    where?: fornecedorservicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fornecedorservicos to fetch.
     */
    orderBy?: fornecedorservicoOrderByWithRelationInput | fornecedorservicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fornecedorservicos.
     */
    cursor?: fornecedorservicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fornecedorservicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fornecedorservicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fornecedorservicos.
     */
    distinct?: FornecedorservicoScalarFieldEnum | FornecedorservicoScalarFieldEnum[]
  }

  /**
   * fornecedorservico findFirstOrThrow
   */
  export type fornecedorservicoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedorservico
     */
    select?: fornecedorservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedorservico
     */
    omit?: fornecedorservicoOmit<ExtArgs> | null
    /**
     * Filter, which fornecedorservico to fetch.
     */
    where?: fornecedorservicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fornecedorservicos to fetch.
     */
    orderBy?: fornecedorservicoOrderByWithRelationInput | fornecedorservicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fornecedorservicos.
     */
    cursor?: fornecedorservicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fornecedorservicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fornecedorservicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fornecedorservicos.
     */
    distinct?: FornecedorservicoScalarFieldEnum | FornecedorservicoScalarFieldEnum[]
  }

  /**
   * fornecedorservico findMany
   */
  export type fornecedorservicoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedorservico
     */
    select?: fornecedorservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedorservico
     */
    omit?: fornecedorservicoOmit<ExtArgs> | null
    /**
     * Filter, which fornecedorservicos to fetch.
     */
    where?: fornecedorservicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fornecedorservicos to fetch.
     */
    orderBy?: fornecedorservicoOrderByWithRelationInput | fornecedorservicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fornecedorservicos.
     */
    cursor?: fornecedorservicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fornecedorservicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fornecedorservicos.
     */
    skip?: number
    distinct?: FornecedorservicoScalarFieldEnum | FornecedorservicoScalarFieldEnum[]
  }

  /**
   * fornecedorservico create
   */
  export type fornecedorservicoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedorservico
     */
    select?: fornecedorservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedorservico
     */
    omit?: fornecedorservicoOmit<ExtArgs> | null
    /**
     * The data needed to create a fornecedorservico.
     */
    data: XOR<fornecedorservicoCreateInput, fornecedorservicoUncheckedCreateInput>
  }

  /**
   * fornecedorservico createMany
   */
  export type fornecedorservicoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fornecedorservicos.
     */
    data: fornecedorservicoCreateManyInput | fornecedorservicoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * fornecedorservico update
   */
  export type fornecedorservicoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedorservico
     */
    select?: fornecedorservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedorservico
     */
    omit?: fornecedorservicoOmit<ExtArgs> | null
    /**
     * The data needed to update a fornecedorservico.
     */
    data: XOR<fornecedorservicoUpdateInput, fornecedorservicoUncheckedUpdateInput>
    /**
     * Choose, which fornecedorservico to update.
     */
    where: fornecedorservicoWhereUniqueInput
  }

  /**
   * fornecedorservico updateMany
   */
  export type fornecedorservicoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fornecedorservicos.
     */
    data: XOR<fornecedorservicoUpdateManyMutationInput, fornecedorservicoUncheckedUpdateManyInput>
    /**
     * Filter which fornecedorservicos to update
     */
    where?: fornecedorservicoWhereInput
    /**
     * Limit how many fornecedorservicos to update.
     */
    limit?: number
  }

  /**
   * fornecedorservico upsert
   */
  export type fornecedorservicoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedorservico
     */
    select?: fornecedorservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedorservico
     */
    omit?: fornecedorservicoOmit<ExtArgs> | null
    /**
     * The filter to search for the fornecedorservico to update in case it exists.
     */
    where: fornecedorservicoWhereUniqueInput
    /**
     * In case the fornecedorservico found by the `where` argument doesn't exist, create a new fornecedorservico with this data.
     */
    create: XOR<fornecedorservicoCreateInput, fornecedorservicoUncheckedCreateInput>
    /**
     * In case the fornecedorservico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fornecedorservicoUpdateInput, fornecedorservicoUncheckedUpdateInput>
  }

  /**
   * fornecedorservico delete
   */
  export type fornecedorservicoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedorservico
     */
    select?: fornecedorservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedorservico
     */
    omit?: fornecedorservicoOmit<ExtArgs> | null
    /**
     * Filter which fornecedorservico to delete.
     */
    where: fornecedorservicoWhereUniqueInput
  }

  /**
   * fornecedorservico deleteMany
   */
  export type fornecedorservicoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fornecedorservicos to delete
     */
    where?: fornecedorservicoWhereInput
    /**
     * Limit how many fornecedorservicos to delete.
     */
    limit?: number
  }

  /**
   * fornecedorservico without action
   */
  export type fornecedorservicoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fornecedorservico
     */
    select?: fornecedorservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fornecedorservico
     */
    omit?: fornecedorservicoOmit<ExtArgs> | null
  }


  /**
   * Model historicoconsultaapi
   */

  export type AggregateHistoricoconsultaapi = {
    _count: HistoricoconsultaapiCountAggregateOutputType | null
    _avg: HistoricoconsultaapiAvgAggregateOutputType | null
    _sum: HistoricoconsultaapiSumAggregateOutputType | null
    _min: HistoricoconsultaapiMinAggregateOutputType | null
    _max: HistoricoconsultaapiMaxAggregateOutputType | null
  }

  export type HistoricoconsultaapiAvgAggregateOutputType = {
    id: number | null
    idservico: number | null
    idfornecedor: number | null
    statusConsulta: number | null
  }

  export type HistoricoconsultaapiSumAggregateOutputType = {
    id: number | null
    idservico: number | null
    idfornecedor: number | null
    statusConsulta: number | null
  }

  export type HistoricoconsultaapiMinAggregateOutputType = {
    id: number | null
    idservico: number | null
    idfornecedor: number | null
    cpf: string | null
    cpfRepresentanteLegal: string | null
    beneficio: string | null
    statusConsulta: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HistoricoconsultaapiMaxAggregateOutputType = {
    id: number | null
    idservico: number | null
    idfornecedor: number | null
    cpf: string | null
    cpfRepresentanteLegal: string | null
    beneficio: string | null
    statusConsulta: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HistoricoconsultaapiCountAggregateOutputType = {
    id: number
    idservico: number
    idfornecedor: number
    cpf: number
    cpfRepresentanteLegal: number
    beneficio: number
    resultado: number
    statusConsulta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HistoricoconsultaapiAvgAggregateInputType = {
    id?: true
    idservico?: true
    idfornecedor?: true
    statusConsulta?: true
  }

  export type HistoricoconsultaapiSumAggregateInputType = {
    id?: true
    idservico?: true
    idfornecedor?: true
    statusConsulta?: true
  }

  export type HistoricoconsultaapiMinAggregateInputType = {
    id?: true
    idservico?: true
    idfornecedor?: true
    cpf?: true
    cpfRepresentanteLegal?: true
    beneficio?: true
    statusConsulta?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HistoricoconsultaapiMaxAggregateInputType = {
    id?: true
    idservico?: true
    idfornecedor?: true
    cpf?: true
    cpfRepresentanteLegal?: true
    beneficio?: true
    statusConsulta?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HistoricoconsultaapiCountAggregateInputType = {
    id?: true
    idservico?: true
    idfornecedor?: true
    cpf?: true
    cpfRepresentanteLegal?: true
    beneficio?: true
    resultado?: true
    statusConsulta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HistoricoconsultaapiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which historicoconsultaapi to aggregate.
     */
    where?: historicoconsultaapiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicoconsultaapis to fetch.
     */
    orderBy?: historicoconsultaapiOrderByWithRelationInput | historicoconsultaapiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historicoconsultaapiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicoconsultaapis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicoconsultaapis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historicoconsultaapis
    **/
    _count?: true | HistoricoconsultaapiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistoricoconsultaapiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistoricoconsultaapiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoricoconsultaapiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoricoconsultaapiMaxAggregateInputType
  }

  export type GetHistoricoconsultaapiAggregateType<T extends HistoricoconsultaapiAggregateArgs> = {
        [P in keyof T & keyof AggregateHistoricoconsultaapi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistoricoconsultaapi[P]>
      : GetScalarType<T[P], AggregateHistoricoconsultaapi[P]>
  }




  export type historicoconsultaapiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historicoconsultaapiWhereInput
    orderBy?: historicoconsultaapiOrderByWithAggregationInput | historicoconsultaapiOrderByWithAggregationInput[]
    by: HistoricoconsultaapiScalarFieldEnum[] | HistoricoconsultaapiScalarFieldEnum
    having?: historicoconsultaapiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoricoconsultaapiCountAggregateInputType | true
    _avg?: HistoricoconsultaapiAvgAggregateInputType
    _sum?: HistoricoconsultaapiSumAggregateInputType
    _min?: HistoricoconsultaapiMinAggregateInputType
    _max?: HistoricoconsultaapiMaxAggregateInputType
  }

  export type HistoricoconsultaapiGroupByOutputType = {
    id: number
    idservico: number
    idfornecedor: number
    cpf: string | null
    cpfRepresentanteLegal: string | null
    beneficio: string | null
    resultado: JsonValue | null
    statusConsulta: number | null
    createdAt: Date
    updatedAt: Date | null
    _count: HistoricoconsultaapiCountAggregateOutputType | null
    _avg: HistoricoconsultaapiAvgAggregateOutputType | null
    _sum: HistoricoconsultaapiSumAggregateOutputType | null
    _min: HistoricoconsultaapiMinAggregateOutputType | null
    _max: HistoricoconsultaapiMaxAggregateOutputType | null
  }

  type GetHistoricoconsultaapiGroupByPayload<T extends historicoconsultaapiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistoricoconsultaapiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoricoconsultaapiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoricoconsultaapiGroupByOutputType[P]>
            : GetScalarType<T[P], HistoricoconsultaapiGroupByOutputType[P]>
        }
      >
    >


  export type historicoconsultaapiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idservico?: boolean
    idfornecedor?: boolean
    cpf?: boolean
    cpfRepresentanteLegal?: boolean
    beneficio?: boolean
    resultado?: boolean
    statusConsulta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["historicoconsultaapi"]>



  export type historicoconsultaapiSelectScalar = {
    id?: boolean
    idservico?: boolean
    idfornecedor?: boolean
    cpf?: boolean
    cpfRepresentanteLegal?: boolean
    beneficio?: boolean
    resultado?: boolean
    statusConsulta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type historicoconsultaapiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idservico" | "idfornecedor" | "cpf" | "cpfRepresentanteLegal" | "beneficio" | "resultado" | "statusConsulta" | "createdAt" | "updatedAt", ExtArgs["result"]["historicoconsultaapi"]>

  export type $historicoconsultaapiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "historicoconsultaapi"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idservico: number
      idfornecedor: number
      cpf: string | null
      cpfRepresentanteLegal: string | null
      beneficio: string | null
      resultado: Prisma.JsonValue | null
      statusConsulta: number | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["historicoconsultaapi"]>
    composites: {}
  }

  type historicoconsultaapiGetPayload<S extends boolean | null | undefined | historicoconsultaapiDefaultArgs> = $Result.GetResult<Prisma.$historicoconsultaapiPayload, S>

  type historicoconsultaapiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<historicoconsultaapiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HistoricoconsultaapiCountAggregateInputType | true
    }

  export interface historicoconsultaapiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['historicoconsultaapi'], meta: { name: 'historicoconsultaapi' } }
    /**
     * Find zero or one Historicoconsultaapi that matches the filter.
     * @param {historicoconsultaapiFindUniqueArgs} args - Arguments to find a Historicoconsultaapi
     * @example
     * // Get one Historicoconsultaapi
     * const historicoconsultaapi = await prisma.historicoconsultaapi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends historicoconsultaapiFindUniqueArgs>(args: SelectSubset<T, historicoconsultaapiFindUniqueArgs<ExtArgs>>): Prisma__historicoconsultaapiClient<$Result.GetResult<Prisma.$historicoconsultaapiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Historicoconsultaapi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {historicoconsultaapiFindUniqueOrThrowArgs} args - Arguments to find a Historicoconsultaapi
     * @example
     * // Get one Historicoconsultaapi
     * const historicoconsultaapi = await prisma.historicoconsultaapi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends historicoconsultaapiFindUniqueOrThrowArgs>(args: SelectSubset<T, historicoconsultaapiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__historicoconsultaapiClient<$Result.GetResult<Prisma.$historicoconsultaapiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Historicoconsultaapi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicoconsultaapiFindFirstArgs} args - Arguments to find a Historicoconsultaapi
     * @example
     * // Get one Historicoconsultaapi
     * const historicoconsultaapi = await prisma.historicoconsultaapi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends historicoconsultaapiFindFirstArgs>(args?: SelectSubset<T, historicoconsultaapiFindFirstArgs<ExtArgs>>): Prisma__historicoconsultaapiClient<$Result.GetResult<Prisma.$historicoconsultaapiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Historicoconsultaapi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicoconsultaapiFindFirstOrThrowArgs} args - Arguments to find a Historicoconsultaapi
     * @example
     * // Get one Historicoconsultaapi
     * const historicoconsultaapi = await prisma.historicoconsultaapi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends historicoconsultaapiFindFirstOrThrowArgs>(args?: SelectSubset<T, historicoconsultaapiFindFirstOrThrowArgs<ExtArgs>>): Prisma__historicoconsultaapiClient<$Result.GetResult<Prisma.$historicoconsultaapiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Historicoconsultaapis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicoconsultaapiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historicoconsultaapis
     * const historicoconsultaapis = await prisma.historicoconsultaapi.findMany()
     * 
     * // Get first 10 Historicoconsultaapis
     * const historicoconsultaapis = await prisma.historicoconsultaapi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historicoconsultaapiWithIdOnly = await prisma.historicoconsultaapi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends historicoconsultaapiFindManyArgs>(args?: SelectSubset<T, historicoconsultaapiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historicoconsultaapiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Historicoconsultaapi.
     * @param {historicoconsultaapiCreateArgs} args - Arguments to create a Historicoconsultaapi.
     * @example
     * // Create one Historicoconsultaapi
     * const Historicoconsultaapi = await prisma.historicoconsultaapi.create({
     *   data: {
     *     // ... data to create a Historicoconsultaapi
     *   }
     * })
     * 
     */
    create<T extends historicoconsultaapiCreateArgs>(args: SelectSubset<T, historicoconsultaapiCreateArgs<ExtArgs>>): Prisma__historicoconsultaapiClient<$Result.GetResult<Prisma.$historicoconsultaapiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Historicoconsultaapis.
     * @param {historicoconsultaapiCreateManyArgs} args - Arguments to create many Historicoconsultaapis.
     * @example
     * // Create many Historicoconsultaapis
     * const historicoconsultaapi = await prisma.historicoconsultaapi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends historicoconsultaapiCreateManyArgs>(args?: SelectSubset<T, historicoconsultaapiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historicoconsultaapi.
     * @param {historicoconsultaapiDeleteArgs} args - Arguments to delete one Historicoconsultaapi.
     * @example
     * // Delete one Historicoconsultaapi
     * const Historicoconsultaapi = await prisma.historicoconsultaapi.delete({
     *   where: {
     *     // ... filter to delete one Historicoconsultaapi
     *   }
     * })
     * 
     */
    delete<T extends historicoconsultaapiDeleteArgs>(args: SelectSubset<T, historicoconsultaapiDeleteArgs<ExtArgs>>): Prisma__historicoconsultaapiClient<$Result.GetResult<Prisma.$historicoconsultaapiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Historicoconsultaapi.
     * @param {historicoconsultaapiUpdateArgs} args - Arguments to update one Historicoconsultaapi.
     * @example
     * // Update one Historicoconsultaapi
     * const historicoconsultaapi = await prisma.historicoconsultaapi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends historicoconsultaapiUpdateArgs>(args: SelectSubset<T, historicoconsultaapiUpdateArgs<ExtArgs>>): Prisma__historicoconsultaapiClient<$Result.GetResult<Prisma.$historicoconsultaapiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Historicoconsultaapis.
     * @param {historicoconsultaapiDeleteManyArgs} args - Arguments to filter Historicoconsultaapis to delete.
     * @example
     * // Delete a few Historicoconsultaapis
     * const { count } = await prisma.historicoconsultaapi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends historicoconsultaapiDeleteManyArgs>(args?: SelectSubset<T, historicoconsultaapiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historicoconsultaapis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicoconsultaapiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historicoconsultaapis
     * const historicoconsultaapi = await prisma.historicoconsultaapi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends historicoconsultaapiUpdateManyArgs>(args: SelectSubset<T, historicoconsultaapiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historicoconsultaapi.
     * @param {historicoconsultaapiUpsertArgs} args - Arguments to update or create a Historicoconsultaapi.
     * @example
     * // Update or create a Historicoconsultaapi
     * const historicoconsultaapi = await prisma.historicoconsultaapi.upsert({
     *   create: {
     *     // ... data to create a Historicoconsultaapi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historicoconsultaapi we want to update
     *   }
     * })
     */
    upsert<T extends historicoconsultaapiUpsertArgs>(args: SelectSubset<T, historicoconsultaapiUpsertArgs<ExtArgs>>): Prisma__historicoconsultaapiClient<$Result.GetResult<Prisma.$historicoconsultaapiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Historicoconsultaapis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicoconsultaapiCountArgs} args - Arguments to filter Historicoconsultaapis to count.
     * @example
     * // Count the number of Historicoconsultaapis
     * const count = await prisma.historicoconsultaapi.count({
     *   where: {
     *     // ... the filter for the Historicoconsultaapis we want to count
     *   }
     * })
    **/
    count<T extends historicoconsultaapiCountArgs>(
      args?: Subset<T, historicoconsultaapiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoricoconsultaapiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historicoconsultaapi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricoconsultaapiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoricoconsultaapiAggregateArgs>(args: Subset<T, HistoricoconsultaapiAggregateArgs>): Prisma.PrismaPromise<GetHistoricoconsultaapiAggregateType<T>>

    /**
     * Group by Historicoconsultaapi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicoconsultaapiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historicoconsultaapiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historicoconsultaapiGroupByArgs['orderBy'] }
        : { orderBy?: historicoconsultaapiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historicoconsultaapiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoricoconsultaapiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the historicoconsultaapi model
   */
  readonly fields: historicoconsultaapiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for historicoconsultaapi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__historicoconsultaapiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the historicoconsultaapi model
   */
  interface historicoconsultaapiFieldRefs {
    readonly id: FieldRef<"historicoconsultaapi", 'Int'>
    readonly idservico: FieldRef<"historicoconsultaapi", 'Int'>
    readonly idfornecedor: FieldRef<"historicoconsultaapi", 'Int'>
    readonly cpf: FieldRef<"historicoconsultaapi", 'String'>
    readonly cpfRepresentanteLegal: FieldRef<"historicoconsultaapi", 'String'>
    readonly beneficio: FieldRef<"historicoconsultaapi", 'String'>
    readonly resultado: FieldRef<"historicoconsultaapi", 'Json'>
    readonly statusConsulta: FieldRef<"historicoconsultaapi", 'Int'>
    readonly createdAt: FieldRef<"historicoconsultaapi", 'DateTime'>
    readonly updatedAt: FieldRef<"historicoconsultaapi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * historicoconsultaapi findUnique
   */
  export type historicoconsultaapiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoconsultaapi
     */
    select?: historicoconsultaapiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicoconsultaapi
     */
    omit?: historicoconsultaapiOmit<ExtArgs> | null
    /**
     * Filter, which historicoconsultaapi to fetch.
     */
    where: historicoconsultaapiWhereUniqueInput
  }

  /**
   * historicoconsultaapi findUniqueOrThrow
   */
  export type historicoconsultaapiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoconsultaapi
     */
    select?: historicoconsultaapiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicoconsultaapi
     */
    omit?: historicoconsultaapiOmit<ExtArgs> | null
    /**
     * Filter, which historicoconsultaapi to fetch.
     */
    where: historicoconsultaapiWhereUniqueInput
  }

  /**
   * historicoconsultaapi findFirst
   */
  export type historicoconsultaapiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoconsultaapi
     */
    select?: historicoconsultaapiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicoconsultaapi
     */
    omit?: historicoconsultaapiOmit<ExtArgs> | null
    /**
     * Filter, which historicoconsultaapi to fetch.
     */
    where?: historicoconsultaapiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicoconsultaapis to fetch.
     */
    orderBy?: historicoconsultaapiOrderByWithRelationInput | historicoconsultaapiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historicoconsultaapis.
     */
    cursor?: historicoconsultaapiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicoconsultaapis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicoconsultaapis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historicoconsultaapis.
     */
    distinct?: HistoricoconsultaapiScalarFieldEnum | HistoricoconsultaapiScalarFieldEnum[]
  }

  /**
   * historicoconsultaapi findFirstOrThrow
   */
  export type historicoconsultaapiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoconsultaapi
     */
    select?: historicoconsultaapiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicoconsultaapi
     */
    omit?: historicoconsultaapiOmit<ExtArgs> | null
    /**
     * Filter, which historicoconsultaapi to fetch.
     */
    where?: historicoconsultaapiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicoconsultaapis to fetch.
     */
    orderBy?: historicoconsultaapiOrderByWithRelationInput | historicoconsultaapiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historicoconsultaapis.
     */
    cursor?: historicoconsultaapiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicoconsultaapis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicoconsultaapis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historicoconsultaapis.
     */
    distinct?: HistoricoconsultaapiScalarFieldEnum | HistoricoconsultaapiScalarFieldEnum[]
  }

  /**
   * historicoconsultaapi findMany
   */
  export type historicoconsultaapiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoconsultaapi
     */
    select?: historicoconsultaapiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicoconsultaapi
     */
    omit?: historicoconsultaapiOmit<ExtArgs> | null
    /**
     * Filter, which historicoconsultaapis to fetch.
     */
    where?: historicoconsultaapiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicoconsultaapis to fetch.
     */
    orderBy?: historicoconsultaapiOrderByWithRelationInput | historicoconsultaapiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historicoconsultaapis.
     */
    cursor?: historicoconsultaapiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicoconsultaapis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicoconsultaapis.
     */
    skip?: number
    distinct?: HistoricoconsultaapiScalarFieldEnum | HistoricoconsultaapiScalarFieldEnum[]
  }

  /**
   * historicoconsultaapi create
   */
  export type historicoconsultaapiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoconsultaapi
     */
    select?: historicoconsultaapiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicoconsultaapi
     */
    omit?: historicoconsultaapiOmit<ExtArgs> | null
    /**
     * The data needed to create a historicoconsultaapi.
     */
    data: XOR<historicoconsultaapiCreateInput, historicoconsultaapiUncheckedCreateInput>
  }

  /**
   * historicoconsultaapi createMany
   */
  export type historicoconsultaapiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many historicoconsultaapis.
     */
    data: historicoconsultaapiCreateManyInput | historicoconsultaapiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * historicoconsultaapi update
   */
  export type historicoconsultaapiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoconsultaapi
     */
    select?: historicoconsultaapiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicoconsultaapi
     */
    omit?: historicoconsultaapiOmit<ExtArgs> | null
    /**
     * The data needed to update a historicoconsultaapi.
     */
    data: XOR<historicoconsultaapiUpdateInput, historicoconsultaapiUncheckedUpdateInput>
    /**
     * Choose, which historicoconsultaapi to update.
     */
    where: historicoconsultaapiWhereUniqueInput
  }

  /**
   * historicoconsultaapi updateMany
   */
  export type historicoconsultaapiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update historicoconsultaapis.
     */
    data: XOR<historicoconsultaapiUpdateManyMutationInput, historicoconsultaapiUncheckedUpdateManyInput>
    /**
     * Filter which historicoconsultaapis to update
     */
    where?: historicoconsultaapiWhereInput
    /**
     * Limit how many historicoconsultaapis to update.
     */
    limit?: number
  }

  /**
   * historicoconsultaapi upsert
   */
  export type historicoconsultaapiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoconsultaapi
     */
    select?: historicoconsultaapiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicoconsultaapi
     */
    omit?: historicoconsultaapiOmit<ExtArgs> | null
    /**
     * The filter to search for the historicoconsultaapi to update in case it exists.
     */
    where: historicoconsultaapiWhereUniqueInput
    /**
     * In case the historicoconsultaapi found by the `where` argument doesn't exist, create a new historicoconsultaapi with this data.
     */
    create: XOR<historicoconsultaapiCreateInput, historicoconsultaapiUncheckedCreateInput>
    /**
     * In case the historicoconsultaapi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historicoconsultaapiUpdateInput, historicoconsultaapiUncheckedUpdateInput>
  }

  /**
   * historicoconsultaapi delete
   */
  export type historicoconsultaapiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoconsultaapi
     */
    select?: historicoconsultaapiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicoconsultaapi
     */
    omit?: historicoconsultaapiOmit<ExtArgs> | null
    /**
     * Filter which historicoconsultaapi to delete.
     */
    where: historicoconsultaapiWhereUniqueInput
  }

  /**
   * historicoconsultaapi deleteMany
   */
  export type historicoconsultaapiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which historicoconsultaapis to delete
     */
    where?: historicoconsultaapiWhereInput
    /**
     * Limit how many historicoconsultaapis to delete.
     */
    limit?: number
  }

  /**
   * historicoconsultaapi without action
   */
  export type historicoconsultaapiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicoconsultaapi
     */
    select?: historicoconsultaapiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicoconsultaapi
     */
    omit?: historicoconsultaapiOmit<ExtArgs> | null
  }


  /**
   * Model historicocredito
   */

  export type AggregateHistoricocredito = {
    _count: HistoricocreditoCountAggregateOutputType | null
    _avg: HistoricocreditoAvgAggregateOutputType | null
    _sum: HistoricocreditoSumAggregateOutputType | null
    _min: HistoricocreditoMinAggregateOutputType | null
    _max: HistoricocreditoMaxAggregateOutputType | null
  }

  export type HistoricocreditoAvgAggregateOutputType = {
    id: number | null
    clienteId: number | null
    tipoOperacao: number | null
    quantidade: number | null
    idServico: number | null
  }

  export type HistoricocreditoSumAggregateOutputType = {
    id: number | null
    clienteId: number | null
    tipoOperacao: number | null
    quantidade: number | null
    idServico: number | null
  }

  export type HistoricocreditoMinAggregateOutputType = {
    id: number | null
    clienteId: number | null
    tipoOperacao: number | null
    quantidade: number | null
    createdAt: Date | null
    idServico: number | null
  }

  export type HistoricocreditoMaxAggregateOutputType = {
    id: number | null
    clienteId: number | null
    tipoOperacao: number | null
    quantidade: number | null
    createdAt: Date | null
    idServico: number | null
  }

  export type HistoricocreditoCountAggregateOutputType = {
    id: number
    clienteId: number
    tipoOperacao: number
    quantidade: number
    createdAt: number
    idServico: number
    _all: number
  }


  export type HistoricocreditoAvgAggregateInputType = {
    id?: true
    clienteId?: true
    tipoOperacao?: true
    quantidade?: true
    idServico?: true
  }

  export type HistoricocreditoSumAggregateInputType = {
    id?: true
    clienteId?: true
    tipoOperacao?: true
    quantidade?: true
    idServico?: true
  }

  export type HistoricocreditoMinAggregateInputType = {
    id?: true
    clienteId?: true
    tipoOperacao?: true
    quantidade?: true
    createdAt?: true
    idServico?: true
  }

  export type HistoricocreditoMaxAggregateInputType = {
    id?: true
    clienteId?: true
    tipoOperacao?: true
    quantidade?: true
    createdAt?: true
    idServico?: true
  }

  export type HistoricocreditoCountAggregateInputType = {
    id?: true
    clienteId?: true
    tipoOperacao?: true
    quantidade?: true
    createdAt?: true
    idServico?: true
    _all?: true
  }

  export type HistoricocreditoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which historicocredito to aggregate.
     */
    where?: historicocreditoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicocreditos to fetch.
     */
    orderBy?: historicocreditoOrderByWithRelationInput | historicocreditoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historicocreditoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicocreditos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicocreditos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historicocreditos
    **/
    _count?: true | HistoricocreditoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistoricocreditoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistoricocreditoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoricocreditoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoricocreditoMaxAggregateInputType
  }

  export type GetHistoricocreditoAggregateType<T extends HistoricocreditoAggregateArgs> = {
        [P in keyof T & keyof AggregateHistoricocredito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistoricocredito[P]>
      : GetScalarType<T[P], AggregateHistoricocredito[P]>
  }




  export type historicocreditoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historicocreditoWhereInput
    orderBy?: historicocreditoOrderByWithAggregationInput | historicocreditoOrderByWithAggregationInput[]
    by: HistoricocreditoScalarFieldEnum[] | HistoricocreditoScalarFieldEnum
    having?: historicocreditoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoricocreditoCountAggregateInputType | true
    _avg?: HistoricocreditoAvgAggregateInputType
    _sum?: HistoricocreditoSumAggregateInputType
    _min?: HistoricocreditoMinAggregateInputType
    _max?: HistoricocreditoMaxAggregateInputType
  }

  export type HistoricocreditoGroupByOutputType = {
    id: number
    clienteId: number
    tipoOperacao: number
    quantidade: number
    createdAt: Date
    idServico: number
    _count: HistoricocreditoCountAggregateOutputType | null
    _avg: HistoricocreditoAvgAggregateOutputType | null
    _sum: HistoricocreditoSumAggregateOutputType | null
    _min: HistoricocreditoMinAggregateOutputType | null
    _max: HistoricocreditoMaxAggregateOutputType | null
  }

  type GetHistoricocreditoGroupByPayload<T extends historicocreditoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistoricocreditoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoricocreditoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoricocreditoGroupByOutputType[P]>
            : GetScalarType<T[P], HistoricocreditoGroupByOutputType[P]>
        }
      >
    >


  export type historicocreditoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clienteId?: boolean
    tipoOperacao?: boolean
    quantidade?: boolean
    createdAt?: boolean
    idServico?: boolean
  }, ExtArgs["result"]["historicocredito"]>



  export type historicocreditoSelectScalar = {
    id?: boolean
    clienteId?: boolean
    tipoOperacao?: boolean
    quantidade?: boolean
    createdAt?: boolean
    idServico?: boolean
  }

  export type historicocreditoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clienteId" | "tipoOperacao" | "quantidade" | "createdAt" | "idServico", ExtArgs["result"]["historicocredito"]>

  export type $historicocreditoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "historicocredito"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clienteId: number
      tipoOperacao: number
      quantidade: number
      createdAt: Date
      idServico: number
    }, ExtArgs["result"]["historicocredito"]>
    composites: {}
  }

  type historicocreditoGetPayload<S extends boolean | null | undefined | historicocreditoDefaultArgs> = $Result.GetResult<Prisma.$historicocreditoPayload, S>

  type historicocreditoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<historicocreditoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HistoricocreditoCountAggregateInputType | true
    }

  export interface historicocreditoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['historicocredito'], meta: { name: 'historicocredito' } }
    /**
     * Find zero or one Historicocredito that matches the filter.
     * @param {historicocreditoFindUniqueArgs} args - Arguments to find a Historicocredito
     * @example
     * // Get one Historicocredito
     * const historicocredito = await prisma.historicocredito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends historicocreditoFindUniqueArgs>(args: SelectSubset<T, historicocreditoFindUniqueArgs<ExtArgs>>): Prisma__historicocreditoClient<$Result.GetResult<Prisma.$historicocreditoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Historicocredito that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {historicocreditoFindUniqueOrThrowArgs} args - Arguments to find a Historicocredito
     * @example
     * // Get one Historicocredito
     * const historicocredito = await prisma.historicocredito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends historicocreditoFindUniqueOrThrowArgs>(args: SelectSubset<T, historicocreditoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__historicocreditoClient<$Result.GetResult<Prisma.$historicocreditoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Historicocredito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicocreditoFindFirstArgs} args - Arguments to find a Historicocredito
     * @example
     * // Get one Historicocredito
     * const historicocredito = await prisma.historicocredito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends historicocreditoFindFirstArgs>(args?: SelectSubset<T, historicocreditoFindFirstArgs<ExtArgs>>): Prisma__historicocreditoClient<$Result.GetResult<Prisma.$historicocreditoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Historicocredito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicocreditoFindFirstOrThrowArgs} args - Arguments to find a Historicocredito
     * @example
     * // Get one Historicocredito
     * const historicocredito = await prisma.historicocredito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends historicocreditoFindFirstOrThrowArgs>(args?: SelectSubset<T, historicocreditoFindFirstOrThrowArgs<ExtArgs>>): Prisma__historicocreditoClient<$Result.GetResult<Prisma.$historicocreditoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Historicocreditos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicocreditoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historicocreditos
     * const historicocreditos = await prisma.historicocredito.findMany()
     * 
     * // Get first 10 Historicocreditos
     * const historicocreditos = await prisma.historicocredito.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historicocreditoWithIdOnly = await prisma.historicocredito.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends historicocreditoFindManyArgs>(args?: SelectSubset<T, historicocreditoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historicocreditoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Historicocredito.
     * @param {historicocreditoCreateArgs} args - Arguments to create a Historicocredito.
     * @example
     * // Create one Historicocredito
     * const Historicocredito = await prisma.historicocredito.create({
     *   data: {
     *     // ... data to create a Historicocredito
     *   }
     * })
     * 
     */
    create<T extends historicocreditoCreateArgs>(args: SelectSubset<T, historicocreditoCreateArgs<ExtArgs>>): Prisma__historicocreditoClient<$Result.GetResult<Prisma.$historicocreditoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Historicocreditos.
     * @param {historicocreditoCreateManyArgs} args - Arguments to create many Historicocreditos.
     * @example
     * // Create many Historicocreditos
     * const historicocredito = await prisma.historicocredito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends historicocreditoCreateManyArgs>(args?: SelectSubset<T, historicocreditoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historicocredito.
     * @param {historicocreditoDeleteArgs} args - Arguments to delete one Historicocredito.
     * @example
     * // Delete one Historicocredito
     * const Historicocredito = await prisma.historicocredito.delete({
     *   where: {
     *     // ... filter to delete one Historicocredito
     *   }
     * })
     * 
     */
    delete<T extends historicocreditoDeleteArgs>(args: SelectSubset<T, historicocreditoDeleteArgs<ExtArgs>>): Prisma__historicocreditoClient<$Result.GetResult<Prisma.$historicocreditoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Historicocredito.
     * @param {historicocreditoUpdateArgs} args - Arguments to update one Historicocredito.
     * @example
     * // Update one Historicocredito
     * const historicocredito = await prisma.historicocredito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends historicocreditoUpdateArgs>(args: SelectSubset<T, historicocreditoUpdateArgs<ExtArgs>>): Prisma__historicocreditoClient<$Result.GetResult<Prisma.$historicocreditoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Historicocreditos.
     * @param {historicocreditoDeleteManyArgs} args - Arguments to filter Historicocreditos to delete.
     * @example
     * // Delete a few Historicocreditos
     * const { count } = await prisma.historicocredito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends historicocreditoDeleteManyArgs>(args?: SelectSubset<T, historicocreditoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historicocreditos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicocreditoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historicocreditos
     * const historicocredito = await prisma.historicocredito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends historicocreditoUpdateManyArgs>(args: SelectSubset<T, historicocreditoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historicocredito.
     * @param {historicocreditoUpsertArgs} args - Arguments to update or create a Historicocredito.
     * @example
     * // Update or create a Historicocredito
     * const historicocredito = await prisma.historicocredito.upsert({
     *   create: {
     *     // ... data to create a Historicocredito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historicocredito we want to update
     *   }
     * })
     */
    upsert<T extends historicocreditoUpsertArgs>(args: SelectSubset<T, historicocreditoUpsertArgs<ExtArgs>>): Prisma__historicocreditoClient<$Result.GetResult<Prisma.$historicocreditoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Historicocreditos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicocreditoCountArgs} args - Arguments to filter Historicocreditos to count.
     * @example
     * // Count the number of Historicocreditos
     * const count = await prisma.historicocredito.count({
     *   where: {
     *     // ... the filter for the Historicocreditos we want to count
     *   }
     * })
    **/
    count<T extends historicocreditoCountArgs>(
      args?: Subset<T, historicocreditoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoricocreditoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historicocredito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricocreditoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoricocreditoAggregateArgs>(args: Subset<T, HistoricocreditoAggregateArgs>): Prisma.PrismaPromise<GetHistoricocreditoAggregateType<T>>

    /**
     * Group by Historicocredito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historicocreditoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historicocreditoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historicocreditoGroupByArgs['orderBy'] }
        : { orderBy?: historicocreditoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historicocreditoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoricocreditoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the historicocredito model
   */
  readonly fields: historicocreditoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for historicocredito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__historicocreditoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the historicocredito model
   */
  interface historicocreditoFieldRefs {
    readonly id: FieldRef<"historicocredito", 'Int'>
    readonly clienteId: FieldRef<"historicocredito", 'Int'>
    readonly tipoOperacao: FieldRef<"historicocredito", 'Int'>
    readonly quantidade: FieldRef<"historicocredito", 'Int'>
    readonly createdAt: FieldRef<"historicocredito", 'DateTime'>
    readonly idServico: FieldRef<"historicocredito", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * historicocredito findUnique
   */
  export type historicocreditoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicocredito
     */
    select?: historicocreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicocredito
     */
    omit?: historicocreditoOmit<ExtArgs> | null
    /**
     * Filter, which historicocredito to fetch.
     */
    where: historicocreditoWhereUniqueInput
  }

  /**
   * historicocredito findUniqueOrThrow
   */
  export type historicocreditoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicocredito
     */
    select?: historicocreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicocredito
     */
    omit?: historicocreditoOmit<ExtArgs> | null
    /**
     * Filter, which historicocredito to fetch.
     */
    where: historicocreditoWhereUniqueInput
  }

  /**
   * historicocredito findFirst
   */
  export type historicocreditoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicocredito
     */
    select?: historicocreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicocredito
     */
    omit?: historicocreditoOmit<ExtArgs> | null
    /**
     * Filter, which historicocredito to fetch.
     */
    where?: historicocreditoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicocreditos to fetch.
     */
    orderBy?: historicocreditoOrderByWithRelationInput | historicocreditoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historicocreditos.
     */
    cursor?: historicocreditoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicocreditos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicocreditos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historicocreditos.
     */
    distinct?: HistoricocreditoScalarFieldEnum | HistoricocreditoScalarFieldEnum[]
  }

  /**
   * historicocredito findFirstOrThrow
   */
  export type historicocreditoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicocredito
     */
    select?: historicocreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicocredito
     */
    omit?: historicocreditoOmit<ExtArgs> | null
    /**
     * Filter, which historicocredito to fetch.
     */
    where?: historicocreditoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicocreditos to fetch.
     */
    orderBy?: historicocreditoOrderByWithRelationInput | historicocreditoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historicocreditos.
     */
    cursor?: historicocreditoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicocreditos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicocreditos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historicocreditos.
     */
    distinct?: HistoricocreditoScalarFieldEnum | HistoricocreditoScalarFieldEnum[]
  }

  /**
   * historicocredito findMany
   */
  export type historicocreditoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicocredito
     */
    select?: historicocreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicocredito
     */
    omit?: historicocreditoOmit<ExtArgs> | null
    /**
     * Filter, which historicocreditos to fetch.
     */
    where?: historicocreditoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historicocreditos to fetch.
     */
    orderBy?: historicocreditoOrderByWithRelationInput | historicocreditoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historicocreditos.
     */
    cursor?: historicocreditoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historicocreditos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historicocreditos.
     */
    skip?: number
    distinct?: HistoricocreditoScalarFieldEnum | HistoricocreditoScalarFieldEnum[]
  }

  /**
   * historicocredito create
   */
  export type historicocreditoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicocredito
     */
    select?: historicocreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicocredito
     */
    omit?: historicocreditoOmit<ExtArgs> | null
    /**
     * The data needed to create a historicocredito.
     */
    data: XOR<historicocreditoCreateInput, historicocreditoUncheckedCreateInput>
  }

  /**
   * historicocredito createMany
   */
  export type historicocreditoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many historicocreditos.
     */
    data: historicocreditoCreateManyInput | historicocreditoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * historicocredito update
   */
  export type historicocreditoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicocredito
     */
    select?: historicocreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicocredito
     */
    omit?: historicocreditoOmit<ExtArgs> | null
    /**
     * The data needed to update a historicocredito.
     */
    data: XOR<historicocreditoUpdateInput, historicocreditoUncheckedUpdateInput>
    /**
     * Choose, which historicocredito to update.
     */
    where: historicocreditoWhereUniqueInput
  }

  /**
   * historicocredito updateMany
   */
  export type historicocreditoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update historicocreditos.
     */
    data: XOR<historicocreditoUpdateManyMutationInput, historicocreditoUncheckedUpdateManyInput>
    /**
     * Filter which historicocreditos to update
     */
    where?: historicocreditoWhereInput
    /**
     * Limit how many historicocreditos to update.
     */
    limit?: number
  }

  /**
   * historicocredito upsert
   */
  export type historicocreditoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicocredito
     */
    select?: historicocreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicocredito
     */
    omit?: historicocreditoOmit<ExtArgs> | null
    /**
     * The filter to search for the historicocredito to update in case it exists.
     */
    where: historicocreditoWhereUniqueInput
    /**
     * In case the historicocredito found by the `where` argument doesn't exist, create a new historicocredito with this data.
     */
    create: XOR<historicocreditoCreateInput, historicocreditoUncheckedCreateInput>
    /**
     * In case the historicocredito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historicocreditoUpdateInput, historicocreditoUncheckedUpdateInput>
  }

  /**
   * historicocredito delete
   */
  export type historicocreditoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicocredito
     */
    select?: historicocreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicocredito
     */
    omit?: historicocreditoOmit<ExtArgs> | null
    /**
     * Filter which historicocredito to delete.
     */
    where: historicocreditoWhereUniqueInput
  }

  /**
   * historicocredito deleteMany
   */
  export type historicocreditoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which historicocreditos to delete
     */
    where?: historicocreditoWhereInput
    /**
     * Limit how many historicocreditos to delete.
     */
    limit?: number
  }

  /**
   * historicocredito without action
   */
  export type historicocreditoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historicocredito
     */
    select?: historicocreditoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the historicocredito
     */
    omit?: historicocreditoOmit<ExtArgs> | null
  }


  /**
   * Model in100
   */

  export type AggregateIn100 = {
    _count: In100CountAggregateOutputType | null
    _avg: In100AvgAggregateOutputType | null
    _sum: In100SumAggregateOutputType | null
    _min: In100MinAggregateOutputType | null
    _max: In100MaxAggregateOutputType | null
  }

  export type In100AvgAggregateOutputType = {
    id: number | null
    idUsuario: number | null
    idConsulta: number | null
    idConsultaOffline: number | null
    requisicao: number | null
    idFornecedor: number | null
    idStatusSolicitacaoIn100: number | null
  }

  export type In100SumAggregateOutputType = {
    id: number | null
    idUsuario: number | null
    idConsulta: number | null
    idConsultaOffline: number | null
    requisicao: bigint | null
    idFornecedor: number | null
    idStatusSolicitacaoIn100: number | null
  }

  export type In100MinAggregateOutputType = {
    id: number | null
    idUsuario: number | null
    idConsulta: number | null
    idConsultaOffline: number | null
    cpf: string | null
    numeroBeneficio: string | null
    situacao: string | null
    requisicao: bigint | null
    errorID: string | null
    createdAt: Date | null
    updatedAt: Date | null
    cpfRepresentanteLegal: string | null
    idFornecedor: number | null
    idStatusSolicitacaoIn100: number | null
    msgErro: string | null
  }

  export type In100MaxAggregateOutputType = {
    id: number | null
    idUsuario: number | null
    idConsulta: number | null
    idConsultaOffline: number | null
    cpf: string | null
    numeroBeneficio: string | null
    situacao: string | null
    requisicao: bigint | null
    errorID: string | null
    createdAt: Date | null
    updatedAt: Date | null
    cpfRepresentanteLegal: string | null
    idFornecedor: number | null
    idStatusSolicitacaoIn100: number | null
    msgErro: string | null
  }

  export type In100CountAggregateOutputType = {
    id: number
    idUsuario: number
    idConsulta: number
    idConsultaOffline: number
    cpf: number
    numeroBeneficio: number
    situacao: number
    requisicao: number
    errorID: number
    resultado: number
    createdAt: number
    updatedAt: number
    cpfRepresentanteLegal: number
    idFornecedor: number
    idStatusSolicitacaoIn100: number
    msgErro: number
    _all: number
  }


  export type In100AvgAggregateInputType = {
    id?: true
    idUsuario?: true
    idConsulta?: true
    idConsultaOffline?: true
    requisicao?: true
    idFornecedor?: true
    idStatusSolicitacaoIn100?: true
  }

  export type In100SumAggregateInputType = {
    id?: true
    idUsuario?: true
    idConsulta?: true
    idConsultaOffline?: true
    requisicao?: true
    idFornecedor?: true
    idStatusSolicitacaoIn100?: true
  }

  export type In100MinAggregateInputType = {
    id?: true
    idUsuario?: true
    idConsulta?: true
    idConsultaOffline?: true
    cpf?: true
    numeroBeneficio?: true
    situacao?: true
    requisicao?: true
    errorID?: true
    createdAt?: true
    updatedAt?: true
    cpfRepresentanteLegal?: true
    idFornecedor?: true
    idStatusSolicitacaoIn100?: true
    msgErro?: true
  }

  export type In100MaxAggregateInputType = {
    id?: true
    idUsuario?: true
    idConsulta?: true
    idConsultaOffline?: true
    cpf?: true
    numeroBeneficio?: true
    situacao?: true
    requisicao?: true
    errorID?: true
    createdAt?: true
    updatedAt?: true
    cpfRepresentanteLegal?: true
    idFornecedor?: true
    idStatusSolicitacaoIn100?: true
    msgErro?: true
  }

  export type In100CountAggregateInputType = {
    id?: true
    idUsuario?: true
    idConsulta?: true
    idConsultaOffline?: true
    cpf?: true
    numeroBeneficio?: true
    situacao?: true
    requisicao?: true
    errorID?: true
    resultado?: true
    createdAt?: true
    updatedAt?: true
    cpfRepresentanteLegal?: true
    idFornecedor?: true
    idStatusSolicitacaoIn100?: true
    msgErro?: true
    _all?: true
  }

  export type In100AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which in100 to aggregate.
     */
    where?: in100WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of in100s to fetch.
     */
    orderBy?: in100OrderByWithRelationInput | in100OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: in100WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` in100s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` in100s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned in100s
    **/
    _count?: true | In100CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: In100AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: In100SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: In100MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: In100MaxAggregateInputType
  }

  export type GetIn100AggregateType<T extends In100AggregateArgs> = {
        [P in keyof T & keyof AggregateIn100]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIn100[P]>
      : GetScalarType<T[P], AggregateIn100[P]>
  }




  export type in100GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: in100WhereInput
    orderBy?: in100OrderByWithAggregationInput | in100OrderByWithAggregationInput[]
    by: In100ScalarFieldEnum[] | In100ScalarFieldEnum
    having?: in100ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: In100CountAggregateInputType | true
    _avg?: In100AvgAggregateInputType
    _sum?: In100SumAggregateInputType
    _min?: In100MinAggregateInputType
    _max?: In100MaxAggregateInputType
  }

  export type In100GroupByOutputType = {
    id: number
    idUsuario: number
    idConsulta: number
    idConsultaOffline: number
    cpf: string
    numeroBeneficio: string | null
    situacao: string | null
    requisicao: bigint | null
    errorID: string | null
    resultado: JsonValue | null
    createdAt: Date
    updatedAt: Date
    cpfRepresentanteLegal: string | null
    idFornecedor: number
    idStatusSolicitacaoIn100: number
    msgErro: string | null
    _count: In100CountAggregateOutputType | null
    _avg: In100AvgAggregateOutputType | null
    _sum: In100SumAggregateOutputType | null
    _min: In100MinAggregateOutputType | null
    _max: In100MaxAggregateOutputType | null
  }

  type GetIn100GroupByPayload<T extends in100GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<In100GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof In100GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], In100GroupByOutputType[P]>
            : GetScalarType<T[P], In100GroupByOutputType[P]>
        }
      >
    >


  export type in100Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idUsuario?: boolean
    idConsulta?: boolean
    idConsultaOffline?: boolean
    cpf?: boolean
    numeroBeneficio?: boolean
    situacao?: boolean
    requisicao?: boolean
    errorID?: boolean
    resultado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cpfRepresentanteLegal?: boolean
    idFornecedor?: boolean
    idStatusSolicitacaoIn100?: boolean
    msgErro?: boolean
  }, ExtArgs["result"]["in100"]>



  export type in100SelectScalar = {
    id?: boolean
    idUsuario?: boolean
    idConsulta?: boolean
    idConsultaOffline?: boolean
    cpf?: boolean
    numeroBeneficio?: boolean
    situacao?: boolean
    requisicao?: boolean
    errorID?: boolean
    resultado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cpfRepresentanteLegal?: boolean
    idFornecedor?: boolean
    idStatusSolicitacaoIn100?: boolean
    msgErro?: boolean
  }

  export type in100Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idUsuario" | "idConsulta" | "idConsultaOffline" | "cpf" | "numeroBeneficio" | "situacao" | "requisicao" | "errorID" | "resultado" | "createdAt" | "updatedAt" | "cpfRepresentanteLegal" | "idFornecedor" | "idStatusSolicitacaoIn100" | "msgErro", ExtArgs["result"]["in100"]>

  export type $in100Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "in100"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idUsuario: number
      idConsulta: number
      idConsultaOffline: number
      cpf: string
      numeroBeneficio: string | null
      situacao: string | null
      requisicao: bigint | null
      errorID: string | null
      resultado: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      cpfRepresentanteLegal: string | null
      idFornecedor: number
      idStatusSolicitacaoIn100: number
      msgErro: string | null
    }, ExtArgs["result"]["in100"]>
    composites: {}
  }

  type in100GetPayload<S extends boolean | null | undefined | in100DefaultArgs> = $Result.GetResult<Prisma.$in100Payload, S>

  type in100CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<in100FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: In100CountAggregateInputType | true
    }

  export interface in100Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['in100'], meta: { name: 'in100' } }
    /**
     * Find zero or one In100 that matches the filter.
     * @param {in100FindUniqueArgs} args - Arguments to find a In100
     * @example
     * // Get one In100
     * const in100 = await prisma.in100.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends in100FindUniqueArgs>(args: SelectSubset<T, in100FindUniqueArgs<ExtArgs>>): Prisma__in100Client<$Result.GetResult<Prisma.$in100Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one In100 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {in100FindUniqueOrThrowArgs} args - Arguments to find a In100
     * @example
     * // Get one In100
     * const in100 = await prisma.in100.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends in100FindUniqueOrThrowArgs>(args: SelectSubset<T, in100FindUniqueOrThrowArgs<ExtArgs>>): Prisma__in100Client<$Result.GetResult<Prisma.$in100Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first In100 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in100FindFirstArgs} args - Arguments to find a In100
     * @example
     * // Get one In100
     * const in100 = await prisma.in100.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends in100FindFirstArgs>(args?: SelectSubset<T, in100FindFirstArgs<ExtArgs>>): Prisma__in100Client<$Result.GetResult<Prisma.$in100Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first In100 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in100FindFirstOrThrowArgs} args - Arguments to find a In100
     * @example
     * // Get one In100
     * const in100 = await prisma.in100.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends in100FindFirstOrThrowArgs>(args?: SelectSubset<T, in100FindFirstOrThrowArgs<ExtArgs>>): Prisma__in100Client<$Result.GetResult<Prisma.$in100Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more In100s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in100FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all In100s
     * const in100s = await prisma.in100.findMany()
     * 
     * // Get first 10 In100s
     * const in100s = await prisma.in100.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const in100WithIdOnly = await prisma.in100.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends in100FindManyArgs>(args?: SelectSubset<T, in100FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$in100Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a In100.
     * @param {in100CreateArgs} args - Arguments to create a In100.
     * @example
     * // Create one In100
     * const In100 = await prisma.in100.create({
     *   data: {
     *     // ... data to create a In100
     *   }
     * })
     * 
     */
    create<T extends in100CreateArgs>(args: SelectSubset<T, in100CreateArgs<ExtArgs>>): Prisma__in100Client<$Result.GetResult<Prisma.$in100Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many In100s.
     * @param {in100CreateManyArgs} args - Arguments to create many In100s.
     * @example
     * // Create many In100s
     * const in100 = await prisma.in100.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends in100CreateManyArgs>(args?: SelectSubset<T, in100CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a In100.
     * @param {in100DeleteArgs} args - Arguments to delete one In100.
     * @example
     * // Delete one In100
     * const In100 = await prisma.in100.delete({
     *   where: {
     *     // ... filter to delete one In100
     *   }
     * })
     * 
     */
    delete<T extends in100DeleteArgs>(args: SelectSubset<T, in100DeleteArgs<ExtArgs>>): Prisma__in100Client<$Result.GetResult<Prisma.$in100Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one In100.
     * @param {in100UpdateArgs} args - Arguments to update one In100.
     * @example
     * // Update one In100
     * const in100 = await prisma.in100.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends in100UpdateArgs>(args: SelectSubset<T, in100UpdateArgs<ExtArgs>>): Prisma__in100Client<$Result.GetResult<Prisma.$in100Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more In100s.
     * @param {in100DeleteManyArgs} args - Arguments to filter In100s to delete.
     * @example
     * // Delete a few In100s
     * const { count } = await prisma.in100.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends in100DeleteManyArgs>(args?: SelectSubset<T, in100DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more In100s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in100UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many In100s
     * const in100 = await prisma.in100.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends in100UpdateManyArgs>(args: SelectSubset<T, in100UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one In100.
     * @param {in100UpsertArgs} args - Arguments to update or create a In100.
     * @example
     * // Update or create a In100
     * const in100 = await prisma.in100.upsert({
     *   create: {
     *     // ... data to create a In100
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the In100 we want to update
     *   }
     * })
     */
    upsert<T extends in100UpsertArgs>(args: SelectSubset<T, in100UpsertArgs<ExtArgs>>): Prisma__in100Client<$Result.GetResult<Prisma.$in100Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of In100s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in100CountArgs} args - Arguments to filter In100s to count.
     * @example
     * // Count the number of In100s
     * const count = await prisma.in100.count({
     *   where: {
     *     // ... the filter for the In100s we want to count
     *   }
     * })
    **/
    count<T extends in100CountArgs>(
      args?: Subset<T, in100CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], In100CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a In100.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {In100AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends In100AggregateArgs>(args: Subset<T, In100AggregateArgs>): Prisma.PrismaPromise<GetIn100AggregateType<T>>

    /**
     * Group by In100.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {in100GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends in100GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: in100GroupByArgs['orderBy'] }
        : { orderBy?: in100GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, in100GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIn100GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the in100 model
   */
  readonly fields: in100FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for in100.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__in100Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the in100 model
   */
  interface in100FieldRefs {
    readonly id: FieldRef<"in100", 'Int'>
    readonly idUsuario: FieldRef<"in100", 'Int'>
    readonly idConsulta: FieldRef<"in100", 'Int'>
    readonly idConsultaOffline: FieldRef<"in100", 'Int'>
    readonly cpf: FieldRef<"in100", 'String'>
    readonly numeroBeneficio: FieldRef<"in100", 'String'>
    readonly situacao: FieldRef<"in100", 'String'>
    readonly requisicao: FieldRef<"in100", 'BigInt'>
    readonly errorID: FieldRef<"in100", 'String'>
    readonly resultado: FieldRef<"in100", 'Json'>
    readonly createdAt: FieldRef<"in100", 'DateTime'>
    readonly updatedAt: FieldRef<"in100", 'DateTime'>
    readonly cpfRepresentanteLegal: FieldRef<"in100", 'String'>
    readonly idFornecedor: FieldRef<"in100", 'Int'>
    readonly idStatusSolicitacaoIn100: FieldRef<"in100", 'Int'>
    readonly msgErro: FieldRef<"in100", 'String'>
  }
    

  // Custom InputTypes
  /**
   * in100 findUnique
   */
  export type in100FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in100
     */
    select?: in100Select<ExtArgs> | null
    /**
     * Omit specific fields from the in100
     */
    omit?: in100Omit<ExtArgs> | null
    /**
     * Filter, which in100 to fetch.
     */
    where: in100WhereUniqueInput
  }

  /**
   * in100 findUniqueOrThrow
   */
  export type in100FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in100
     */
    select?: in100Select<ExtArgs> | null
    /**
     * Omit specific fields from the in100
     */
    omit?: in100Omit<ExtArgs> | null
    /**
     * Filter, which in100 to fetch.
     */
    where: in100WhereUniqueInput
  }

  /**
   * in100 findFirst
   */
  export type in100FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in100
     */
    select?: in100Select<ExtArgs> | null
    /**
     * Omit specific fields from the in100
     */
    omit?: in100Omit<ExtArgs> | null
    /**
     * Filter, which in100 to fetch.
     */
    where?: in100WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of in100s to fetch.
     */
    orderBy?: in100OrderByWithRelationInput | in100OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for in100s.
     */
    cursor?: in100WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` in100s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` in100s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of in100s.
     */
    distinct?: In100ScalarFieldEnum | In100ScalarFieldEnum[]
  }

  /**
   * in100 findFirstOrThrow
   */
  export type in100FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in100
     */
    select?: in100Select<ExtArgs> | null
    /**
     * Omit specific fields from the in100
     */
    omit?: in100Omit<ExtArgs> | null
    /**
     * Filter, which in100 to fetch.
     */
    where?: in100WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of in100s to fetch.
     */
    orderBy?: in100OrderByWithRelationInput | in100OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for in100s.
     */
    cursor?: in100WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` in100s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` in100s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of in100s.
     */
    distinct?: In100ScalarFieldEnum | In100ScalarFieldEnum[]
  }

  /**
   * in100 findMany
   */
  export type in100FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in100
     */
    select?: in100Select<ExtArgs> | null
    /**
     * Omit specific fields from the in100
     */
    omit?: in100Omit<ExtArgs> | null
    /**
     * Filter, which in100s to fetch.
     */
    where?: in100WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of in100s to fetch.
     */
    orderBy?: in100OrderByWithRelationInput | in100OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing in100s.
     */
    cursor?: in100WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` in100s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` in100s.
     */
    skip?: number
    distinct?: In100ScalarFieldEnum | In100ScalarFieldEnum[]
  }

  /**
   * in100 create
   */
  export type in100CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in100
     */
    select?: in100Select<ExtArgs> | null
    /**
     * Omit specific fields from the in100
     */
    omit?: in100Omit<ExtArgs> | null
    /**
     * The data needed to create a in100.
     */
    data: XOR<in100CreateInput, in100UncheckedCreateInput>
  }

  /**
   * in100 createMany
   */
  export type in100CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many in100s.
     */
    data: in100CreateManyInput | in100CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * in100 update
   */
  export type in100UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in100
     */
    select?: in100Select<ExtArgs> | null
    /**
     * Omit specific fields from the in100
     */
    omit?: in100Omit<ExtArgs> | null
    /**
     * The data needed to update a in100.
     */
    data: XOR<in100UpdateInput, in100UncheckedUpdateInput>
    /**
     * Choose, which in100 to update.
     */
    where: in100WhereUniqueInput
  }

  /**
   * in100 updateMany
   */
  export type in100UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update in100s.
     */
    data: XOR<in100UpdateManyMutationInput, in100UncheckedUpdateManyInput>
    /**
     * Filter which in100s to update
     */
    where?: in100WhereInput
    /**
     * Limit how many in100s to update.
     */
    limit?: number
  }

  /**
   * in100 upsert
   */
  export type in100UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in100
     */
    select?: in100Select<ExtArgs> | null
    /**
     * Omit specific fields from the in100
     */
    omit?: in100Omit<ExtArgs> | null
    /**
     * The filter to search for the in100 to update in case it exists.
     */
    where: in100WhereUniqueInput
    /**
     * In case the in100 found by the `where` argument doesn't exist, create a new in100 with this data.
     */
    create: XOR<in100CreateInput, in100UncheckedCreateInput>
    /**
     * In case the in100 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<in100UpdateInput, in100UncheckedUpdateInput>
  }

  /**
   * in100 delete
   */
  export type in100DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in100
     */
    select?: in100Select<ExtArgs> | null
    /**
     * Omit specific fields from the in100
     */
    omit?: in100Omit<ExtArgs> | null
    /**
     * Filter which in100 to delete.
     */
    where: in100WhereUniqueInput
  }

  /**
   * in100 deleteMany
   */
  export type in100DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which in100s to delete
     */
    where?: in100WhereInput
    /**
     * Limit how many in100s to delete.
     */
    limit?: number
  }

  /**
   * in100 without action
   */
  export type in100DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the in100
     */
    select?: in100Select<ExtArgs> | null
    /**
     * Omit specific fields from the in100
     */
    omit?: in100Omit<ExtArgs> | null
  }


  /**
   * Model logins
   */

  export type AggregateLogins = {
    _count: LoginsCountAggregateOutputType | null
    _avg: LoginsAvgAggregateOutputType | null
    _sum: LoginsSumAggregateOutputType | null
    _min: LoginsMinAggregateOutputType | null
    _max: LoginsMaxAggregateOutputType | null
  }

  export type LoginsAvgAggregateOutputType = {
    id: number | null
    idperfil: number | null
  }

  export type LoginsSumAggregateOutputType = {
    id: number | null
    idperfil: number | null
  }

  export type LoginsMinAggregateOutputType = {
    id: number | null
    name: string | null
    user_name: string | null
    active: boolean | null
    password: string | null
    idperfil: number | null
    createdAt: Date | null
    updatedAt: Date | null
    cpf: string | null
    email: string | null
    telefone: string | null
    usuarioAPi: boolean | null
    chaveApi: string | null
  }

  export type LoginsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    user_name: string | null
    active: boolean | null
    password: string | null
    idperfil: number | null
    createdAt: Date | null
    updatedAt: Date | null
    cpf: string | null
    email: string | null
    telefone: string | null
    usuarioAPi: boolean | null
    chaveApi: string | null
  }

  export type LoginsCountAggregateOutputType = {
    id: number
    name: number
    user_name: number
    active: number
    password: number
    idperfil: number
    createdAt: number
    updatedAt: number
    cpf: number
    email: number
    telefone: number
    usuarioAPi: number
    chaveApi: number
    _all: number
  }


  export type LoginsAvgAggregateInputType = {
    id?: true
    idperfil?: true
  }

  export type LoginsSumAggregateInputType = {
    id?: true
    idperfil?: true
  }

  export type LoginsMinAggregateInputType = {
    id?: true
    name?: true
    user_name?: true
    active?: true
    password?: true
    idperfil?: true
    createdAt?: true
    updatedAt?: true
    cpf?: true
    email?: true
    telefone?: true
    usuarioAPi?: true
    chaveApi?: true
  }

  export type LoginsMaxAggregateInputType = {
    id?: true
    name?: true
    user_name?: true
    active?: true
    password?: true
    idperfil?: true
    createdAt?: true
    updatedAt?: true
    cpf?: true
    email?: true
    telefone?: true
    usuarioAPi?: true
    chaveApi?: true
  }

  export type LoginsCountAggregateInputType = {
    id?: true
    name?: true
    user_name?: true
    active?: true
    password?: true
    idperfil?: true
    createdAt?: true
    updatedAt?: true
    cpf?: true
    email?: true
    telefone?: true
    usuarioAPi?: true
    chaveApi?: true
    _all?: true
  }

  export type LoginsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logins to aggregate.
     */
    where?: loginsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logins to fetch.
     */
    orderBy?: loginsOrderByWithRelationInput | loginsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: loginsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned logins
    **/
    _count?: true | LoginsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoginsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoginsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoginsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoginsMaxAggregateInputType
  }

  export type GetLoginsAggregateType<T extends LoginsAggregateArgs> = {
        [P in keyof T & keyof AggregateLogins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogins[P]>
      : GetScalarType<T[P], AggregateLogins[P]>
  }




  export type loginsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: loginsWhereInput
    orderBy?: loginsOrderByWithAggregationInput | loginsOrderByWithAggregationInput[]
    by: LoginsScalarFieldEnum[] | LoginsScalarFieldEnum
    having?: loginsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoginsCountAggregateInputType | true
    _avg?: LoginsAvgAggregateInputType
    _sum?: LoginsSumAggregateInputType
    _min?: LoginsMinAggregateInputType
    _max?: LoginsMaxAggregateInputType
  }

  export type LoginsGroupByOutputType = {
    id: number
    name: string
    user_name: string
    active: boolean
    password: string
    idperfil: number
    createdAt: Date
    updatedAt: Date
    cpf: string
    email: string
    telefone: string
    usuarioAPi: boolean
    chaveApi: string
    _count: LoginsCountAggregateOutputType | null
    _avg: LoginsAvgAggregateOutputType | null
    _sum: LoginsSumAggregateOutputType | null
    _min: LoginsMinAggregateOutputType | null
    _max: LoginsMaxAggregateOutputType | null
  }

  type GetLoginsGroupByPayload<T extends loginsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoginsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoginsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoginsGroupByOutputType[P]>
            : GetScalarType<T[P], LoginsGroupByOutputType[P]>
        }
      >
    >


  export type loginsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    user_name?: boolean
    active?: boolean
    password?: boolean
    idperfil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cpf?: boolean
    email?: boolean
    telefone?: boolean
    usuarioAPi?: boolean
    chaveApi?: boolean
    perfil?: boolean | perfilusuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logins"]>



  export type loginsSelectScalar = {
    id?: boolean
    name?: boolean
    user_name?: boolean
    active?: boolean
    password?: boolean
    idperfil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cpf?: boolean
    email?: boolean
    telefone?: boolean
    usuarioAPi?: boolean
    chaveApi?: boolean
  }

  export type loginsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "user_name" | "active" | "password" | "idperfil" | "createdAt" | "updatedAt" | "cpf" | "email" | "telefone" | "usuarioAPi" | "chaveApi", ExtArgs["result"]["logins"]>
  export type loginsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    perfil?: boolean | perfilusuarioDefaultArgs<ExtArgs>
  }

  export type $loginsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "logins"
    objects: {
      perfil: Prisma.$perfilusuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      user_name: string
      active: boolean
      password: string
      idperfil: number
      createdAt: Date
      updatedAt: Date
      cpf: string
      email: string
      telefone: string
      usuarioAPi: boolean
      chaveApi: string
    }, ExtArgs["result"]["logins"]>
    composites: {}
  }

  type loginsGetPayload<S extends boolean | null | undefined | loginsDefaultArgs> = $Result.GetResult<Prisma.$loginsPayload, S>

  type loginsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<loginsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoginsCountAggregateInputType | true
    }

  export interface loginsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['logins'], meta: { name: 'logins' } }
    /**
     * Find zero or one Logins that matches the filter.
     * @param {loginsFindUniqueArgs} args - Arguments to find a Logins
     * @example
     * // Get one Logins
     * const logins = await prisma.logins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends loginsFindUniqueArgs>(args: SelectSubset<T, loginsFindUniqueArgs<ExtArgs>>): Prisma__loginsClient<$Result.GetResult<Prisma.$loginsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Logins that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {loginsFindUniqueOrThrowArgs} args - Arguments to find a Logins
     * @example
     * // Get one Logins
     * const logins = await prisma.logins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends loginsFindUniqueOrThrowArgs>(args: SelectSubset<T, loginsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__loginsClient<$Result.GetResult<Prisma.$loginsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loginsFindFirstArgs} args - Arguments to find a Logins
     * @example
     * // Get one Logins
     * const logins = await prisma.logins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends loginsFindFirstArgs>(args?: SelectSubset<T, loginsFindFirstArgs<ExtArgs>>): Prisma__loginsClient<$Result.GetResult<Prisma.$loginsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loginsFindFirstOrThrowArgs} args - Arguments to find a Logins
     * @example
     * // Get one Logins
     * const logins = await prisma.logins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends loginsFindFirstOrThrowArgs>(args?: SelectSubset<T, loginsFindFirstOrThrowArgs<ExtArgs>>): Prisma__loginsClient<$Result.GetResult<Prisma.$loginsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loginsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logins
     * const logins = await prisma.logins.findMany()
     * 
     * // Get first 10 Logins
     * const logins = await prisma.logins.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loginsWithIdOnly = await prisma.logins.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends loginsFindManyArgs>(args?: SelectSubset<T, loginsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$loginsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Logins.
     * @param {loginsCreateArgs} args - Arguments to create a Logins.
     * @example
     * // Create one Logins
     * const Logins = await prisma.logins.create({
     *   data: {
     *     // ... data to create a Logins
     *   }
     * })
     * 
     */
    create<T extends loginsCreateArgs>(args: SelectSubset<T, loginsCreateArgs<ExtArgs>>): Prisma__loginsClient<$Result.GetResult<Prisma.$loginsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logins.
     * @param {loginsCreateManyArgs} args - Arguments to create many Logins.
     * @example
     * // Create many Logins
     * const logins = await prisma.logins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends loginsCreateManyArgs>(args?: SelectSubset<T, loginsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Logins.
     * @param {loginsDeleteArgs} args - Arguments to delete one Logins.
     * @example
     * // Delete one Logins
     * const Logins = await prisma.logins.delete({
     *   where: {
     *     // ... filter to delete one Logins
     *   }
     * })
     * 
     */
    delete<T extends loginsDeleteArgs>(args: SelectSubset<T, loginsDeleteArgs<ExtArgs>>): Prisma__loginsClient<$Result.GetResult<Prisma.$loginsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Logins.
     * @param {loginsUpdateArgs} args - Arguments to update one Logins.
     * @example
     * // Update one Logins
     * const logins = await prisma.logins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends loginsUpdateArgs>(args: SelectSubset<T, loginsUpdateArgs<ExtArgs>>): Prisma__loginsClient<$Result.GetResult<Prisma.$loginsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logins.
     * @param {loginsDeleteManyArgs} args - Arguments to filter Logins to delete.
     * @example
     * // Delete a few Logins
     * const { count } = await prisma.logins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends loginsDeleteManyArgs>(args?: SelectSubset<T, loginsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loginsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logins
     * const logins = await prisma.logins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends loginsUpdateManyArgs>(args: SelectSubset<T, loginsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Logins.
     * @param {loginsUpsertArgs} args - Arguments to update or create a Logins.
     * @example
     * // Update or create a Logins
     * const logins = await prisma.logins.upsert({
     *   create: {
     *     // ... data to create a Logins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logins we want to update
     *   }
     * })
     */
    upsert<T extends loginsUpsertArgs>(args: SelectSubset<T, loginsUpsertArgs<ExtArgs>>): Prisma__loginsClient<$Result.GetResult<Prisma.$loginsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loginsCountArgs} args - Arguments to filter Logins to count.
     * @example
     * // Count the number of Logins
     * const count = await prisma.logins.count({
     *   where: {
     *     // ... the filter for the Logins we want to count
     *   }
     * })
    **/
    count<T extends loginsCountArgs>(
      args?: Subset<T, loginsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoginsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoginsAggregateArgs>(args: Subset<T, LoginsAggregateArgs>): Prisma.PrismaPromise<GetLoginsAggregateType<T>>

    /**
     * Group by Logins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loginsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends loginsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: loginsGroupByArgs['orderBy'] }
        : { orderBy?: loginsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, loginsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoginsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the logins model
   */
  readonly fields: loginsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for logins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__loginsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    perfil<T extends perfilusuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, perfilusuarioDefaultArgs<ExtArgs>>): Prisma__perfilusuarioClient<$Result.GetResult<Prisma.$perfilusuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the logins model
   */
  interface loginsFieldRefs {
    readonly id: FieldRef<"logins", 'Int'>
    readonly name: FieldRef<"logins", 'String'>
    readonly user_name: FieldRef<"logins", 'String'>
    readonly active: FieldRef<"logins", 'Boolean'>
    readonly password: FieldRef<"logins", 'String'>
    readonly idperfil: FieldRef<"logins", 'Int'>
    readonly createdAt: FieldRef<"logins", 'DateTime'>
    readonly updatedAt: FieldRef<"logins", 'DateTime'>
    readonly cpf: FieldRef<"logins", 'String'>
    readonly email: FieldRef<"logins", 'String'>
    readonly telefone: FieldRef<"logins", 'String'>
    readonly usuarioAPi: FieldRef<"logins", 'Boolean'>
    readonly chaveApi: FieldRef<"logins", 'String'>
  }
    

  // Custom InputTypes
  /**
   * logins findUnique
   */
  export type loginsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logins
     */
    select?: loginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logins
     */
    omit?: loginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginsInclude<ExtArgs> | null
    /**
     * Filter, which logins to fetch.
     */
    where: loginsWhereUniqueInput
  }

  /**
   * logins findUniqueOrThrow
   */
  export type loginsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logins
     */
    select?: loginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logins
     */
    omit?: loginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginsInclude<ExtArgs> | null
    /**
     * Filter, which logins to fetch.
     */
    where: loginsWhereUniqueInput
  }

  /**
   * logins findFirst
   */
  export type loginsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logins
     */
    select?: loginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logins
     */
    omit?: loginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginsInclude<ExtArgs> | null
    /**
     * Filter, which logins to fetch.
     */
    where?: loginsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logins to fetch.
     */
    orderBy?: loginsOrderByWithRelationInput | loginsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logins.
     */
    cursor?: loginsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logins.
     */
    distinct?: LoginsScalarFieldEnum | LoginsScalarFieldEnum[]
  }

  /**
   * logins findFirstOrThrow
   */
  export type loginsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logins
     */
    select?: loginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logins
     */
    omit?: loginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginsInclude<ExtArgs> | null
    /**
     * Filter, which logins to fetch.
     */
    where?: loginsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logins to fetch.
     */
    orderBy?: loginsOrderByWithRelationInput | loginsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logins.
     */
    cursor?: loginsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logins.
     */
    distinct?: LoginsScalarFieldEnum | LoginsScalarFieldEnum[]
  }

  /**
   * logins findMany
   */
  export type loginsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logins
     */
    select?: loginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logins
     */
    omit?: loginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginsInclude<ExtArgs> | null
    /**
     * Filter, which logins to fetch.
     */
    where?: loginsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logins to fetch.
     */
    orderBy?: loginsOrderByWithRelationInput | loginsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing logins.
     */
    cursor?: loginsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logins.
     */
    skip?: number
    distinct?: LoginsScalarFieldEnum | LoginsScalarFieldEnum[]
  }

  /**
   * logins create
   */
  export type loginsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logins
     */
    select?: loginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logins
     */
    omit?: loginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginsInclude<ExtArgs> | null
    /**
     * The data needed to create a logins.
     */
    data: XOR<loginsCreateInput, loginsUncheckedCreateInput>
  }

  /**
   * logins createMany
   */
  export type loginsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many logins.
     */
    data: loginsCreateManyInput | loginsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * logins update
   */
  export type loginsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logins
     */
    select?: loginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logins
     */
    omit?: loginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginsInclude<ExtArgs> | null
    /**
     * The data needed to update a logins.
     */
    data: XOR<loginsUpdateInput, loginsUncheckedUpdateInput>
    /**
     * Choose, which logins to update.
     */
    where: loginsWhereUniqueInput
  }

  /**
   * logins updateMany
   */
  export type loginsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update logins.
     */
    data: XOR<loginsUpdateManyMutationInput, loginsUncheckedUpdateManyInput>
    /**
     * Filter which logins to update
     */
    where?: loginsWhereInput
    /**
     * Limit how many logins to update.
     */
    limit?: number
  }

  /**
   * logins upsert
   */
  export type loginsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logins
     */
    select?: loginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logins
     */
    omit?: loginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginsInclude<ExtArgs> | null
    /**
     * The filter to search for the logins to update in case it exists.
     */
    where: loginsWhereUniqueInput
    /**
     * In case the logins found by the `where` argument doesn't exist, create a new logins with this data.
     */
    create: XOR<loginsCreateInput, loginsUncheckedCreateInput>
    /**
     * In case the logins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<loginsUpdateInput, loginsUncheckedUpdateInput>
  }

  /**
   * logins delete
   */
  export type loginsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logins
     */
    select?: loginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logins
     */
    omit?: loginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginsInclude<ExtArgs> | null
    /**
     * Filter which logins to delete.
     */
    where: loginsWhereUniqueInput
  }

  /**
   * logins deleteMany
   */
  export type loginsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logins to delete
     */
    where?: loginsWhereInput
    /**
     * Limit how many logins to delete.
     */
    limit?: number
  }

  /**
   * logins without action
   */
  export type loginsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logins
     */
    select?: loginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logins
     */
    omit?: loginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginsInclude<ExtArgs> | null
  }


  /**
   * Model menu
   */

  export type AggregateMenu = {
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  export type MenuAvgAggregateOutputType = {
    id: number | null
    codsequencia: number | null
    idmodulo: number | null
  }

  export type MenuSumAggregateOutputType = {
    id: number | null
    codsequencia: number | null
    idmodulo: number | null
  }

  export type MenuMinAggregateOutputType = {
    id: number | null
    codsequencia: number | null
    descricao: string | null
    pagina: string | null
    rota: string | null
    idmodulo: number | null
    createdAt: Date | null
    updatedAt: Date | null
    icone: string | null
  }

  export type MenuMaxAggregateOutputType = {
    id: number | null
    codsequencia: number | null
    descricao: string | null
    pagina: string | null
    rota: string | null
    idmodulo: number | null
    createdAt: Date | null
    updatedAt: Date | null
    icone: string | null
  }

  export type MenuCountAggregateOutputType = {
    id: number
    codsequencia: number
    descricao: number
    pagina: number
    rota: number
    idmodulo: number
    createdAt: number
    updatedAt: number
    icone: number
    _all: number
  }


  export type MenuAvgAggregateInputType = {
    id?: true
    codsequencia?: true
    idmodulo?: true
  }

  export type MenuSumAggregateInputType = {
    id?: true
    codsequencia?: true
    idmodulo?: true
  }

  export type MenuMinAggregateInputType = {
    id?: true
    codsequencia?: true
    descricao?: true
    pagina?: true
    rota?: true
    idmodulo?: true
    createdAt?: true
    updatedAt?: true
    icone?: true
  }

  export type MenuMaxAggregateInputType = {
    id?: true
    codsequencia?: true
    descricao?: true
    pagina?: true
    rota?: true
    idmodulo?: true
    createdAt?: true
    updatedAt?: true
    icone?: true
  }

  export type MenuCountAggregateInputType = {
    id?: true
    codsequencia?: true
    descricao?: true
    pagina?: true
    rota?: true
    idmodulo?: true
    createdAt?: true
    updatedAt?: true
    icone?: true
    _all?: true
  }

  export type MenuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which menu to aggregate.
     */
    where?: menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menuOrderByWithRelationInput | menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned menus
    **/
    _count?: true | MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuMaxAggregateInputType
  }

  export type GetMenuAggregateType<T extends MenuAggregateArgs> = {
        [P in keyof T & keyof AggregateMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu[P]>
      : GetScalarType<T[P], AggregateMenu[P]>
  }




  export type menuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: menuWhereInput
    orderBy?: menuOrderByWithAggregationInput | menuOrderByWithAggregationInput[]
    by: MenuScalarFieldEnum[] | MenuScalarFieldEnum
    having?: menuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuCountAggregateInputType | true
    _avg?: MenuAvgAggregateInputType
    _sum?: MenuSumAggregateInputType
    _min?: MenuMinAggregateInputType
    _max?: MenuMaxAggregateInputType
  }

  export type MenuGroupByOutputType = {
    id: number
    codsequencia: number
    descricao: string
    pagina: string
    rota: string
    idmodulo: number
    createdAt: Date
    updatedAt: Date
    icone: string | null
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  type GetMenuGroupByPayload<T extends menuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuGroupByOutputType[P]>
            : GetScalarType<T[P], MenuGroupByOutputType[P]>
        }
      >
    >


  export type menuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codsequencia?: boolean
    descricao?: boolean
    pagina?: boolean
    rota?: boolean
    idmodulo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    icone?: boolean
  }, ExtArgs["result"]["menu"]>



  export type menuSelectScalar = {
    id?: boolean
    codsequencia?: boolean
    descricao?: boolean
    pagina?: boolean
    rota?: boolean
    idmodulo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    icone?: boolean
  }

  export type menuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codsequencia" | "descricao" | "pagina" | "rota" | "idmodulo" | "createdAt" | "updatedAt" | "icone", ExtArgs["result"]["menu"]>

  export type $menuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "menu"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codsequencia: number
      descricao: string
      pagina: string
      rota: string
      idmodulo: number
      createdAt: Date
      updatedAt: Date
      icone: string | null
    }, ExtArgs["result"]["menu"]>
    composites: {}
  }

  type menuGetPayload<S extends boolean | null | undefined | menuDefaultArgs> = $Result.GetResult<Prisma.$menuPayload, S>

  type menuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<menuFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenuCountAggregateInputType | true
    }

  export interface menuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['menu'], meta: { name: 'menu' } }
    /**
     * Find zero or one Menu that matches the filter.
     * @param {menuFindUniqueArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends menuFindUniqueArgs>(args: SelectSubset<T, menuFindUniqueArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Menu that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {menuFindUniqueOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends menuFindUniqueOrThrowArgs>(args: SelectSubset<T, menuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuFindFirstArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends menuFindFirstArgs>(args?: SelectSubset<T, menuFindFirstArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuFindFirstOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends menuFindFirstOrThrowArgs>(args?: SelectSubset<T, menuFindFirstOrThrowArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menu.findMany()
     * 
     * // Get first 10 Menus
     * const menus = await prisma.menu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuWithIdOnly = await prisma.menu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends menuFindManyArgs>(args?: SelectSubset<T, menuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Menu.
     * @param {menuCreateArgs} args - Arguments to create a Menu.
     * @example
     * // Create one Menu
     * const Menu = await prisma.menu.create({
     *   data: {
     *     // ... data to create a Menu
     *   }
     * })
     * 
     */
    create<T extends menuCreateArgs>(args: SelectSubset<T, menuCreateArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Menus.
     * @param {menuCreateManyArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends menuCreateManyArgs>(args?: SelectSubset<T, menuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Menu.
     * @param {menuDeleteArgs} args - Arguments to delete one Menu.
     * @example
     * // Delete one Menu
     * const Menu = await prisma.menu.delete({
     *   where: {
     *     // ... filter to delete one Menu
     *   }
     * })
     * 
     */
    delete<T extends menuDeleteArgs>(args: SelectSubset<T, menuDeleteArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Menu.
     * @param {menuUpdateArgs} args - Arguments to update one Menu.
     * @example
     * // Update one Menu
     * const menu = await prisma.menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends menuUpdateArgs>(args: SelectSubset<T, menuUpdateArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Menus.
     * @param {menuDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends menuDeleteManyArgs>(args?: SelectSubset<T, menuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends menuUpdateManyArgs>(args: SelectSubset<T, menuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Menu.
     * @param {menuUpsertArgs} args - Arguments to update or create a Menu.
     * @example
     * // Update or create a Menu
     * const menu = await prisma.menu.upsert({
     *   create: {
     *     // ... data to create a Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu we want to update
     *   }
     * })
     */
    upsert<T extends menuUpsertArgs>(args: SelectSubset<T, menuUpsertArgs<ExtArgs>>): Prisma__menuClient<$Result.GetResult<Prisma.$menuPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menu.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
    **/
    count<T extends menuCountArgs>(
      args?: Subset<T, menuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuAggregateArgs>(args: Subset<T, MenuAggregateArgs>): Prisma.PrismaPromise<GetMenuAggregateType<T>>

    /**
     * Group by Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends menuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: menuGroupByArgs['orderBy'] }
        : { orderBy?: menuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, menuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the menu model
   */
  readonly fields: menuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__menuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the menu model
   */
  interface menuFieldRefs {
    readonly id: FieldRef<"menu", 'Int'>
    readonly codsequencia: FieldRef<"menu", 'Int'>
    readonly descricao: FieldRef<"menu", 'String'>
    readonly pagina: FieldRef<"menu", 'String'>
    readonly rota: FieldRef<"menu", 'String'>
    readonly idmodulo: FieldRef<"menu", 'Int'>
    readonly createdAt: FieldRef<"menu", 'DateTime'>
    readonly updatedAt: FieldRef<"menu", 'DateTime'>
    readonly icone: FieldRef<"menu", 'String'>
  }
    

  // Custom InputTypes
  /**
   * menu findUnique
   */
  export type menuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * Filter, which menu to fetch.
     */
    where: menuWhereUniqueInput
  }

  /**
   * menu findUniqueOrThrow
   */
  export type menuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * Filter, which menu to fetch.
     */
    where: menuWhereUniqueInput
  }

  /**
   * menu findFirst
   */
  export type menuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * Filter, which menu to fetch.
     */
    where?: menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menuOrderByWithRelationInput | menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for menus.
     */
    cursor?: menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * menu findFirstOrThrow
   */
  export type menuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * Filter, which menu to fetch.
     */
    where?: menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menuOrderByWithRelationInput | menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for menus.
     */
    cursor?: menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * menu findMany
   */
  export type menuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * Filter, which menus to fetch.
     */
    where?: menuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menuOrderByWithRelationInput | menuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing menus.
     */
    cursor?: menuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * menu create
   */
  export type menuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * The data needed to create a menu.
     */
    data: XOR<menuCreateInput, menuUncheckedCreateInput>
  }

  /**
   * menu createMany
   */
  export type menuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many menus.
     */
    data: menuCreateManyInput | menuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * menu update
   */
  export type menuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * The data needed to update a menu.
     */
    data: XOR<menuUpdateInput, menuUncheckedUpdateInput>
    /**
     * Choose, which menu to update.
     */
    where: menuWhereUniqueInput
  }

  /**
   * menu updateMany
   */
  export type menuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update menus.
     */
    data: XOR<menuUpdateManyMutationInput, menuUncheckedUpdateManyInput>
    /**
     * Filter which menus to update
     */
    where?: menuWhereInput
    /**
     * Limit how many menus to update.
     */
    limit?: number
  }

  /**
   * menu upsert
   */
  export type menuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * The filter to search for the menu to update in case it exists.
     */
    where: menuWhereUniqueInput
    /**
     * In case the menu found by the `where` argument doesn't exist, create a new menu with this data.
     */
    create: XOR<menuCreateInput, menuUncheckedCreateInput>
    /**
     * In case the menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<menuUpdateInput, menuUncheckedUpdateInput>
  }

  /**
   * menu delete
   */
  export type menuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
    /**
     * Filter which menu to delete.
     */
    where: menuWhereUniqueInput
  }

  /**
   * menu deleteMany
   */
  export type menuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which menus to delete
     */
    where?: menuWhereInput
    /**
     * Limit how many menus to delete.
     */
    limit?: number
  }

  /**
   * menu without action
   */
  export type menuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menu
     */
    select?: menuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menu
     */
    omit?: menuOmit<ExtArgs> | null
  }


  /**
   * Model modulos
   */

  export type AggregateModulos = {
    _count: ModulosCountAggregateOutputType | null
    _avg: ModulosAvgAggregateOutputType | null
    _sum: ModulosSumAggregateOutputType | null
    _min: ModulosMinAggregateOutputType | null
    _max: ModulosMaxAggregateOutputType | null
  }

  export type ModulosAvgAggregateOutputType = {
    id: number | null
  }

  export type ModulosSumAggregateOutputType = {
    id: number | null
  }

  export type ModulosMinAggregateOutputType = {
    id: number | null
    desc_modulo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModulosMaxAggregateOutputType = {
    id: number | null
    desc_modulo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModulosCountAggregateOutputType = {
    id: number
    desc_modulo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModulosAvgAggregateInputType = {
    id?: true
  }

  export type ModulosSumAggregateInputType = {
    id?: true
  }

  export type ModulosMinAggregateInputType = {
    id?: true
    desc_modulo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModulosMaxAggregateInputType = {
    id?: true
    desc_modulo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModulosCountAggregateInputType = {
    id?: true
    desc_modulo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModulosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which modulos to aggregate.
     */
    where?: modulosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modulos to fetch.
     */
    orderBy?: modulosOrderByWithRelationInput | modulosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: modulosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned modulos
    **/
    _count?: true | ModulosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModulosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModulosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModulosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModulosMaxAggregateInputType
  }

  export type GetModulosAggregateType<T extends ModulosAggregateArgs> = {
        [P in keyof T & keyof AggregateModulos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModulos[P]>
      : GetScalarType<T[P], AggregateModulos[P]>
  }




  export type modulosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: modulosWhereInput
    orderBy?: modulosOrderByWithAggregationInput | modulosOrderByWithAggregationInput[]
    by: ModulosScalarFieldEnum[] | ModulosScalarFieldEnum
    having?: modulosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModulosCountAggregateInputType | true
    _avg?: ModulosAvgAggregateInputType
    _sum?: ModulosSumAggregateInputType
    _min?: ModulosMinAggregateInputType
    _max?: ModulosMaxAggregateInputType
  }

  export type ModulosGroupByOutputType = {
    id: number
    desc_modulo: string
    createdAt: Date
    updatedAt: Date
    _count: ModulosCountAggregateOutputType | null
    _avg: ModulosAvgAggregateOutputType | null
    _sum: ModulosSumAggregateOutputType | null
    _min: ModulosMinAggregateOutputType | null
    _max: ModulosMaxAggregateOutputType | null
  }

  type GetModulosGroupByPayload<T extends modulosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModulosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModulosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModulosGroupByOutputType[P]>
            : GetScalarType<T[P], ModulosGroupByOutputType[P]>
        }
      >
    >


  export type modulosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    desc_modulo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    perfilXmodulos?: boolean | modulos$perfilXmodulosArgs<ExtArgs>
    _count?: boolean | ModulosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modulos"]>



  export type modulosSelectScalar = {
    id?: boolean
    desc_modulo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type modulosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "desc_modulo" | "createdAt" | "updatedAt", ExtArgs["result"]["modulos"]>
  export type modulosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    perfilXmodulos?: boolean | modulos$perfilXmodulosArgs<ExtArgs>
    _count?: boolean | ModulosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $modulosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "modulos"
    objects: {
      perfilXmodulos: Prisma.$perfil_moduloPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      desc_modulo: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["modulos"]>
    composites: {}
  }

  type modulosGetPayload<S extends boolean | null | undefined | modulosDefaultArgs> = $Result.GetResult<Prisma.$modulosPayload, S>

  type modulosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<modulosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModulosCountAggregateInputType | true
    }

  export interface modulosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['modulos'], meta: { name: 'modulos' } }
    /**
     * Find zero or one Modulos that matches the filter.
     * @param {modulosFindUniqueArgs} args - Arguments to find a Modulos
     * @example
     * // Get one Modulos
     * const modulos = await prisma.modulos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends modulosFindUniqueArgs>(args: SelectSubset<T, modulosFindUniqueArgs<ExtArgs>>): Prisma__modulosClient<$Result.GetResult<Prisma.$modulosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Modulos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {modulosFindUniqueOrThrowArgs} args - Arguments to find a Modulos
     * @example
     * // Get one Modulos
     * const modulos = await prisma.modulos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends modulosFindUniqueOrThrowArgs>(args: SelectSubset<T, modulosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__modulosClient<$Result.GetResult<Prisma.$modulosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Modulos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulosFindFirstArgs} args - Arguments to find a Modulos
     * @example
     * // Get one Modulos
     * const modulos = await prisma.modulos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends modulosFindFirstArgs>(args?: SelectSubset<T, modulosFindFirstArgs<ExtArgs>>): Prisma__modulosClient<$Result.GetResult<Prisma.$modulosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Modulos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulosFindFirstOrThrowArgs} args - Arguments to find a Modulos
     * @example
     * // Get one Modulos
     * const modulos = await prisma.modulos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends modulosFindFirstOrThrowArgs>(args?: SelectSubset<T, modulosFindFirstOrThrowArgs<ExtArgs>>): Prisma__modulosClient<$Result.GetResult<Prisma.$modulosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Modulos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modulos
     * const modulos = await prisma.modulos.findMany()
     * 
     * // Get first 10 Modulos
     * const modulos = await prisma.modulos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modulosWithIdOnly = await prisma.modulos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends modulosFindManyArgs>(args?: SelectSubset<T, modulosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modulosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Modulos.
     * @param {modulosCreateArgs} args - Arguments to create a Modulos.
     * @example
     * // Create one Modulos
     * const Modulos = await prisma.modulos.create({
     *   data: {
     *     // ... data to create a Modulos
     *   }
     * })
     * 
     */
    create<T extends modulosCreateArgs>(args: SelectSubset<T, modulosCreateArgs<ExtArgs>>): Prisma__modulosClient<$Result.GetResult<Prisma.$modulosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Modulos.
     * @param {modulosCreateManyArgs} args - Arguments to create many Modulos.
     * @example
     * // Create many Modulos
     * const modulos = await prisma.modulos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends modulosCreateManyArgs>(args?: SelectSubset<T, modulosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Modulos.
     * @param {modulosDeleteArgs} args - Arguments to delete one Modulos.
     * @example
     * // Delete one Modulos
     * const Modulos = await prisma.modulos.delete({
     *   where: {
     *     // ... filter to delete one Modulos
     *   }
     * })
     * 
     */
    delete<T extends modulosDeleteArgs>(args: SelectSubset<T, modulosDeleteArgs<ExtArgs>>): Prisma__modulosClient<$Result.GetResult<Prisma.$modulosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Modulos.
     * @param {modulosUpdateArgs} args - Arguments to update one Modulos.
     * @example
     * // Update one Modulos
     * const modulos = await prisma.modulos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends modulosUpdateArgs>(args: SelectSubset<T, modulosUpdateArgs<ExtArgs>>): Prisma__modulosClient<$Result.GetResult<Prisma.$modulosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Modulos.
     * @param {modulosDeleteManyArgs} args - Arguments to filter Modulos to delete.
     * @example
     * // Delete a few Modulos
     * const { count } = await prisma.modulos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends modulosDeleteManyArgs>(args?: SelectSubset<T, modulosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modulos
     * const modulos = await prisma.modulos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends modulosUpdateManyArgs>(args: SelectSubset<T, modulosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Modulos.
     * @param {modulosUpsertArgs} args - Arguments to update or create a Modulos.
     * @example
     * // Update or create a Modulos
     * const modulos = await prisma.modulos.upsert({
     *   create: {
     *     // ... data to create a Modulos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Modulos we want to update
     *   }
     * })
     */
    upsert<T extends modulosUpsertArgs>(args: SelectSubset<T, modulosUpsertArgs<ExtArgs>>): Prisma__modulosClient<$Result.GetResult<Prisma.$modulosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulosCountArgs} args - Arguments to filter Modulos to count.
     * @example
     * // Count the number of Modulos
     * const count = await prisma.modulos.count({
     *   where: {
     *     // ... the filter for the Modulos we want to count
     *   }
     * })
    **/
    count<T extends modulosCountArgs>(
      args?: Subset<T, modulosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModulosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModulosAggregateArgs>(args: Subset<T, ModulosAggregateArgs>): Prisma.PrismaPromise<GetModulosAggregateType<T>>

    /**
     * Group by Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends modulosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: modulosGroupByArgs['orderBy'] }
        : { orderBy?: modulosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, modulosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModulosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the modulos model
   */
  readonly fields: modulosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for modulos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__modulosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    perfilXmodulos<T extends modulos$perfilXmodulosArgs<ExtArgs> = {}>(args?: Subset<T, modulos$perfilXmodulosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$perfil_moduloPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the modulos model
   */
  interface modulosFieldRefs {
    readonly id: FieldRef<"modulos", 'Int'>
    readonly desc_modulo: FieldRef<"modulos", 'String'>
    readonly createdAt: FieldRef<"modulos", 'DateTime'>
    readonly updatedAt: FieldRef<"modulos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * modulos findUnique
   */
  export type modulosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulos
     */
    select?: modulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modulos
     */
    omit?: modulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulosInclude<ExtArgs> | null
    /**
     * Filter, which modulos to fetch.
     */
    where: modulosWhereUniqueInput
  }

  /**
   * modulos findUniqueOrThrow
   */
  export type modulosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulos
     */
    select?: modulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modulos
     */
    omit?: modulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulosInclude<ExtArgs> | null
    /**
     * Filter, which modulos to fetch.
     */
    where: modulosWhereUniqueInput
  }

  /**
   * modulos findFirst
   */
  export type modulosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulos
     */
    select?: modulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modulos
     */
    omit?: modulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulosInclude<ExtArgs> | null
    /**
     * Filter, which modulos to fetch.
     */
    where?: modulosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modulos to fetch.
     */
    orderBy?: modulosOrderByWithRelationInput | modulosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for modulos.
     */
    cursor?: modulosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of modulos.
     */
    distinct?: ModulosScalarFieldEnum | ModulosScalarFieldEnum[]
  }

  /**
   * modulos findFirstOrThrow
   */
  export type modulosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulos
     */
    select?: modulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modulos
     */
    omit?: modulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulosInclude<ExtArgs> | null
    /**
     * Filter, which modulos to fetch.
     */
    where?: modulosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modulos to fetch.
     */
    orderBy?: modulosOrderByWithRelationInput | modulosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for modulos.
     */
    cursor?: modulosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of modulos.
     */
    distinct?: ModulosScalarFieldEnum | ModulosScalarFieldEnum[]
  }

  /**
   * modulos findMany
   */
  export type modulosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulos
     */
    select?: modulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modulos
     */
    omit?: modulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulosInclude<ExtArgs> | null
    /**
     * Filter, which modulos to fetch.
     */
    where?: modulosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of modulos to fetch.
     */
    orderBy?: modulosOrderByWithRelationInput | modulosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing modulos.
     */
    cursor?: modulosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` modulos.
     */
    skip?: number
    distinct?: ModulosScalarFieldEnum | ModulosScalarFieldEnum[]
  }

  /**
   * modulos create
   */
  export type modulosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulos
     */
    select?: modulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modulos
     */
    omit?: modulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulosInclude<ExtArgs> | null
    /**
     * The data needed to create a modulos.
     */
    data: XOR<modulosCreateInput, modulosUncheckedCreateInput>
  }

  /**
   * modulos createMany
   */
  export type modulosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many modulos.
     */
    data: modulosCreateManyInput | modulosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * modulos update
   */
  export type modulosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulos
     */
    select?: modulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modulos
     */
    omit?: modulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulosInclude<ExtArgs> | null
    /**
     * The data needed to update a modulos.
     */
    data: XOR<modulosUpdateInput, modulosUncheckedUpdateInput>
    /**
     * Choose, which modulos to update.
     */
    where: modulosWhereUniqueInput
  }

  /**
   * modulos updateMany
   */
  export type modulosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update modulos.
     */
    data: XOR<modulosUpdateManyMutationInput, modulosUncheckedUpdateManyInput>
    /**
     * Filter which modulos to update
     */
    where?: modulosWhereInput
    /**
     * Limit how many modulos to update.
     */
    limit?: number
  }

  /**
   * modulos upsert
   */
  export type modulosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulos
     */
    select?: modulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modulos
     */
    omit?: modulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulosInclude<ExtArgs> | null
    /**
     * The filter to search for the modulos to update in case it exists.
     */
    where: modulosWhereUniqueInput
    /**
     * In case the modulos found by the `where` argument doesn't exist, create a new modulos with this data.
     */
    create: XOR<modulosCreateInput, modulosUncheckedCreateInput>
    /**
     * In case the modulos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<modulosUpdateInput, modulosUncheckedUpdateInput>
  }

  /**
   * modulos delete
   */
  export type modulosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulos
     */
    select?: modulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modulos
     */
    omit?: modulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulosInclude<ExtArgs> | null
    /**
     * Filter which modulos to delete.
     */
    where: modulosWhereUniqueInput
  }

  /**
   * modulos deleteMany
   */
  export type modulosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which modulos to delete
     */
    where?: modulosWhereInput
    /**
     * Limit how many modulos to delete.
     */
    limit?: number
  }

  /**
   * modulos.perfilXmodulos
   */
  export type modulos$perfilXmodulosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfil_modulo
     */
    select?: perfil_moduloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfil_modulo
     */
    omit?: perfil_moduloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfil_moduloInclude<ExtArgs> | null
    where?: perfil_moduloWhereInput
    orderBy?: perfil_moduloOrderByWithRelationInput | perfil_moduloOrderByWithRelationInput[]
    cursor?: perfil_moduloWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Perfil_moduloScalarFieldEnum | Perfil_moduloScalarFieldEnum[]
  }

  /**
   * modulos without action
   */
  export type modulosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modulos
     */
    select?: modulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modulos
     */
    omit?: modulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulosInclude<ExtArgs> | null
  }


  /**
   * Model perfil_modulo
   */

  export type AggregatePerfil_modulo = {
    _count: Perfil_moduloCountAggregateOutputType | null
    _avg: Perfil_moduloAvgAggregateOutputType | null
    _sum: Perfil_moduloSumAggregateOutputType | null
    _min: Perfil_moduloMinAggregateOutputType | null
    _max: Perfil_moduloMaxAggregateOutputType | null
  }

  export type Perfil_moduloAvgAggregateOutputType = {
    id: number | null
    idperfil: number | null
    idmodulo: number | null
  }

  export type Perfil_moduloSumAggregateOutputType = {
    id: number | null
    idperfil: number | null
    idmodulo: number | null
  }

  export type Perfil_moduloMinAggregateOutputType = {
    id: number | null
    idperfil: number | null
    idmodulo: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Perfil_moduloMaxAggregateOutputType = {
    id: number | null
    idperfil: number | null
    idmodulo: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Perfil_moduloCountAggregateOutputType = {
    id: number
    idperfil: number
    idmodulo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Perfil_moduloAvgAggregateInputType = {
    id?: true
    idperfil?: true
    idmodulo?: true
  }

  export type Perfil_moduloSumAggregateInputType = {
    id?: true
    idperfil?: true
    idmodulo?: true
  }

  export type Perfil_moduloMinAggregateInputType = {
    id?: true
    idperfil?: true
    idmodulo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Perfil_moduloMaxAggregateInputType = {
    id?: true
    idperfil?: true
    idmodulo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Perfil_moduloCountAggregateInputType = {
    id?: true
    idperfil?: true
    idmodulo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Perfil_moduloAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which perfil_modulo to aggregate.
     */
    where?: perfil_moduloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of perfil_modulos to fetch.
     */
    orderBy?: perfil_moduloOrderByWithRelationInput | perfil_moduloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: perfil_moduloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` perfil_modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` perfil_modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned perfil_modulos
    **/
    _count?: true | Perfil_moduloCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Perfil_moduloAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Perfil_moduloSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Perfil_moduloMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Perfil_moduloMaxAggregateInputType
  }

  export type GetPerfil_moduloAggregateType<T extends Perfil_moduloAggregateArgs> = {
        [P in keyof T & keyof AggregatePerfil_modulo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerfil_modulo[P]>
      : GetScalarType<T[P], AggregatePerfil_modulo[P]>
  }




  export type perfil_moduloGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: perfil_moduloWhereInput
    orderBy?: perfil_moduloOrderByWithAggregationInput | perfil_moduloOrderByWithAggregationInput[]
    by: Perfil_moduloScalarFieldEnum[] | Perfil_moduloScalarFieldEnum
    having?: perfil_moduloScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Perfil_moduloCountAggregateInputType | true
    _avg?: Perfil_moduloAvgAggregateInputType
    _sum?: Perfil_moduloSumAggregateInputType
    _min?: Perfil_moduloMinAggregateInputType
    _max?: Perfil_moduloMaxAggregateInputType
  }

  export type Perfil_moduloGroupByOutputType = {
    id: number
    idperfil: number
    idmodulo: number
    createdAt: Date
    updatedAt: Date
    _count: Perfil_moduloCountAggregateOutputType | null
    _avg: Perfil_moduloAvgAggregateOutputType | null
    _sum: Perfil_moduloSumAggregateOutputType | null
    _min: Perfil_moduloMinAggregateOutputType | null
    _max: Perfil_moduloMaxAggregateOutputType | null
  }

  type GetPerfil_moduloGroupByPayload<T extends perfil_moduloGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Perfil_moduloGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Perfil_moduloGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Perfil_moduloGroupByOutputType[P]>
            : GetScalarType<T[P], Perfil_moduloGroupByOutputType[P]>
        }
      >
    >


  export type perfil_moduloSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idperfil?: boolean
    idmodulo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    perfil?: boolean | perfilusuarioDefaultArgs<ExtArgs>
    modulo?: boolean | modulosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["perfil_modulo"]>



  export type perfil_moduloSelectScalar = {
    id?: boolean
    idperfil?: boolean
    idmodulo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type perfil_moduloOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idperfil" | "idmodulo" | "createdAt" | "updatedAt", ExtArgs["result"]["perfil_modulo"]>
  export type perfil_moduloInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    perfil?: boolean | perfilusuarioDefaultArgs<ExtArgs>
    modulo?: boolean | modulosDefaultArgs<ExtArgs>
  }

  export type $perfil_moduloPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "perfil_modulo"
    objects: {
      perfil: Prisma.$perfilusuarioPayload<ExtArgs>
      modulo: Prisma.$modulosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idperfil: number
      idmodulo: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["perfil_modulo"]>
    composites: {}
  }

  type perfil_moduloGetPayload<S extends boolean | null | undefined | perfil_moduloDefaultArgs> = $Result.GetResult<Prisma.$perfil_moduloPayload, S>

  type perfil_moduloCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<perfil_moduloFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Perfil_moduloCountAggregateInputType | true
    }

  export interface perfil_moduloDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['perfil_modulo'], meta: { name: 'perfil_modulo' } }
    /**
     * Find zero or one Perfil_modulo that matches the filter.
     * @param {perfil_moduloFindUniqueArgs} args - Arguments to find a Perfil_modulo
     * @example
     * // Get one Perfil_modulo
     * const perfil_modulo = await prisma.perfil_modulo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends perfil_moduloFindUniqueArgs>(args: SelectSubset<T, perfil_moduloFindUniqueArgs<ExtArgs>>): Prisma__perfil_moduloClient<$Result.GetResult<Prisma.$perfil_moduloPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Perfil_modulo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {perfil_moduloFindUniqueOrThrowArgs} args - Arguments to find a Perfil_modulo
     * @example
     * // Get one Perfil_modulo
     * const perfil_modulo = await prisma.perfil_modulo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends perfil_moduloFindUniqueOrThrowArgs>(args: SelectSubset<T, perfil_moduloFindUniqueOrThrowArgs<ExtArgs>>): Prisma__perfil_moduloClient<$Result.GetResult<Prisma.$perfil_moduloPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Perfil_modulo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {perfil_moduloFindFirstArgs} args - Arguments to find a Perfil_modulo
     * @example
     * // Get one Perfil_modulo
     * const perfil_modulo = await prisma.perfil_modulo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends perfil_moduloFindFirstArgs>(args?: SelectSubset<T, perfil_moduloFindFirstArgs<ExtArgs>>): Prisma__perfil_moduloClient<$Result.GetResult<Prisma.$perfil_moduloPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Perfil_modulo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {perfil_moduloFindFirstOrThrowArgs} args - Arguments to find a Perfil_modulo
     * @example
     * // Get one Perfil_modulo
     * const perfil_modulo = await prisma.perfil_modulo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends perfil_moduloFindFirstOrThrowArgs>(args?: SelectSubset<T, perfil_moduloFindFirstOrThrowArgs<ExtArgs>>): Prisma__perfil_moduloClient<$Result.GetResult<Prisma.$perfil_moduloPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Perfil_modulos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {perfil_moduloFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Perfil_modulos
     * const perfil_modulos = await prisma.perfil_modulo.findMany()
     * 
     * // Get first 10 Perfil_modulos
     * const perfil_modulos = await prisma.perfil_modulo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const perfil_moduloWithIdOnly = await prisma.perfil_modulo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends perfil_moduloFindManyArgs>(args?: SelectSubset<T, perfil_moduloFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$perfil_moduloPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Perfil_modulo.
     * @param {perfil_moduloCreateArgs} args - Arguments to create a Perfil_modulo.
     * @example
     * // Create one Perfil_modulo
     * const Perfil_modulo = await prisma.perfil_modulo.create({
     *   data: {
     *     // ... data to create a Perfil_modulo
     *   }
     * })
     * 
     */
    create<T extends perfil_moduloCreateArgs>(args: SelectSubset<T, perfil_moduloCreateArgs<ExtArgs>>): Prisma__perfil_moduloClient<$Result.GetResult<Prisma.$perfil_moduloPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Perfil_modulos.
     * @param {perfil_moduloCreateManyArgs} args - Arguments to create many Perfil_modulos.
     * @example
     * // Create many Perfil_modulos
     * const perfil_modulo = await prisma.perfil_modulo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends perfil_moduloCreateManyArgs>(args?: SelectSubset<T, perfil_moduloCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Perfil_modulo.
     * @param {perfil_moduloDeleteArgs} args - Arguments to delete one Perfil_modulo.
     * @example
     * // Delete one Perfil_modulo
     * const Perfil_modulo = await prisma.perfil_modulo.delete({
     *   where: {
     *     // ... filter to delete one Perfil_modulo
     *   }
     * })
     * 
     */
    delete<T extends perfil_moduloDeleteArgs>(args: SelectSubset<T, perfil_moduloDeleteArgs<ExtArgs>>): Prisma__perfil_moduloClient<$Result.GetResult<Prisma.$perfil_moduloPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Perfil_modulo.
     * @param {perfil_moduloUpdateArgs} args - Arguments to update one Perfil_modulo.
     * @example
     * // Update one Perfil_modulo
     * const perfil_modulo = await prisma.perfil_modulo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends perfil_moduloUpdateArgs>(args: SelectSubset<T, perfil_moduloUpdateArgs<ExtArgs>>): Prisma__perfil_moduloClient<$Result.GetResult<Prisma.$perfil_moduloPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Perfil_modulos.
     * @param {perfil_moduloDeleteManyArgs} args - Arguments to filter Perfil_modulos to delete.
     * @example
     * // Delete a few Perfil_modulos
     * const { count } = await prisma.perfil_modulo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends perfil_moduloDeleteManyArgs>(args?: SelectSubset<T, perfil_moduloDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Perfil_modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {perfil_moduloUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Perfil_modulos
     * const perfil_modulo = await prisma.perfil_modulo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends perfil_moduloUpdateManyArgs>(args: SelectSubset<T, perfil_moduloUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Perfil_modulo.
     * @param {perfil_moduloUpsertArgs} args - Arguments to update or create a Perfil_modulo.
     * @example
     * // Update or create a Perfil_modulo
     * const perfil_modulo = await prisma.perfil_modulo.upsert({
     *   create: {
     *     // ... data to create a Perfil_modulo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Perfil_modulo we want to update
     *   }
     * })
     */
    upsert<T extends perfil_moduloUpsertArgs>(args: SelectSubset<T, perfil_moduloUpsertArgs<ExtArgs>>): Prisma__perfil_moduloClient<$Result.GetResult<Prisma.$perfil_moduloPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Perfil_modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {perfil_moduloCountArgs} args - Arguments to filter Perfil_modulos to count.
     * @example
     * // Count the number of Perfil_modulos
     * const count = await prisma.perfil_modulo.count({
     *   where: {
     *     // ... the filter for the Perfil_modulos we want to count
     *   }
     * })
    **/
    count<T extends perfil_moduloCountArgs>(
      args?: Subset<T, perfil_moduloCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Perfil_moduloCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Perfil_modulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Perfil_moduloAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Perfil_moduloAggregateArgs>(args: Subset<T, Perfil_moduloAggregateArgs>): Prisma.PrismaPromise<GetPerfil_moduloAggregateType<T>>

    /**
     * Group by Perfil_modulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {perfil_moduloGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends perfil_moduloGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: perfil_moduloGroupByArgs['orderBy'] }
        : { orderBy?: perfil_moduloGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, perfil_moduloGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerfil_moduloGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the perfil_modulo model
   */
  readonly fields: perfil_moduloFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for perfil_modulo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__perfil_moduloClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    perfil<T extends perfilusuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, perfilusuarioDefaultArgs<ExtArgs>>): Prisma__perfilusuarioClient<$Result.GetResult<Prisma.$perfilusuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    modulo<T extends modulosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, modulosDefaultArgs<ExtArgs>>): Prisma__modulosClient<$Result.GetResult<Prisma.$modulosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the perfil_modulo model
   */
  interface perfil_moduloFieldRefs {
    readonly id: FieldRef<"perfil_modulo", 'Int'>
    readonly idperfil: FieldRef<"perfil_modulo", 'Int'>
    readonly idmodulo: FieldRef<"perfil_modulo", 'Int'>
    readonly createdAt: FieldRef<"perfil_modulo", 'DateTime'>
    readonly updatedAt: FieldRef<"perfil_modulo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * perfil_modulo findUnique
   */
  export type perfil_moduloFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfil_modulo
     */
    select?: perfil_moduloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfil_modulo
     */
    omit?: perfil_moduloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfil_moduloInclude<ExtArgs> | null
    /**
     * Filter, which perfil_modulo to fetch.
     */
    where: perfil_moduloWhereUniqueInput
  }

  /**
   * perfil_modulo findUniqueOrThrow
   */
  export type perfil_moduloFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfil_modulo
     */
    select?: perfil_moduloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfil_modulo
     */
    omit?: perfil_moduloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfil_moduloInclude<ExtArgs> | null
    /**
     * Filter, which perfil_modulo to fetch.
     */
    where: perfil_moduloWhereUniqueInput
  }

  /**
   * perfil_modulo findFirst
   */
  export type perfil_moduloFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfil_modulo
     */
    select?: perfil_moduloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfil_modulo
     */
    omit?: perfil_moduloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfil_moduloInclude<ExtArgs> | null
    /**
     * Filter, which perfil_modulo to fetch.
     */
    where?: perfil_moduloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of perfil_modulos to fetch.
     */
    orderBy?: perfil_moduloOrderByWithRelationInput | perfil_moduloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for perfil_modulos.
     */
    cursor?: perfil_moduloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` perfil_modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` perfil_modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of perfil_modulos.
     */
    distinct?: Perfil_moduloScalarFieldEnum | Perfil_moduloScalarFieldEnum[]
  }

  /**
   * perfil_modulo findFirstOrThrow
   */
  export type perfil_moduloFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfil_modulo
     */
    select?: perfil_moduloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfil_modulo
     */
    omit?: perfil_moduloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfil_moduloInclude<ExtArgs> | null
    /**
     * Filter, which perfil_modulo to fetch.
     */
    where?: perfil_moduloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of perfil_modulos to fetch.
     */
    orderBy?: perfil_moduloOrderByWithRelationInput | perfil_moduloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for perfil_modulos.
     */
    cursor?: perfil_moduloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` perfil_modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` perfil_modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of perfil_modulos.
     */
    distinct?: Perfil_moduloScalarFieldEnum | Perfil_moduloScalarFieldEnum[]
  }

  /**
   * perfil_modulo findMany
   */
  export type perfil_moduloFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfil_modulo
     */
    select?: perfil_moduloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfil_modulo
     */
    omit?: perfil_moduloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfil_moduloInclude<ExtArgs> | null
    /**
     * Filter, which perfil_modulos to fetch.
     */
    where?: perfil_moduloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of perfil_modulos to fetch.
     */
    orderBy?: perfil_moduloOrderByWithRelationInput | perfil_moduloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing perfil_modulos.
     */
    cursor?: perfil_moduloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` perfil_modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` perfil_modulos.
     */
    skip?: number
    distinct?: Perfil_moduloScalarFieldEnum | Perfil_moduloScalarFieldEnum[]
  }

  /**
   * perfil_modulo create
   */
  export type perfil_moduloCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfil_modulo
     */
    select?: perfil_moduloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfil_modulo
     */
    omit?: perfil_moduloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfil_moduloInclude<ExtArgs> | null
    /**
     * The data needed to create a perfil_modulo.
     */
    data: XOR<perfil_moduloCreateInput, perfil_moduloUncheckedCreateInput>
  }

  /**
   * perfil_modulo createMany
   */
  export type perfil_moduloCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many perfil_modulos.
     */
    data: perfil_moduloCreateManyInput | perfil_moduloCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * perfil_modulo update
   */
  export type perfil_moduloUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfil_modulo
     */
    select?: perfil_moduloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfil_modulo
     */
    omit?: perfil_moduloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfil_moduloInclude<ExtArgs> | null
    /**
     * The data needed to update a perfil_modulo.
     */
    data: XOR<perfil_moduloUpdateInput, perfil_moduloUncheckedUpdateInput>
    /**
     * Choose, which perfil_modulo to update.
     */
    where: perfil_moduloWhereUniqueInput
  }

  /**
   * perfil_modulo updateMany
   */
  export type perfil_moduloUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update perfil_modulos.
     */
    data: XOR<perfil_moduloUpdateManyMutationInput, perfil_moduloUncheckedUpdateManyInput>
    /**
     * Filter which perfil_modulos to update
     */
    where?: perfil_moduloWhereInput
    /**
     * Limit how many perfil_modulos to update.
     */
    limit?: number
  }

  /**
   * perfil_modulo upsert
   */
  export type perfil_moduloUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfil_modulo
     */
    select?: perfil_moduloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfil_modulo
     */
    omit?: perfil_moduloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfil_moduloInclude<ExtArgs> | null
    /**
     * The filter to search for the perfil_modulo to update in case it exists.
     */
    where: perfil_moduloWhereUniqueInput
    /**
     * In case the perfil_modulo found by the `where` argument doesn't exist, create a new perfil_modulo with this data.
     */
    create: XOR<perfil_moduloCreateInput, perfil_moduloUncheckedCreateInput>
    /**
     * In case the perfil_modulo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<perfil_moduloUpdateInput, perfil_moduloUncheckedUpdateInput>
  }

  /**
   * perfil_modulo delete
   */
  export type perfil_moduloDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfil_modulo
     */
    select?: perfil_moduloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfil_modulo
     */
    omit?: perfil_moduloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfil_moduloInclude<ExtArgs> | null
    /**
     * Filter which perfil_modulo to delete.
     */
    where: perfil_moduloWhereUniqueInput
  }

  /**
   * perfil_modulo deleteMany
   */
  export type perfil_moduloDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which perfil_modulos to delete
     */
    where?: perfil_moduloWhereInput
    /**
     * Limit how many perfil_modulos to delete.
     */
    limit?: number
  }

  /**
   * perfil_modulo without action
   */
  export type perfil_moduloDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfil_modulo
     */
    select?: perfil_moduloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfil_modulo
     */
    omit?: perfil_moduloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfil_moduloInclude<ExtArgs> | null
  }


  /**
   * Model perfilusuario
   */

  export type AggregatePerfilusuario = {
    _count: PerfilusuarioCountAggregateOutputType | null
    _avg: PerfilusuarioAvgAggregateOutputType | null
    _sum: PerfilusuarioSumAggregateOutputType | null
    _min: PerfilusuarioMinAggregateOutputType | null
    _max: PerfilusuarioMaxAggregateOutputType | null
  }

  export type PerfilusuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type PerfilusuarioSumAggregateOutputType = {
    id: number | null
  }

  export type PerfilusuarioMinAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type PerfilusuarioMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type PerfilusuarioCountAggregateOutputType = {
    id: number
    descricao: number
    _all: number
  }


  export type PerfilusuarioAvgAggregateInputType = {
    id?: true
  }

  export type PerfilusuarioSumAggregateInputType = {
    id?: true
  }

  export type PerfilusuarioMinAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type PerfilusuarioMaxAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type PerfilusuarioCountAggregateInputType = {
    id?: true
    descricao?: true
    _all?: true
  }

  export type PerfilusuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which perfilusuario to aggregate.
     */
    where?: perfilusuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of perfilusuarios to fetch.
     */
    orderBy?: perfilusuarioOrderByWithRelationInput | perfilusuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: perfilusuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` perfilusuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` perfilusuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned perfilusuarios
    **/
    _count?: true | PerfilusuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerfilusuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerfilusuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerfilusuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerfilusuarioMaxAggregateInputType
  }

  export type GetPerfilusuarioAggregateType<T extends PerfilusuarioAggregateArgs> = {
        [P in keyof T & keyof AggregatePerfilusuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerfilusuario[P]>
      : GetScalarType<T[P], AggregatePerfilusuario[P]>
  }




  export type perfilusuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: perfilusuarioWhereInput
    orderBy?: perfilusuarioOrderByWithAggregationInput | perfilusuarioOrderByWithAggregationInput[]
    by: PerfilusuarioScalarFieldEnum[] | PerfilusuarioScalarFieldEnum
    having?: perfilusuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerfilusuarioCountAggregateInputType | true
    _avg?: PerfilusuarioAvgAggregateInputType
    _sum?: PerfilusuarioSumAggregateInputType
    _min?: PerfilusuarioMinAggregateInputType
    _max?: PerfilusuarioMaxAggregateInputType
  }

  export type PerfilusuarioGroupByOutputType = {
    id: number
    descricao: string
    _count: PerfilusuarioCountAggregateOutputType | null
    _avg: PerfilusuarioAvgAggregateOutputType | null
    _sum: PerfilusuarioSumAggregateOutputType | null
    _min: PerfilusuarioMinAggregateOutputType | null
    _max: PerfilusuarioMaxAggregateOutputType | null
  }

  type GetPerfilusuarioGroupByPayload<T extends perfilusuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerfilusuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerfilusuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerfilusuarioGroupByOutputType[P]>
            : GetScalarType<T[P], PerfilusuarioGroupByOutputType[P]>
        }
      >
    >


  export type perfilusuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    logins?: boolean | perfilusuario$loginsArgs<ExtArgs>
    perfilXmodulos?: boolean | perfilusuario$perfilXmodulosArgs<ExtArgs>
    _count?: boolean | PerfilusuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["perfilusuario"]>



  export type perfilusuarioSelectScalar = {
    id?: boolean
    descricao?: boolean
  }

  export type perfilusuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao", ExtArgs["result"]["perfilusuario"]>
  export type perfilusuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logins?: boolean | perfilusuario$loginsArgs<ExtArgs>
    perfilXmodulos?: boolean | perfilusuario$perfilXmodulosArgs<ExtArgs>
    _count?: boolean | PerfilusuarioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $perfilusuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "perfilusuario"
    objects: {
      logins: Prisma.$loginsPayload<ExtArgs>[]
      perfilXmodulos: Prisma.$perfil_moduloPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
    }, ExtArgs["result"]["perfilusuario"]>
    composites: {}
  }

  type perfilusuarioGetPayload<S extends boolean | null | undefined | perfilusuarioDefaultArgs> = $Result.GetResult<Prisma.$perfilusuarioPayload, S>

  type perfilusuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<perfilusuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerfilusuarioCountAggregateInputType | true
    }

  export interface perfilusuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['perfilusuario'], meta: { name: 'perfilusuario' } }
    /**
     * Find zero or one Perfilusuario that matches the filter.
     * @param {perfilusuarioFindUniqueArgs} args - Arguments to find a Perfilusuario
     * @example
     * // Get one Perfilusuario
     * const perfilusuario = await prisma.perfilusuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends perfilusuarioFindUniqueArgs>(args: SelectSubset<T, perfilusuarioFindUniqueArgs<ExtArgs>>): Prisma__perfilusuarioClient<$Result.GetResult<Prisma.$perfilusuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Perfilusuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {perfilusuarioFindUniqueOrThrowArgs} args - Arguments to find a Perfilusuario
     * @example
     * // Get one Perfilusuario
     * const perfilusuario = await prisma.perfilusuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends perfilusuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, perfilusuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__perfilusuarioClient<$Result.GetResult<Prisma.$perfilusuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Perfilusuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {perfilusuarioFindFirstArgs} args - Arguments to find a Perfilusuario
     * @example
     * // Get one Perfilusuario
     * const perfilusuario = await prisma.perfilusuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends perfilusuarioFindFirstArgs>(args?: SelectSubset<T, perfilusuarioFindFirstArgs<ExtArgs>>): Prisma__perfilusuarioClient<$Result.GetResult<Prisma.$perfilusuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Perfilusuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {perfilusuarioFindFirstOrThrowArgs} args - Arguments to find a Perfilusuario
     * @example
     * // Get one Perfilusuario
     * const perfilusuario = await prisma.perfilusuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends perfilusuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, perfilusuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__perfilusuarioClient<$Result.GetResult<Prisma.$perfilusuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Perfilusuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {perfilusuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Perfilusuarios
     * const perfilusuarios = await prisma.perfilusuario.findMany()
     * 
     * // Get first 10 Perfilusuarios
     * const perfilusuarios = await prisma.perfilusuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const perfilusuarioWithIdOnly = await prisma.perfilusuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends perfilusuarioFindManyArgs>(args?: SelectSubset<T, perfilusuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$perfilusuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Perfilusuario.
     * @param {perfilusuarioCreateArgs} args - Arguments to create a Perfilusuario.
     * @example
     * // Create one Perfilusuario
     * const Perfilusuario = await prisma.perfilusuario.create({
     *   data: {
     *     // ... data to create a Perfilusuario
     *   }
     * })
     * 
     */
    create<T extends perfilusuarioCreateArgs>(args: SelectSubset<T, perfilusuarioCreateArgs<ExtArgs>>): Prisma__perfilusuarioClient<$Result.GetResult<Prisma.$perfilusuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Perfilusuarios.
     * @param {perfilusuarioCreateManyArgs} args - Arguments to create many Perfilusuarios.
     * @example
     * // Create many Perfilusuarios
     * const perfilusuario = await prisma.perfilusuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends perfilusuarioCreateManyArgs>(args?: SelectSubset<T, perfilusuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Perfilusuario.
     * @param {perfilusuarioDeleteArgs} args - Arguments to delete one Perfilusuario.
     * @example
     * // Delete one Perfilusuario
     * const Perfilusuario = await prisma.perfilusuario.delete({
     *   where: {
     *     // ... filter to delete one Perfilusuario
     *   }
     * })
     * 
     */
    delete<T extends perfilusuarioDeleteArgs>(args: SelectSubset<T, perfilusuarioDeleteArgs<ExtArgs>>): Prisma__perfilusuarioClient<$Result.GetResult<Prisma.$perfilusuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Perfilusuario.
     * @param {perfilusuarioUpdateArgs} args - Arguments to update one Perfilusuario.
     * @example
     * // Update one Perfilusuario
     * const perfilusuario = await prisma.perfilusuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends perfilusuarioUpdateArgs>(args: SelectSubset<T, perfilusuarioUpdateArgs<ExtArgs>>): Prisma__perfilusuarioClient<$Result.GetResult<Prisma.$perfilusuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Perfilusuarios.
     * @param {perfilusuarioDeleteManyArgs} args - Arguments to filter Perfilusuarios to delete.
     * @example
     * // Delete a few Perfilusuarios
     * const { count } = await prisma.perfilusuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends perfilusuarioDeleteManyArgs>(args?: SelectSubset<T, perfilusuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Perfilusuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {perfilusuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Perfilusuarios
     * const perfilusuario = await prisma.perfilusuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends perfilusuarioUpdateManyArgs>(args: SelectSubset<T, perfilusuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Perfilusuario.
     * @param {perfilusuarioUpsertArgs} args - Arguments to update or create a Perfilusuario.
     * @example
     * // Update or create a Perfilusuario
     * const perfilusuario = await prisma.perfilusuario.upsert({
     *   create: {
     *     // ... data to create a Perfilusuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Perfilusuario we want to update
     *   }
     * })
     */
    upsert<T extends perfilusuarioUpsertArgs>(args: SelectSubset<T, perfilusuarioUpsertArgs<ExtArgs>>): Prisma__perfilusuarioClient<$Result.GetResult<Prisma.$perfilusuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Perfilusuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {perfilusuarioCountArgs} args - Arguments to filter Perfilusuarios to count.
     * @example
     * // Count the number of Perfilusuarios
     * const count = await prisma.perfilusuario.count({
     *   where: {
     *     // ... the filter for the Perfilusuarios we want to count
     *   }
     * })
    **/
    count<T extends perfilusuarioCountArgs>(
      args?: Subset<T, perfilusuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerfilusuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Perfilusuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilusuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerfilusuarioAggregateArgs>(args: Subset<T, PerfilusuarioAggregateArgs>): Prisma.PrismaPromise<GetPerfilusuarioAggregateType<T>>

    /**
     * Group by Perfilusuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {perfilusuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends perfilusuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: perfilusuarioGroupByArgs['orderBy'] }
        : { orderBy?: perfilusuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, perfilusuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerfilusuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the perfilusuario model
   */
  readonly fields: perfilusuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for perfilusuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__perfilusuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    logins<T extends perfilusuario$loginsArgs<ExtArgs> = {}>(args?: Subset<T, perfilusuario$loginsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$loginsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    perfilXmodulos<T extends perfilusuario$perfilXmodulosArgs<ExtArgs> = {}>(args?: Subset<T, perfilusuario$perfilXmodulosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$perfil_moduloPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the perfilusuario model
   */
  interface perfilusuarioFieldRefs {
    readonly id: FieldRef<"perfilusuario", 'Int'>
    readonly descricao: FieldRef<"perfilusuario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * perfilusuario findUnique
   */
  export type perfilusuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfilusuario
     */
    select?: perfilusuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfilusuario
     */
    omit?: perfilusuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfilusuarioInclude<ExtArgs> | null
    /**
     * Filter, which perfilusuario to fetch.
     */
    where: perfilusuarioWhereUniqueInput
  }

  /**
   * perfilusuario findUniqueOrThrow
   */
  export type perfilusuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfilusuario
     */
    select?: perfilusuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfilusuario
     */
    omit?: perfilusuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfilusuarioInclude<ExtArgs> | null
    /**
     * Filter, which perfilusuario to fetch.
     */
    where: perfilusuarioWhereUniqueInput
  }

  /**
   * perfilusuario findFirst
   */
  export type perfilusuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfilusuario
     */
    select?: perfilusuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfilusuario
     */
    omit?: perfilusuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfilusuarioInclude<ExtArgs> | null
    /**
     * Filter, which perfilusuario to fetch.
     */
    where?: perfilusuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of perfilusuarios to fetch.
     */
    orderBy?: perfilusuarioOrderByWithRelationInput | perfilusuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for perfilusuarios.
     */
    cursor?: perfilusuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` perfilusuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` perfilusuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of perfilusuarios.
     */
    distinct?: PerfilusuarioScalarFieldEnum | PerfilusuarioScalarFieldEnum[]
  }

  /**
   * perfilusuario findFirstOrThrow
   */
  export type perfilusuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfilusuario
     */
    select?: perfilusuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfilusuario
     */
    omit?: perfilusuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfilusuarioInclude<ExtArgs> | null
    /**
     * Filter, which perfilusuario to fetch.
     */
    where?: perfilusuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of perfilusuarios to fetch.
     */
    orderBy?: perfilusuarioOrderByWithRelationInput | perfilusuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for perfilusuarios.
     */
    cursor?: perfilusuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` perfilusuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` perfilusuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of perfilusuarios.
     */
    distinct?: PerfilusuarioScalarFieldEnum | PerfilusuarioScalarFieldEnum[]
  }

  /**
   * perfilusuario findMany
   */
  export type perfilusuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfilusuario
     */
    select?: perfilusuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfilusuario
     */
    omit?: perfilusuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfilusuarioInclude<ExtArgs> | null
    /**
     * Filter, which perfilusuarios to fetch.
     */
    where?: perfilusuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of perfilusuarios to fetch.
     */
    orderBy?: perfilusuarioOrderByWithRelationInput | perfilusuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing perfilusuarios.
     */
    cursor?: perfilusuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` perfilusuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` perfilusuarios.
     */
    skip?: number
    distinct?: PerfilusuarioScalarFieldEnum | PerfilusuarioScalarFieldEnum[]
  }

  /**
   * perfilusuario create
   */
  export type perfilusuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfilusuario
     */
    select?: perfilusuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfilusuario
     */
    omit?: perfilusuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfilusuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a perfilusuario.
     */
    data: XOR<perfilusuarioCreateInput, perfilusuarioUncheckedCreateInput>
  }

  /**
   * perfilusuario createMany
   */
  export type perfilusuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many perfilusuarios.
     */
    data: perfilusuarioCreateManyInput | perfilusuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * perfilusuario update
   */
  export type perfilusuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfilusuario
     */
    select?: perfilusuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfilusuario
     */
    omit?: perfilusuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfilusuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a perfilusuario.
     */
    data: XOR<perfilusuarioUpdateInput, perfilusuarioUncheckedUpdateInput>
    /**
     * Choose, which perfilusuario to update.
     */
    where: perfilusuarioWhereUniqueInput
  }

  /**
   * perfilusuario updateMany
   */
  export type perfilusuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update perfilusuarios.
     */
    data: XOR<perfilusuarioUpdateManyMutationInput, perfilusuarioUncheckedUpdateManyInput>
    /**
     * Filter which perfilusuarios to update
     */
    where?: perfilusuarioWhereInput
    /**
     * Limit how many perfilusuarios to update.
     */
    limit?: number
  }

  /**
   * perfilusuario upsert
   */
  export type perfilusuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfilusuario
     */
    select?: perfilusuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfilusuario
     */
    omit?: perfilusuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfilusuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the perfilusuario to update in case it exists.
     */
    where: perfilusuarioWhereUniqueInput
    /**
     * In case the perfilusuario found by the `where` argument doesn't exist, create a new perfilusuario with this data.
     */
    create: XOR<perfilusuarioCreateInput, perfilusuarioUncheckedCreateInput>
    /**
     * In case the perfilusuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<perfilusuarioUpdateInput, perfilusuarioUncheckedUpdateInput>
  }

  /**
   * perfilusuario delete
   */
  export type perfilusuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfilusuario
     */
    select?: perfilusuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfilusuario
     */
    omit?: perfilusuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfilusuarioInclude<ExtArgs> | null
    /**
     * Filter which perfilusuario to delete.
     */
    where: perfilusuarioWhereUniqueInput
  }

  /**
   * perfilusuario deleteMany
   */
  export type perfilusuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which perfilusuarios to delete
     */
    where?: perfilusuarioWhereInput
    /**
     * Limit how many perfilusuarios to delete.
     */
    limit?: number
  }

  /**
   * perfilusuario.logins
   */
  export type perfilusuario$loginsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logins
     */
    select?: loginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logins
     */
    omit?: loginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginsInclude<ExtArgs> | null
    where?: loginsWhereInput
    orderBy?: loginsOrderByWithRelationInput | loginsOrderByWithRelationInput[]
    cursor?: loginsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoginsScalarFieldEnum | LoginsScalarFieldEnum[]
  }

  /**
   * perfilusuario.perfilXmodulos
   */
  export type perfilusuario$perfilXmodulosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfil_modulo
     */
    select?: perfil_moduloSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfil_modulo
     */
    omit?: perfil_moduloOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfil_moduloInclude<ExtArgs> | null
    where?: perfil_moduloWhereInput
    orderBy?: perfil_moduloOrderByWithRelationInput | perfil_moduloOrderByWithRelationInput[]
    cursor?: perfil_moduloWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Perfil_moduloScalarFieldEnum | Perfil_moduloScalarFieldEnum[]
  }

  /**
   * perfilusuario without action
   */
  export type perfilusuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the perfilusuario
     */
    select?: perfilusuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the perfilusuario
     */
    omit?: perfilusuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: perfilusuarioInclude<ExtArgs> | null
  }


  /**
   * Model senhas
   */

  export type AggregateSenhas = {
    _count: SenhasCountAggregateOutputType | null
    _avg: SenhasAvgAggregateOutputType | null
    _sum: SenhasSumAggregateOutputType | null
    _min: SenhasMinAggregateOutputType | null
    _max: SenhasMaxAggregateOutputType | null
  }

  export type SenhasAvgAggregateOutputType = {
    id: number | null
    idusuario: number | null
    idretorno: number | null
    idusuario_atualizacao: number | null
  }

  export type SenhasSumAggregateOutputType = {
    id: number | null
    idusuario: number | null
    idretorno: number | null
    idusuario_atualizacao: number | null
  }

  export type SenhasMinAggregateOutputType = {
    id: number | null
    idusuario: number | null
    senha: string | null
    idretorno: number | null
    observacao: string | null
    createdAt: Date | null
    updatedAt: Date | null
    cpf: string | null
    idusuario_atualizacao: number | null
  }

  export type SenhasMaxAggregateOutputType = {
    id: number | null
    idusuario: number | null
    senha: string | null
    idretorno: number | null
    observacao: string | null
    createdAt: Date | null
    updatedAt: Date | null
    cpf: string | null
    idusuario_atualizacao: number | null
  }

  export type SenhasCountAggregateOutputType = {
    id: number
    idusuario: number
    senha: number
    idretorno: number
    observacao: number
    createdAt: number
    updatedAt: number
    cpf: number
    idusuario_atualizacao: number
    _all: number
  }


  export type SenhasAvgAggregateInputType = {
    id?: true
    idusuario?: true
    idretorno?: true
    idusuario_atualizacao?: true
  }

  export type SenhasSumAggregateInputType = {
    id?: true
    idusuario?: true
    idretorno?: true
    idusuario_atualizacao?: true
  }

  export type SenhasMinAggregateInputType = {
    id?: true
    idusuario?: true
    senha?: true
    idretorno?: true
    observacao?: true
    createdAt?: true
    updatedAt?: true
    cpf?: true
    idusuario_atualizacao?: true
  }

  export type SenhasMaxAggregateInputType = {
    id?: true
    idusuario?: true
    senha?: true
    idretorno?: true
    observacao?: true
    createdAt?: true
    updatedAt?: true
    cpf?: true
    idusuario_atualizacao?: true
  }

  export type SenhasCountAggregateInputType = {
    id?: true
    idusuario?: true
    senha?: true
    idretorno?: true
    observacao?: true
    createdAt?: true
    updatedAt?: true
    cpf?: true
    idusuario_atualizacao?: true
    _all?: true
  }

  export type SenhasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which senhas to aggregate.
     */
    where?: senhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of senhas to fetch.
     */
    orderBy?: senhasOrderByWithRelationInput | senhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: senhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` senhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` senhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned senhas
    **/
    _count?: true | SenhasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SenhasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SenhasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SenhasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SenhasMaxAggregateInputType
  }

  export type GetSenhasAggregateType<T extends SenhasAggregateArgs> = {
        [P in keyof T & keyof AggregateSenhas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSenhas[P]>
      : GetScalarType<T[P], AggregateSenhas[P]>
  }




  export type senhasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: senhasWhereInput
    orderBy?: senhasOrderByWithAggregationInput | senhasOrderByWithAggregationInput[]
    by: SenhasScalarFieldEnum[] | SenhasScalarFieldEnum
    having?: senhasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SenhasCountAggregateInputType | true
    _avg?: SenhasAvgAggregateInputType
    _sum?: SenhasSumAggregateInputType
    _min?: SenhasMinAggregateInputType
    _max?: SenhasMaxAggregateInputType
  }

  export type SenhasGroupByOutputType = {
    id: number
    idusuario: number
    senha: string | null
    idretorno: number | null
    observacao: string | null
    createdAt: Date
    updatedAt: Date
    cpf: string
    idusuario_atualizacao: number | null
    _count: SenhasCountAggregateOutputType | null
    _avg: SenhasAvgAggregateOutputType | null
    _sum: SenhasSumAggregateOutputType | null
    _min: SenhasMinAggregateOutputType | null
    _max: SenhasMaxAggregateOutputType | null
  }

  type GetSenhasGroupByPayload<T extends senhasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SenhasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SenhasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SenhasGroupByOutputType[P]>
            : GetScalarType<T[P], SenhasGroupByOutputType[P]>
        }
      >
    >


  export type senhasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idusuario?: boolean
    senha?: boolean
    idretorno?: boolean
    observacao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cpf?: boolean
    idusuario_atualizacao?: boolean
  }, ExtArgs["result"]["senhas"]>



  export type senhasSelectScalar = {
    id?: boolean
    idusuario?: boolean
    senha?: boolean
    idretorno?: boolean
    observacao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cpf?: boolean
    idusuario_atualizacao?: boolean
  }

  export type senhasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idusuario" | "senha" | "idretorno" | "observacao" | "createdAt" | "updatedAt" | "cpf" | "idusuario_atualizacao", ExtArgs["result"]["senhas"]>

  export type $senhasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "senhas"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idusuario: number
      senha: string | null
      idretorno: number | null
      observacao: string | null
      createdAt: Date
      updatedAt: Date
      cpf: string
      idusuario_atualizacao: number | null
    }, ExtArgs["result"]["senhas"]>
    composites: {}
  }

  type senhasGetPayload<S extends boolean | null | undefined | senhasDefaultArgs> = $Result.GetResult<Prisma.$senhasPayload, S>

  type senhasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<senhasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SenhasCountAggregateInputType | true
    }

  export interface senhasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['senhas'], meta: { name: 'senhas' } }
    /**
     * Find zero or one Senhas that matches the filter.
     * @param {senhasFindUniqueArgs} args - Arguments to find a Senhas
     * @example
     * // Get one Senhas
     * const senhas = await prisma.senhas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends senhasFindUniqueArgs>(args: SelectSubset<T, senhasFindUniqueArgs<ExtArgs>>): Prisma__senhasClient<$Result.GetResult<Prisma.$senhasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Senhas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {senhasFindUniqueOrThrowArgs} args - Arguments to find a Senhas
     * @example
     * // Get one Senhas
     * const senhas = await prisma.senhas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends senhasFindUniqueOrThrowArgs>(args: SelectSubset<T, senhasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__senhasClient<$Result.GetResult<Prisma.$senhasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Senhas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {senhasFindFirstArgs} args - Arguments to find a Senhas
     * @example
     * // Get one Senhas
     * const senhas = await prisma.senhas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends senhasFindFirstArgs>(args?: SelectSubset<T, senhasFindFirstArgs<ExtArgs>>): Prisma__senhasClient<$Result.GetResult<Prisma.$senhasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Senhas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {senhasFindFirstOrThrowArgs} args - Arguments to find a Senhas
     * @example
     * // Get one Senhas
     * const senhas = await prisma.senhas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends senhasFindFirstOrThrowArgs>(args?: SelectSubset<T, senhasFindFirstOrThrowArgs<ExtArgs>>): Prisma__senhasClient<$Result.GetResult<Prisma.$senhasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Senhas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {senhasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Senhas
     * const senhas = await prisma.senhas.findMany()
     * 
     * // Get first 10 Senhas
     * const senhas = await prisma.senhas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const senhasWithIdOnly = await prisma.senhas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends senhasFindManyArgs>(args?: SelectSubset<T, senhasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$senhasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Senhas.
     * @param {senhasCreateArgs} args - Arguments to create a Senhas.
     * @example
     * // Create one Senhas
     * const Senhas = await prisma.senhas.create({
     *   data: {
     *     // ... data to create a Senhas
     *   }
     * })
     * 
     */
    create<T extends senhasCreateArgs>(args: SelectSubset<T, senhasCreateArgs<ExtArgs>>): Prisma__senhasClient<$Result.GetResult<Prisma.$senhasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Senhas.
     * @param {senhasCreateManyArgs} args - Arguments to create many Senhas.
     * @example
     * // Create many Senhas
     * const senhas = await prisma.senhas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends senhasCreateManyArgs>(args?: SelectSubset<T, senhasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Senhas.
     * @param {senhasDeleteArgs} args - Arguments to delete one Senhas.
     * @example
     * // Delete one Senhas
     * const Senhas = await prisma.senhas.delete({
     *   where: {
     *     // ... filter to delete one Senhas
     *   }
     * })
     * 
     */
    delete<T extends senhasDeleteArgs>(args: SelectSubset<T, senhasDeleteArgs<ExtArgs>>): Prisma__senhasClient<$Result.GetResult<Prisma.$senhasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Senhas.
     * @param {senhasUpdateArgs} args - Arguments to update one Senhas.
     * @example
     * // Update one Senhas
     * const senhas = await prisma.senhas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends senhasUpdateArgs>(args: SelectSubset<T, senhasUpdateArgs<ExtArgs>>): Prisma__senhasClient<$Result.GetResult<Prisma.$senhasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Senhas.
     * @param {senhasDeleteManyArgs} args - Arguments to filter Senhas to delete.
     * @example
     * // Delete a few Senhas
     * const { count } = await prisma.senhas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends senhasDeleteManyArgs>(args?: SelectSubset<T, senhasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Senhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {senhasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Senhas
     * const senhas = await prisma.senhas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends senhasUpdateManyArgs>(args: SelectSubset<T, senhasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Senhas.
     * @param {senhasUpsertArgs} args - Arguments to update or create a Senhas.
     * @example
     * // Update or create a Senhas
     * const senhas = await prisma.senhas.upsert({
     *   create: {
     *     // ... data to create a Senhas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Senhas we want to update
     *   }
     * })
     */
    upsert<T extends senhasUpsertArgs>(args: SelectSubset<T, senhasUpsertArgs<ExtArgs>>): Prisma__senhasClient<$Result.GetResult<Prisma.$senhasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Senhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {senhasCountArgs} args - Arguments to filter Senhas to count.
     * @example
     * // Count the number of Senhas
     * const count = await prisma.senhas.count({
     *   where: {
     *     // ... the filter for the Senhas we want to count
     *   }
     * })
    **/
    count<T extends senhasCountArgs>(
      args?: Subset<T, senhasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SenhasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Senhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SenhasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SenhasAggregateArgs>(args: Subset<T, SenhasAggregateArgs>): Prisma.PrismaPromise<GetSenhasAggregateType<T>>

    /**
     * Group by Senhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {senhasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends senhasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: senhasGroupByArgs['orderBy'] }
        : { orderBy?: senhasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, senhasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSenhasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the senhas model
   */
  readonly fields: senhasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for senhas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__senhasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the senhas model
   */
  interface senhasFieldRefs {
    readonly id: FieldRef<"senhas", 'Int'>
    readonly idusuario: FieldRef<"senhas", 'Int'>
    readonly senha: FieldRef<"senhas", 'String'>
    readonly idretorno: FieldRef<"senhas", 'Int'>
    readonly observacao: FieldRef<"senhas", 'String'>
    readonly createdAt: FieldRef<"senhas", 'DateTime'>
    readonly updatedAt: FieldRef<"senhas", 'DateTime'>
    readonly cpf: FieldRef<"senhas", 'String'>
    readonly idusuario_atualizacao: FieldRef<"senhas", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * senhas findUnique
   */
  export type senhasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the senhas
     */
    select?: senhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the senhas
     */
    omit?: senhasOmit<ExtArgs> | null
    /**
     * Filter, which senhas to fetch.
     */
    where: senhasWhereUniqueInput
  }

  /**
   * senhas findUniqueOrThrow
   */
  export type senhasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the senhas
     */
    select?: senhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the senhas
     */
    omit?: senhasOmit<ExtArgs> | null
    /**
     * Filter, which senhas to fetch.
     */
    where: senhasWhereUniqueInput
  }

  /**
   * senhas findFirst
   */
  export type senhasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the senhas
     */
    select?: senhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the senhas
     */
    omit?: senhasOmit<ExtArgs> | null
    /**
     * Filter, which senhas to fetch.
     */
    where?: senhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of senhas to fetch.
     */
    orderBy?: senhasOrderByWithRelationInput | senhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for senhas.
     */
    cursor?: senhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` senhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` senhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of senhas.
     */
    distinct?: SenhasScalarFieldEnum | SenhasScalarFieldEnum[]
  }

  /**
   * senhas findFirstOrThrow
   */
  export type senhasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the senhas
     */
    select?: senhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the senhas
     */
    omit?: senhasOmit<ExtArgs> | null
    /**
     * Filter, which senhas to fetch.
     */
    where?: senhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of senhas to fetch.
     */
    orderBy?: senhasOrderByWithRelationInput | senhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for senhas.
     */
    cursor?: senhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` senhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` senhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of senhas.
     */
    distinct?: SenhasScalarFieldEnum | SenhasScalarFieldEnum[]
  }

  /**
   * senhas findMany
   */
  export type senhasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the senhas
     */
    select?: senhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the senhas
     */
    omit?: senhasOmit<ExtArgs> | null
    /**
     * Filter, which senhas to fetch.
     */
    where?: senhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of senhas to fetch.
     */
    orderBy?: senhasOrderByWithRelationInput | senhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing senhas.
     */
    cursor?: senhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` senhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` senhas.
     */
    skip?: number
    distinct?: SenhasScalarFieldEnum | SenhasScalarFieldEnum[]
  }

  /**
   * senhas create
   */
  export type senhasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the senhas
     */
    select?: senhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the senhas
     */
    omit?: senhasOmit<ExtArgs> | null
    /**
     * The data needed to create a senhas.
     */
    data: XOR<senhasCreateInput, senhasUncheckedCreateInput>
  }

  /**
   * senhas createMany
   */
  export type senhasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many senhas.
     */
    data: senhasCreateManyInput | senhasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * senhas update
   */
  export type senhasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the senhas
     */
    select?: senhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the senhas
     */
    omit?: senhasOmit<ExtArgs> | null
    /**
     * The data needed to update a senhas.
     */
    data: XOR<senhasUpdateInput, senhasUncheckedUpdateInput>
    /**
     * Choose, which senhas to update.
     */
    where: senhasWhereUniqueInput
  }

  /**
   * senhas updateMany
   */
  export type senhasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update senhas.
     */
    data: XOR<senhasUpdateManyMutationInput, senhasUncheckedUpdateManyInput>
    /**
     * Filter which senhas to update
     */
    where?: senhasWhereInput
    /**
     * Limit how many senhas to update.
     */
    limit?: number
  }

  /**
   * senhas upsert
   */
  export type senhasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the senhas
     */
    select?: senhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the senhas
     */
    omit?: senhasOmit<ExtArgs> | null
    /**
     * The filter to search for the senhas to update in case it exists.
     */
    where: senhasWhereUniqueInput
    /**
     * In case the senhas found by the `where` argument doesn't exist, create a new senhas with this data.
     */
    create: XOR<senhasCreateInput, senhasUncheckedCreateInput>
    /**
     * In case the senhas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<senhasUpdateInput, senhasUncheckedUpdateInput>
  }

  /**
   * senhas delete
   */
  export type senhasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the senhas
     */
    select?: senhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the senhas
     */
    omit?: senhasOmit<ExtArgs> | null
    /**
     * Filter which senhas to delete.
     */
    where: senhasWhereUniqueInput
  }

  /**
   * senhas deleteMany
   */
  export type senhasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which senhas to delete
     */
    where?: senhasWhereInput
    /**
     * Limit how many senhas to delete.
     */
    limit?: number
  }

  /**
   * senhas without action
   */
  export type senhasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the senhas
     */
    select?: senhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the senhas
     */
    omit?: senhasOmit<ExtArgs> | null
  }


  /**
   * Model situacao
   */

  export type AggregateSituacao = {
    _count: SituacaoCountAggregateOutputType | null
    _avg: SituacaoAvgAggregateOutputType | null
    _sum: SituacaoSumAggregateOutputType | null
    _min: SituacaoMinAggregateOutputType | null
    _max: SituacaoMaxAggregateOutputType | null
  }

  export type SituacaoAvgAggregateOutputType = {
    id: number | null
  }

  export type SituacaoSumAggregateOutputType = {
    id: number | null
  }

  export type SituacaoMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    icone: string | null
    cor: string | null
    createdAt: Date | null
    updatedAt: Date | null
    formsolicitar: boolean | null
  }

  export type SituacaoMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    icone: string | null
    cor: string | null
    createdAt: Date | null
    updatedAt: Date | null
    formsolicitar: boolean | null
  }

  export type SituacaoCountAggregateOutputType = {
    id: number
    descricao: number
    icone: number
    cor: number
    createdAt: number
    updatedAt: number
    formsolicitar: number
    _all: number
  }


  export type SituacaoAvgAggregateInputType = {
    id?: true
  }

  export type SituacaoSumAggregateInputType = {
    id?: true
  }

  export type SituacaoMinAggregateInputType = {
    id?: true
    descricao?: true
    icone?: true
    cor?: true
    createdAt?: true
    updatedAt?: true
    formsolicitar?: true
  }

  export type SituacaoMaxAggregateInputType = {
    id?: true
    descricao?: true
    icone?: true
    cor?: true
    createdAt?: true
    updatedAt?: true
    formsolicitar?: true
  }

  export type SituacaoCountAggregateInputType = {
    id?: true
    descricao?: true
    icone?: true
    cor?: true
    createdAt?: true
    updatedAt?: true
    formsolicitar?: true
    _all?: true
  }

  export type SituacaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which situacao to aggregate.
     */
    where?: situacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of situacaos to fetch.
     */
    orderBy?: situacaoOrderByWithRelationInput | situacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: situacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` situacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` situacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned situacaos
    **/
    _count?: true | SituacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SituacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SituacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SituacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SituacaoMaxAggregateInputType
  }

  export type GetSituacaoAggregateType<T extends SituacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateSituacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSituacao[P]>
      : GetScalarType<T[P], AggregateSituacao[P]>
  }




  export type situacaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: situacaoWhereInput
    orderBy?: situacaoOrderByWithAggregationInput | situacaoOrderByWithAggregationInput[]
    by: SituacaoScalarFieldEnum[] | SituacaoScalarFieldEnum
    having?: situacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SituacaoCountAggregateInputType | true
    _avg?: SituacaoAvgAggregateInputType
    _sum?: SituacaoSumAggregateInputType
    _min?: SituacaoMinAggregateInputType
    _max?: SituacaoMaxAggregateInputType
  }

  export type SituacaoGroupByOutputType = {
    id: number
    descricao: string
    icone: string | null
    cor: string | null
    createdAt: Date
    updatedAt: Date
    formsolicitar: boolean
    _count: SituacaoCountAggregateOutputType | null
    _avg: SituacaoAvgAggregateOutputType | null
    _sum: SituacaoSumAggregateOutputType | null
    _min: SituacaoMinAggregateOutputType | null
    _max: SituacaoMaxAggregateOutputType | null
  }

  type GetSituacaoGroupByPayload<T extends situacaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SituacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SituacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SituacaoGroupByOutputType[P]>
            : GetScalarType<T[P], SituacaoGroupByOutputType[P]>
        }
      >
    >


  export type situacaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    icone?: boolean
    cor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    formsolicitar?: boolean
  }, ExtArgs["result"]["situacao"]>



  export type situacaoSelectScalar = {
    id?: boolean
    descricao?: boolean
    icone?: boolean
    cor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    formsolicitar?: boolean
  }

  export type situacaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "icone" | "cor" | "createdAt" | "updatedAt" | "formsolicitar", ExtArgs["result"]["situacao"]>

  export type $situacaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "situacao"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      icone: string | null
      cor: string | null
      createdAt: Date
      updatedAt: Date
      formsolicitar: boolean
    }, ExtArgs["result"]["situacao"]>
    composites: {}
  }

  type situacaoGetPayload<S extends boolean | null | undefined | situacaoDefaultArgs> = $Result.GetResult<Prisma.$situacaoPayload, S>

  type situacaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<situacaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SituacaoCountAggregateInputType | true
    }

  export interface situacaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['situacao'], meta: { name: 'situacao' } }
    /**
     * Find zero or one Situacao that matches the filter.
     * @param {situacaoFindUniqueArgs} args - Arguments to find a Situacao
     * @example
     * // Get one Situacao
     * const situacao = await prisma.situacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends situacaoFindUniqueArgs>(args: SelectSubset<T, situacaoFindUniqueArgs<ExtArgs>>): Prisma__situacaoClient<$Result.GetResult<Prisma.$situacaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Situacao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {situacaoFindUniqueOrThrowArgs} args - Arguments to find a Situacao
     * @example
     * // Get one Situacao
     * const situacao = await prisma.situacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends situacaoFindUniqueOrThrowArgs>(args: SelectSubset<T, situacaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__situacaoClient<$Result.GetResult<Prisma.$situacaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Situacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {situacaoFindFirstArgs} args - Arguments to find a Situacao
     * @example
     * // Get one Situacao
     * const situacao = await prisma.situacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends situacaoFindFirstArgs>(args?: SelectSubset<T, situacaoFindFirstArgs<ExtArgs>>): Prisma__situacaoClient<$Result.GetResult<Prisma.$situacaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Situacao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {situacaoFindFirstOrThrowArgs} args - Arguments to find a Situacao
     * @example
     * // Get one Situacao
     * const situacao = await prisma.situacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends situacaoFindFirstOrThrowArgs>(args?: SelectSubset<T, situacaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__situacaoClient<$Result.GetResult<Prisma.$situacaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Situacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {situacaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Situacaos
     * const situacaos = await prisma.situacao.findMany()
     * 
     * // Get first 10 Situacaos
     * const situacaos = await prisma.situacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const situacaoWithIdOnly = await prisma.situacao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends situacaoFindManyArgs>(args?: SelectSubset<T, situacaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$situacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Situacao.
     * @param {situacaoCreateArgs} args - Arguments to create a Situacao.
     * @example
     * // Create one Situacao
     * const Situacao = await prisma.situacao.create({
     *   data: {
     *     // ... data to create a Situacao
     *   }
     * })
     * 
     */
    create<T extends situacaoCreateArgs>(args: SelectSubset<T, situacaoCreateArgs<ExtArgs>>): Prisma__situacaoClient<$Result.GetResult<Prisma.$situacaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Situacaos.
     * @param {situacaoCreateManyArgs} args - Arguments to create many Situacaos.
     * @example
     * // Create many Situacaos
     * const situacao = await prisma.situacao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends situacaoCreateManyArgs>(args?: SelectSubset<T, situacaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Situacao.
     * @param {situacaoDeleteArgs} args - Arguments to delete one Situacao.
     * @example
     * // Delete one Situacao
     * const Situacao = await prisma.situacao.delete({
     *   where: {
     *     // ... filter to delete one Situacao
     *   }
     * })
     * 
     */
    delete<T extends situacaoDeleteArgs>(args: SelectSubset<T, situacaoDeleteArgs<ExtArgs>>): Prisma__situacaoClient<$Result.GetResult<Prisma.$situacaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Situacao.
     * @param {situacaoUpdateArgs} args - Arguments to update one Situacao.
     * @example
     * // Update one Situacao
     * const situacao = await prisma.situacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends situacaoUpdateArgs>(args: SelectSubset<T, situacaoUpdateArgs<ExtArgs>>): Prisma__situacaoClient<$Result.GetResult<Prisma.$situacaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Situacaos.
     * @param {situacaoDeleteManyArgs} args - Arguments to filter Situacaos to delete.
     * @example
     * // Delete a few Situacaos
     * const { count } = await prisma.situacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends situacaoDeleteManyArgs>(args?: SelectSubset<T, situacaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Situacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {situacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Situacaos
     * const situacao = await prisma.situacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends situacaoUpdateManyArgs>(args: SelectSubset<T, situacaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Situacao.
     * @param {situacaoUpsertArgs} args - Arguments to update or create a Situacao.
     * @example
     * // Update or create a Situacao
     * const situacao = await prisma.situacao.upsert({
     *   create: {
     *     // ... data to create a Situacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Situacao we want to update
     *   }
     * })
     */
    upsert<T extends situacaoUpsertArgs>(args: SelectSubset<T, situacaoUpsertArgs<ExtArgs>>): Prisma__situacaoClient<$Result.GetResult<Prisma.$situacaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Situacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {situacaoCountArgs} args - Arguments to filter Situacaos to count.
     * @example
     * // Count the number of Situacaos
     * const count = await prisma.situacao.count({
     *   where: {
     *     // ... the filter for the Situacaos we want to count
     *   }
     * })
    **/
    count<T extends situacaoCountArgs>(
      args?: Subset<T, situacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SituacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Situacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SituacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SituacaoAggregateArgs>(args: Subset<T, SituacaoAggregateArgs>): Prisma.PrismaPromise<GetSituacaoAggregateType<T>>

    /**
     * Group by Situacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {situacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends situacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: situacaoGroupByArgs['orderBy'] }
        : { orderBy?: situacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, situacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSituacaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the situacao model
   */
  readonly fields: situacaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for situacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__situacaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the situacao model
   */
  interface situacaoFieldRefs {
    readonly id: FieldRef<"situacao", 'Int'>
    readonly descricao: FieldRef<"situacao", 'String'>
    readonly icone: FieldRef<"situacao", 'String'>
    readonly cor: FieldRef<"situacao", 'String'>
    readonly createdAt: FieldRef<"situacao", 'DateTime'>
    readonly updatedAt: FieldRef<"situacao", 'DateTime'>
    readonly formsolicitar: FieldRef<"situacao", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * situacao findUnique
   */
  export type situacaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacao
     */
    select?: situacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacao
     */
    omit?: situacaoOmit<ExtArgs> | null
    /**
     * Filter, which situacao to fetch.
     */
    where: situacaoWhereUniqueInput
  }

  /**
   * situacao findUniqueOrThrow
   */
  export type situacaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacao
     */
    select?: situacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacao
     */
    omit?: situacaoOmit<ExtArgs> | null
    /**
     * Filter, which situacao to fetch.
     */
    where: situacaoWhereUniqueInput
  }

  /**
   * situacao findFirst
   */
  export type situacaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacao
     */
    select?: situacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacao
     */
    omit?: situacaoOmit<ExtArgs> | null
    /**
     * Filter, which situacao to fetch.
     */
    where?: situacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of situacaos to fetch.
     */
    orderBy?: situacaoOrderByWithRelationInput | situacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for situacaos.
     */
    cursor?: situacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` situacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` situacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of situacaos.
     */
    distinct?: SituacaoScalarFieldEnum | SituacaoScalarFieldEnum[]
  }

  /**
   * situacao findFirstOrThrow
   */
  export type situacaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacao
     */
    select?: situacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacao
     */
    omit?: situacaoOmit<ExtArgs> | null
    /**
     * Filter, which situacao to fetch.
     */
    where?: situacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of situacaos to fetch.
     */
    orderBy?: situacaoOrderByWithRelationInput | situacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for situacaos.
     */
    cursor?: situacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` situacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` situacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of situacaos.
     */
    distinct?: SituacaoScalarFieldEnum | SituacaoScalarFieldEnum[]
  }

  /**
   * situacao findMany
   */
  export type situacaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacao
     */
    select?: situacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacao
     */
    omit?: situacaoOmit<ExtArgs> | null
    /**
     * Filter, which situacaos to fetch.
     */
    where?: situacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of situacaos to fetch.
     */
    orderBy?: situacaoOrderByWithRelationInput | situacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing situacaos.
     */
    cursor?: situacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` situacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` situacaos.
     */
    skip?: number
    distinct?: SituacaoScalarFieldEnum | SituacaoScalarFieldEnum[]
  }

  /**
   * situacao create
   */
  export type situacaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacao
     */
    select?: situacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacao
     */
    omit?: situacaoOmit<ExtArgs> | null
    /**
     * The data needed to create a situacao.
     */
    data: XOR<situacaoCreateInput, situacaoUncheckedCreateInput>
  }

  /**
   * situacao createMany
   */
  export type situacaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many situacaos.
     */
    data: situacaoCreateManyInput | situacaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * situacao update
   */
  export type situacaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacao
     */
    select?: situacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacao
     */
    omit?: situacaoOmit<ExtArgs> | null
    /**
     * The data needed to update a situacao.
     */
    data: XOR<situacaoUpdateInput, situacaoUncheckedUpdateInput>
    /**
     * Choose, which situacao to update.
     */
    where: situacaoWhereUniqueInput
  }

  /**
   * situacao updateMany
   */
  export type situacaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update situacaos.
     */
    data: XOR<situacaoUpdateManyMutationInput, situacaoUncheckedUpdateManyInput>
    /**
     * Filter which situacaos to update
     */
    where?: situacaoWhereInput
    /**
     * Limit how many situacaos to update.
     */
    limit?: number
  }

  /**
   * situacao upsert
   */
  export type situacaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacao
     */
    select?: situacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacao
     */
    omit?: situacaoOmit<ExtArgs> | null
    /**
     * The filter to search for the situacao to update in case it exists.
     */
    where: situacaoWhereUniqueInput
    /**
     * In case the situacao found by the `where` argument doesn't exist, create a new situacao with this data.
     */
    create: XOR<situacaoCreateInput, situacaoUncheckedCreateInput>
    /**
     * In case the situacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<situacaoUpdateInput, situacaoUncheckedUpdateInput>
  }

  /**
   * situacao delete
   */
  export type situacaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacao
     */
    select?: situacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacao
     */
    omit?: situacaoOmit<ExtArgs> | null
    /**
     * Filter which situacao to delete.
     */
    where: situacaoWhereUniqueInput
  }

  /**
   * situacao deleteMany
   */
  export type situacaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which situacaos to delete
     */
    where?: situacaoWhereInput
    /**
     * Limit how many situacaos to delete.
     */
    limit?: number
  }

  /**
   * situacao without action
   */
  export type situacaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacao
     */
    select?: situacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacao
     */
    omit?: situacaoOmit<ExtArgs> | null
  }


  /**
   * Model situacaosolicsenha
   */

  export type AggregateSituacaosolicsenha = {
    _count: SituacaosolicsenhaCountAggregateOutputType | null
    _avg: SituacaosolicsenhaAvgAggregateOutputType | null
    _sum: SituacaosolicsenhaSumAggregateOutputType | null
    _min: SituacaosolicsenhaMinAggregateOutputType | null
    _max: SituacaosolicsenhaMaxAggregateOutputType | null
  }

  export type SituacaosolicsenhaAvgAggregateOutputType = {
    id: number | null
  }

  export type SituacaosolicsenhaSumAggregateOutputType = {
    id: number | null
  }

  export type SituacaosolicsenhaMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    createdAt: Date | null
    updatedAt: Date | null
    telaSolicitar: boolean | null
    telaAtualizar: boolean | null
  }

  export type SituacaosolicsenhaMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    createdAt: Date | null
    updatedAt: Date | null
    telaSolicitar: boolean | null
    telaAtualizar: boolean | null
  }

  export type SituacaosolicsenhaCountAggregateOutputType = {
    id: number
    descricao: number
    createdAt: number
    updatedAt: number
    telaSolicitar: number
    telaAtualizar: number
    _all: number
  }


  export type SituacaosolicsenhaAvgAggregateInputType = {
    id?: true
  }

  export type SituacaosolicsenhaSumAggregateInputType = {
    id?: true
  }

  export type SituacaosolicsenhaMinAggregateInputType = {
    id?: true
    descricao?: true
    createdAt?: true
    updatedAt?: true
    telaSolicitar?: true
    telaAtualizar?: true
  }

  export type SituacaosolicsenhaMaxAggregateInputType = {
    id?: true
    descricao?: true
    createdAt?: true
    updatedAt?: true
    telaSolicitar?: true
    telaAtualizar?: true
  }

  export type SituacaosolicsenhaCountAggregateInputType = {
    id?: true
    descricao?: true
    createdAt?: true
    updatedAt?: true
    telaSolicitar?: true
    telaAtualizar?: true
    _all?: true
  }

  export type SituacaosolicsenhaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which situacaosolicsenha to aggregate.
     */
    where?: situacaosolicsenhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of situacaosolicsenhas to fetch.
     */
    orderBy?: situacaosolicsenhaOrderByWithRelationInput | situacaosolicsenhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: situacaosolicsenhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` situacaosolicsenhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` situacaosolicsenhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned situacaosolicsenhas
    **/
    _count?: true | SituacaosolicsenhaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SituacaosolicsenhaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SituacaosolicsenhaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SituacaosolicsenhaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SituacaosolicsenhaMaxAggregateInputType
  }

  export type GetSituacaosolicsenhaAggregateType<T extends SituacaosolicsenhaAggregateArgs> = {
        [P in keyof T & keyof AggregateSituacaosolicsenha]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSituacaosolicsenha[P]>
      : GetScalarType<T[P], AggregateSituacaosolicsenha[P]>
  }




  export type situacaosolicsenhaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: situacaosolicsenhaWhereInput
    orderBy?: situacaosolicsenhaOrderByWithAggregationInput | situacaosolicsenhaOrderByWithAggregationInput[]
    by: SituacaosolicsenhaScalarFieldEnum[] | SituacaosolicsenhaScalarFieldEnum
    having?: situacaosolicsenhaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SituacaosolicsenhaCountAggregateInputType | true
    _avg?: SituacaosolicsenhaAvgAggregateInputType
    _sum?: SituacaosolicsenhaSumAggregateInputType
    _min?: SituacaosolicsenhaMinAggregateInputType
    _max?: SituacaosolicsenhaMaxAggregateInputType
  }

  export type SituacaosolicsenhaGroupByOutputType = {
    id: number
    descricao: string
    createdAt: Date
    updatedAt: Date
    telaSolicitar: boolean
    telaAtualizar: boolean
    _count: SituacaosolicsenhaCountAggregateOutputType | null
    _avg: SituacaosolicsenhaAvgAggregateOutputType | null
    _sum: SituacaosolicsenhaSumAggregateOutputType | null
    _min: SituacaosolicsenhaMinAggregateOutputType | null
    _max: SituacaosolicsenhaMaxAggregateOutputType | null
  }

  type GetSituacaosolicsenhaGroupByPayload<T extends situacaosolicsenhaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SituacaosolicsenhaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SituacaosolicsenhaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SituacaosolicsenhaGroupByOutputType[P]>
            : GetScalarType<T[P], SituacaosolicsenhaGroupByOutputType[P]>
        }
      >
    >


  export type situacaosolicsenhaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    telaSolicitar?: boolean
    telaAtualizar?: boolean
  }, ExtArgs["result"]["situacaosolicsenha"]>



  export type situacaosolicsenhaSelectScalar = {
    id?: boolean
    descricao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    telaSolicitar?: boolean
    telaAtualizar?: boolean
  }

  export type situacaosolicsenhaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "createdAt" | "updatedAt" | "telaSolicitar" | "telaAtualizar", ExtArgs["result"]["situacaosolicsenha"]>

  export type $situacaosolicsenhaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "situacaosolicsenha"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      createdAt: Date
      updatedAt: Date
      telaSolicitar: boolean
      telaAtualizar: boolean
    }, ExtArgs["result"]["situacaosolicsenha"]>
    composites: {}
  }

  type situacaosolicsenhaGetPayload<S extends boolean | null | undefined | situacaosolicsenhaDefaultArgs> = $Result.GetResult<Prisma.$situacaosolicsenhaPayload, S>

  type situacaosolicsenhaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<situacaosolicsenhaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SituacaosolicsenhaCountAggregateInputType | true
    }

  export interface situacaosolicsenhaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['situacaosolicsenha'], meta: { name: 'situacaosolicsenha' } }
    /**
     * Find zero or one Situacaosolicsenha that matches the filter.
     * @param {situacaosolicsenhaFindUniqueArgs} args - Arguments to find a Situacaosolicsenha
     * @example
     * // Get one Situacaosolicsenha
     * const situacaosolicsenha = await prisma.situacaosolicsenha.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends situacaosolicsenhaFindUniqueArgs>(args: SelectSubset<T, situacaosolicsenhaFindUniqueArgs<ExtArgs>>): Prisma__situacaosolicsenhaClient<$Result.GetResult<Prisma.$situacaosolicsenhaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Situacaosolicsenha that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {situacaosolicsenhaFindUniqueOrThrowArgs} args - Arguments to find a Situacaosolicsenha
     * @example
     * // Get one Situacaosolicsenha
     * const situacaosolicsenha = await prisma.situacaosolicsenha.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends situacaosolicsenhaFindUniqueOrThrowArgs>(args: SelectSubset<T, situacaosolicsenhaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__situacaosolicsenhaClient<$Result.GetResult<Prisma.$situacaosolicsenhaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Situacaosolicsenha that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {situacaosolicsenhaFindFirstArgs} args - Arguments to find a Situacaosolicsenha
     * @example
     * // Get one Situacaosolicsenha
     * const situacaosolicsenha = await prisma.situacaosolicsenha.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends situacaosolicsenhaFindFirstArgs>(args?: SelectSubset<T, situacaosolicsenhaFindFirstArgs<ExtArgs>>): Prisma__situacaosolicsenhaClient<$Result.GetResult<Prisma.$situacaosolicsenhaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Situacaosolicsenha that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {situacaosolicsenhaFindFirstOrThrowArgs} args - Arguments to find a Situacaosolicsenha
     * @example
     * // Get one Situacaosolicsenha
     * const situacaosolicsenha = await prisma.situacaosolicsenha.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends situacaosolicsenhaFindFirstOrThrowArgs>(args?: SelectSubset<T, situacaosolicsenhaFindFirstOrThrowArgs<ExtArgs>>): Prisma__situacaosolicsenhaClient<$Result.GetResult<Prisma.$situacaosolicsenhaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Situacaosolicsenhas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {situacaosolicsenhaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Situacaosolicsenhas
     * const situacaosolicsenhas = await prisma.situacaosolicsenha.findMany()
     * 
     * // Get first 10 Situacaosolicsenhas
     * const situacaosolicsenhas = await prisma.situacaosolicsenha.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const situacaosolicsenhaWithIdOnly = await prisma.situacaosolicsenha.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends situacaosolicsenhaFindManyArgs>(args?: SelectSubset<T, situacaosolicsenhaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$situacaosolicsenhaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Situacaosolicsenha.
     * @param {situacaosolicsenhaCreateArgs} args - Arguments to create a Situacaosolicsenha.
     * @example
     * // Create one Situacaosolicsenha
     * const Situacaosolicsenha = await prisma.situacaosolicsenha.create({
     *   data: {
     *     // ... data to create a Situacaosolicsenha
     *   }
     * })
     * 
     */
    create<T extends situacaosolicsenhaCreateArgs>(args: SelectSubset<T, situacaosolicsenhaCreateArgs<ExtArgs>>): Prisma__situacaosolicsenhaClient<$Result.GetResult<Prisma.$situacaosolicsenhaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Situacaosolicsenhas.
     * @param {situacaosolicsenhaCreateManyArgs} args - Arguments to create many Situacaosolicsenhas.
     * @example
     * // Create many Situacaosolicsenhas
     * const situacaosolicsenha = await prisma.situacaosolicsenha.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends situacaosolicsenhaCreateManyArgs>(args?: SelectSubset<T, situacaosolicsenhaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Situacaosolicsenha.
     * @param {situacaosolicsenhaDeleteArgs} args - Arguments to delete one Situacaosolicsenha.
     * @example
     * // Delete one Situacaosolicsenha
     * const Situacaosolicsenha = await prisma.situacaosolicsenha.delete({
     *   where: {
     *     // ... filter to delete one Situacaosolicsenha
     *   }
     * })
     * 
     */
    delete<T extends situacaosolicsenhaDeleteArgs>(args: SelectSubset<T, situacaosolicsenhaDeleteArgs<ExtArgs>>): Prisma__situacaosolicsenhaClient<$Result.GetResult<Prisma.$situacaosolicsenhaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Situacaosolicsenha.
     * @param {situacaosolicsenhaUpdateArgs} args - Arguments to update one Situacaosolicsenha.
     * @example
     * // Update one Situacaosolicsenha
     * const situacaosolicsenha = await prisma.situacaosolicsenha.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends situacaosolicsenhaUpdateArgs>(args: SelectSubset<T, situacaosolicsenhaUpdateArgs<ExtArgs>>): Prisma__situacaosolicsenhaClient<$Result.GetResult<Prisma.$situacaosolicsenhaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Situacaosolicsenhas.
     * @param {situacaosolicsenhaDeleteManyArgs} args - Arguments to filter Situacaosolicsenhas to delete.
     * @example
     * // Delete a few Situacaosolicsenhas
     * const { count } = await prisma.situacaosolicsenha.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends situacaosolicsenhaDeleteManyArgs>(args?: SelectSubset<T, situacaosolicsenhaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Situacaosolicsenhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {situacaosolicsenhaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Situacaosolicsenhas
     * const situacaosolicsenha = await prisma.situacaosolicsenha.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends situacaosolicsenhaUpdateManyArgs>(args: SelectSubset<T, situacaosolicsenhaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Situacaosolicsenha.
     * @param {situacaosolicsenhaUpsertArgs} args - Arguments to update or create a Situacaosolicsenha.
     * @example
     * // Update or create a Situacaosolicsenha
     * const situacaosolicsenha = await prisma.situacaosolicsenha.upsert({
     *   create: {
     *     // ... data to create a Situacaosolicsenha
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Situacaosolicsenha we want to update
     *   }
     * })
     */
    upsert<T extends situacaosolicsenhaUpsertArgs>(args: SelectSubset<T, situacaosolicsenhaUpsertArgs<ExtArgs>>): Prisma__situacaosolicsenhaClient<$Result.GetResult<Prisma.$situacaosolicsenhaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Situacaosolicsenhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {situacaosolicsenhaCountArgs} args - Arguments to filter Situacaosolicsenhas to count.
     * @example
     * // Count the number of Situacaosolicsenhas
     * const count = await prisma.situacaosolicsenha.count({
     *   where: {
     *     // ... the filter for the Situacaosolicsenhas we want to count
     *   }
     * })
    **/
    count<T extends situacaosolicsenhaCountArgs>(
      args?: Subset<T, situacaosolicsenhaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SituacaosolicsenhaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Situacaosolicsenha.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SituacaosolicsenhaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SituacaosolicsenhaAggregateArgs>(args: Subset<T, SituacaosolicsenhaAggregateArgs>): Prisma.PrismaPromise<GetSituacaosolicsenhaAggregateType<T>>

    /**
     * Group by Situacaosolicsenha.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {situacaosolicsenhaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends situacaosolicsenhaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: situacaosolicsenhaGroupByArgs['orderBy'] }
        : { orderBy?: situacaosolicsenhaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, situacaosolicsenhaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSituacaosolicsenhaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the situacaosolicsenha model
   */
  readonly fields: situacaosolicsenhaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for situacaosolicsenha.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__situacaosolicsenhaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the situacaosolicsenha model
   */
  interface situacaosolicsenhaFieldRefs {
    readonly id: FieldRef<"situacaosolicsenha", 'Int'>
    readonly descricao: FieldRef<"situacaosolicsenha", 'String'>
    readonly createdAt: FieldRef<"situacaosolicsenha", 'DateTime'>
    readonly updatedAt: FieldRef<"situacaosolicsenha", 'DateTime'>
    readonly telaSolicitar: FieldRef<"situacaosolicsenha", 'Boolean'>
    readonly telaAtualizar: FieldRef<"situacaosolicsenha", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * situacaosolicsenha findUnique
   */
  export type situacaosolicsenhaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacaosolicsenha
     */
    select?: situacaosolicsenhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacaosolicsenha
     */
    omit?: situacaosolicsenhaOmit<ExtArgs> | null
    /**
     * Filter, which situacaosolicsenha to fetch.
     */
    where: situacaosolicsenhaWhereUniqueInput
  }

  /**
   * situacaosolicsenha findUniqueOrThrow
   */
  export type situacaosolicsenhaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacaosolicsenha
     */
    select?: situacaosolicsenhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacaosolicsenha
     */
    omit?: situacaosolicsenhaOmit<ExtArgs> | null
    /**
     * Filter, which situacaosolicsenha to fetch.
     */
    where: situacaosolicsenhaWhereUniqueInput
  }

  /**
   * situacaosolicsenha findFirst
   */
  export type situacaosolicsenhaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacaosolicsenha
     */
    select?: situacaosolicsenhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacaosolicsenha
     */
    omit?: situacaosolicsenhaOmit<ExtArgs> | null
    /**
     * Filter, which situacaosolicsenha to fetch.
     */
    where?: situacaosolicsenhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of situacaosolicsenhas to fetch.
     */
    orderBy?: situacaosolicsenhaOrderByWithRelationInput | situacaosolicsenhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for situacaosolicsenhas.
     */
    cursor?: situacaosolicsenhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` situacaosolicsenhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` situacaosolicsenhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of situacaosolicsenhas.
     */
    distinct?: SituacaosolicsenhaScalarFieldEnum | SituacaosolicsenhaScalarFieldEnum[]
  }

  /**
   * situacaosolicsenha findFirstOrThrow
   */
  export type situacaosolicsenhaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacaosolicsenha
     */
    select?: situacaosolicsenhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacaosolicsenha
     */
    omit?: situacaosolicsenhaOmit<ExtArgs> | null
    /**
     * Filter, which situacaosolicsenha to fetch.
     */
    where?: situacaosolicsenhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of situacaosolicsenhas to fetch.
     */
    orderBy?: situacaosolicsenhaOrderByWithRelationInput | situacaosolicsenhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for situacaosolicsenhas.
     */
    cursor?: situacaosolicsenhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` situacaosolicsenhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` situacaosolicsenhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of situacaosolicsenhas.
     */
    distinct?: SituacaosolicsenhaScalarFieldEnum | SituacaosolicsenhaScalarFieldEnum[]
  }

  /**
   * situacaosolicsenha findMany
   */
  export type situacaosolicsenhaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacaosolicsenha
     */
    select?: situacaosolicsenhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacaosolicsenha
     */
    omit?: situacaosolicsenhaOmit<ExtArgs> | null
    /**
     * Filter, which situacaosolicsenhas to fetch.
     */
    where?: situacaosolicsenhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of situacaosolicsenhas to fetch.
     */
    orderBy?: situacaosolicsenhaOrderByWithRelationInput | situacaosolicsenhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing situacaosolicsenhas.
     */
    cursor?: situacaosolicsenhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` situacaosolicsenhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` situacaosolicsenhas.
     */
    skip?: number
    distinct?: SituacaosolicsenhaScalarFieldEnum | SituacaosolicsenhaScalarFieldEnum[]
  }

  /**
   * situacaosolicsenha create
   */
  export type situacaosolicsenhaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacaosolicsenha
     */
    select?: situacaosolicsenhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacaosolicsenha
     */
    omit?: situacaosolicsenhaOmit<ExtArgs> | null
    /**
     * The data needed to create a situacaosolicsenha.
     */
    data: XOR<situacaosolicsenhaCreateInput, situacaosolicsenhaUncheckedCreateInput>
  }

  /**
   * situacaosolicsenha createMany
   */
  export type situacaosolicsenhaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many situacaosolicsenhas.
     */
    data: situacaosolicsenhaCreateManyInput | situacaosolicsenhaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * situacaosolicsenha update
   */
  export type situacaosolicsenhaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacaosolicsenha
     */
    select?: situacaosolicsenhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacaosolicsenha
     */
    omit?: situacaosolicsenhaOmit<ExtArgs> | null
    /**
     * The data needed to update a situacaosolicsenha.
     */
    data: XOR<situacaosolicsenhaUpdateInput, situacaosolicsenhaUncheckedUpdateInput>
    /**
     * Choose, which situacaosolicsenha to update.
     */
    where: situacaosolicsenhaWhereUniqueInput
  }

  /**
   * situacaosolicsenha updateMany
   */
  export type situacaosolicsenhaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update situacaosolicsenhas.
     */
    data: XOR<situacaosolicsenhaUpdateManyMutationInput, situacaosolicsenhaUncheckedUpdateManyInput>
    /**
     * Filter which situacaosolicsenhas to update
     */
    where?: situacaosolicsenhaWhereInput
    /**
     * Limit how many situacaosolicsenhas to update.
     */
    limit?: number
  }

  /**
   * situacaosolicsenha upsert
   */
  export type situacaosolicsenhaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacaosolicsenha
     */
    select?: situacaosolicsenhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacaosolicsenha
     */
    omit?: situacaosolicsenhaOmit<ExtArgs> | null
    /**
     * The filter to search for the situacaosolicsenha to update in case it exists.
     */
    where: situacaosolicsenhaWhereUniqueInput
    /**
     * In case the situacaosolicsenha found by the `where` argument doesn't exist, create a new situacaosolicsenha with this data.
     */
    create: XOR<situacaosolicsenhaCreateInput, situacaosolicsenhaUncheckedCreateInput>
    /**
     * In case the situacaosolicsenha was found with the provided `where` argument, update it with this data.
     */
    update: XOR<situacaosolicsenhaUpdateInput, situacaosolicsenhaUncheckedUpdateInput>
  }

  /**
   * situacaosolicsenha delete
   */
  export type situacaosolicsenhaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacaosolicsenha
     */
    select?: situacaosolicsenhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacaosolicsenha
     */
    omit?: situacaosolicsenhaOmit<ExtArgs> | null
    /**
     * Filter which situacaosolicsenha to delete.
     */
    where: situacaosolicsenhaWhereUniqueInput
  }

  /**
   * situacaosolicsenha deleteMany
   */
  export type situacaosolicsenhaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which situacaosolicsenhas to delete
     */
    where?: situacaosolicsenhaWhereInput
    /**
     * Limit how many situacaosolicsenhas to delete.
     */
    limit?: number
  }

  /**
   * situacaosolicsenha without action
   */
  export type situacaosolicsenhaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the situacaosolicsenha
     */
    select?: situacaosolicsenhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the situacaosolicsenha
     */
    omit?: situacaosolicsenhaOmit<ExtArgs> | null
  }


  /**
   * Model statussolicitacaoservico
   */

  export type AggregateStatussolicitacaoservico = {
    _count: StatussolicitacaoservicoCountAggregateOutputType | null
    _avg: StatussolicitacaoservicoAvgAggregateOutputType | null
    _sum: StatussolicitacaoservicoSumAggregateOutputType | null
    _min: StatussolicitacaoservicoMinAggregateOutputType | null
    _max: StatussolicitacaoservicoMaxAggregateOutputType | null
  }

  export type StatussolicitacaoservicoAvgAggregateOutputType = {
    id: number | null
    codigo: number | null
  }

  export type StatussolicitacaoservicoSumAggregateOutputType = {
    id: number | null
    codigo: number | null
  }

  export type StatussolicitacaoservicoMinAggregateOutputType = {
    id: number | null
    codigo: number | null
    descricao: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatussolicitacaoservicoMaxAggregateOutputType = {
    id: number | null
    codigo: number | null
    descricao: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatussolicitacaoservicoCountAggregateOutputType = {
    id: number
    codigo: number
    descricao: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StatussolicitacaoservicoAvgAggregateInputType = {
    id?: true
    codigo?: true
  }

  export type StatussolicitacaoservicoSumAggregateInputType = {
    id?: true
    codigo?: true
  }

  export type StatussolicitacaoservicoMinAggregateInputType = {
    id?: true
    codigo?: true
    descricao?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatussolicitacaoservicoMaxAggregateInputType = {
    id?: true
    codigo?: true
    descricao?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatussolicitacaoservicoCountAggregateInputType = {
    id?: true
    codigo?: true
    descricao?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StatussolicitacaoservicoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which statussolicitacaoservico to aggregate.
     */
    where?: statussolicitacaoservicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statussolicitacaoservicos to fetch.
     */
    orderBy?: statussolicitacaoservicoOrderByWithRelationInput | statussolicitacaoservicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: statussolicitacaoservicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statussolicitacaoservicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statussolicitacaoservicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned statussolicitacaoservicos
    **/
    _count?: true | StatussolicitacaoservicoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatussolicitacaoservicoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatussolicitacaoservicoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatussolicitacaoservicoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatussolicitacaoservicoMaxAggregateInputType
  }

  export type GetStatussolicitacaoservicoAggregateType<T extends StatussolicitacaoservicoAggregateArgs> = {
        [P in keyof T & keyof AggregateStatussolicitacaoservico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatussolicitacaoservico[P]>
      : GetScalarType<T[P], AggregateStatussolicitacaoservico[P]>
  }




  export type statussolicitacaoservicoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: statussolicitacaoservicoWhereInput
    orderBy?: statussolicitacaoservicoOrderByWithAggregationInput | statussolicitacaoservicoOrderByWithAggregationInput[]
    by: StatussolicitacaoservicoScalarFieldEnum[] | StatussolicitacaoservicoScalarFieldEnum
    having?: statussolicitacaoservicoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatussolicitacaoservicoCountAggregateInputType | true
    _avg?: StatussolicitacaoservicoAvgAggregateInputType
    _sum?: StatussolicitacaoservicoSumAggregateInputType
    _min?: StatussolicitacaoservicoMinAggregateInputType
    _max?: StatussolicitacaoservicoMaxAggregateInputType
  }

  export type StatussolicitacaoservicoGroupByOutputType = {
    id: number
    codigo: number
    descricao: string
    createdAt: Date
    updatedAt: Date
    _count: StatussolicitacaoservicoCountAggregateOutputType | null
    _avg: StatussolicitacaoservicoAvgAggregateOutputType | null
    _sum: StatussolicitacaoservicoSumAggregateOutputType | null
    _min: StatussolicitacaoservicoMinAggregateOutputType | null
    _max: StatussolicitacaoservicoMaxAggregateOutputType | null
  }

  type GetStatussolicitacaoservicoGroupByPayload<T extends statussolicitacaoservicoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatussolicitacaoservicoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatussolicitacaoservicoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatussolicitacaoservicoGroupByOutputType[P]>
            : GetScalarType<T[P], StatussolicitacaoservicoGroupByOutputType[P]>
        }
      >
    >


  export type statussolicitacaoservicoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    descricao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["statussolicitacaoservico"]>



  export type statussolicitacaoservicoSelectScalar = {
    id?: boolean
    codigo?: boolean
    descricao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type statussolicitacaoservicoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codigo" | "descricao" | "createdAt" | "updatedAt", ExtArgs["result"]["statussolicitacaoservico"]>

  export type $statussolicitacaoservicoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "statussolicitacaoservico"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigo: number
      descricao: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["statussolicitacaoservico"]>
    composites: {}
  }

  type statussolicitacaoservicoGetPayload<S extends boolean | null | undefined | statussolicitacaoservicoDefaultArgs> = $Result.GetResult<Prisma.$statussolicitacaoservicoPayload, S>

  type statussolicitacaoservicoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<statussolicitacaoservicoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatussolicitacaoservicoCountAggregateInputType | true
    }

  export interface statussolicitacaoservicoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['statussolicitacaoservico'], meta: { name: 'statussolicitacaoservico' } }
    /**
     * Find zero or one Statussolicitacaoservico that matches the filter.
     * @param {statussolicitacaoservicoFindUniqueArgs} args - Arguments to find a Statussolicitacaoservico
     * @example
     * // Get one Statussolicitacaoservico
     * const statussolicitacaoservico = await prisma.statussolicitacaoservico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends statussolicitacaoservicoFindUniqueArgs>(args: SelectSubset<T, statussolicitacaoservicoFindUniqueArgs<ExtArgs>>): Prisma__statussolicitacaoservicoClient<$Result.GetResult<Prisma.$statussolicitacaoservicoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Statussolicitacaoservico that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {statussolicitacaoservicoFindUniqueOrThrowArgs} args - Arguments to find a Statussolicitacaoservico
     * @example
     * // Get one Statussolicitacaoservico
     * const statussolicitacaoservico = await prisma.statussolicitacaoservico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends statussolicitacaoservicoFindUniqueOrThrowArgs>(args: SelectSubset<T, statussolicitacaoservicoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__statussolicitacaoservicoClient<$Result.GetResult<Prisma.$statussolicitacaoservicoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Statussolicitacaoservico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statussolicitacaoservicoFindFirstArgs} args - Arguments to find a Statussolicitacaoservico
     * @example
     * // Get one Statussolicitacaoservico
     * const statussolicitacaoservico = await prisma.statussolicitacaoservico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends statussolicitacaoservicoFindFirstArgs>(args?: SelectSubset<T, statussolicitacaoservicoFindFirstArgs<ExtArgs>>): Prisma__statussolicitacaoservicoClient<$Result.GetResult<Prisma.$statussolicitacaoservicoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Statussolicitacaoservico that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statussolicitacaoservicoFindFirstOrThrowArgs} args - Arguments to find a Statussolicitacaoservico
     * @example
     * // Get one Statussolicitacaoservico
     * const statussolicitacaoservico = await prisma.statussolicitacaoservico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends statussolicitacaoservicoFindFirstOrThrowArgs>(args?: SelectSubset<T, statussolicitacaoservicoFindFirstOrThrowArgs<ExtArgs>>): Prisma__statussolicitacaoservicoClient<$Result.GetResult<Prisma.$statussolicitacaoservicoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Statussolicitacaoservicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statussolicitacaoservicoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Statussolicitacaoservicos
     * const statussolicitacaoservicos = await prisma.statussolicitacaoservico.findMany()
     * 
     * // Get first 10 Statussolicitacaoservicos
     * const statussolicitacaoservicos = await prisma.statussolicitacaoservico.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statussolicitacaoservicoWithIdOnly = await prisma.statussolicitacaoservico.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends statussolicitacaoservicoFindManyArgs>(args?: SelectSubset<T, statussolicitacaoservicoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statussolicitacaoservicoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Statussolicitacaoservico.
     * @param {statussolicitacaoservicoCreateArgs} args - Arguments to create a Statussolicitacaoservico.
     * @example
     * // Create one Statussolicitacaoservico
     * const Statussolicitacaoservico = await prisma.statussolicitacaoservico.create({
     *   data: {
     *     // ... data to create a Statussolicitacaoservico
     *   }
     * })
     * 
     */
    create<T extends statussolicitacaoservicoCreateArgs>(args: SelectSubset<T, statussolicitacaoservicoCreateArgs<ExtArgs>>): Prisma__statussolicitacaoservicoClient<$Result.GetResult<Prisma.$statussolicitacaoservicoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Statussolicitacaoservicos.
     * @param {statussolicitacaoservicoCreateManyArgs} args - Arguments to create many Statussolicitacaoservicos.
     * @example
     * // Create many Statussolicitacaoservicos
     * const statussolicitacaoservico = await prisma.statussolicitacaoservico.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends statussolicitacaoservicoCreateManyArgs>(args?: SelectSubset<T, statussolicitacaoservicoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Statussolicitacaoservico.
     * @param {statussolicitacaoservicoDeleteArgs} args - Arguments to delete one Statussolicitacaoservico.
     * @example
     * // Delete one Statussolicitacaoservico
     * const Statussolicitacaoservico = await prisma.statussolicitacaoservico.delete({
     *   where: {
     *     // ... filter to delete one Statussolicitacaoservico
     *   }
     * })
     * 
     */
    delete<T extends statussolicitacaoservicoDeleteArgs>(args: SelectSubset<T, statussolicitacaoservicoDeleteArgs<ExtArgs>>): Prisma__statussolicitacaoservicoClient<$Result.GetResult<Prisma.$statussolicitacaoservicoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Statussolicitacaoservico.
     * @param {statussolicitacaoservicoUpdateArgs} args - Arguments to update one Statussolicitacaoservico.
     * @example
     * // Update one Statussolicitacaoservico
     * const statussolicitacaoservico = await prisma.statussolicitacaoservico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends statussolicitacaoservicoUpdateArgs>(args: SelectSubset<T, statussolicitacaoservicoUpdateArgs<ExtArgs>>): Prisma__statussolicitacaoservicoClient<$Result.GetResult<Prisma.$statussolicitacaoservicoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Statussolicitacaoservicos.
     * @param {statussolicitacaoservicoDeleteManyArgs} args - Arguments to filter Statussolicitacaoservicos to delete.
     * @example
     * // Delete a few Statussolicitacaoservicos
     * const { count } = await prisma.statussolicitacaoservico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends statussolicitacaoservicoDeleteManyArgs>(args?: SelectSubset<T, statussolicitacaoservicoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statussolicitacaoservicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statussolicitacaoservicoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Statussolicitacaoservicos
     * const statussolicitacaoservico = await prisma.statussolicitacaoservico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends statussolicitacaoservicoUpdateManyArgs>(args: SelectSubset<T, statussolicitacaoservicoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Statussolicitacaoservico.
     * @param {statussolicitacaoservicoUpsertArgs} args - Arguments to update or create a Statussolicitacaoservico.
     * @example
     * // Update or create a Statussolicitacaoservico
     * const statussolicitacaoservico = await prisma.statussolicitacaoservico.upsert({
     *   create: {
     *     // ... data to create a Statussolicitacaoservico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Statussolicitacaoservico we want to update
     *   }
     * })
     */
    upsert<T extends statussolicitacaoservicoUpsertArgs>(args: SelectSubset<T, statussolicitacaoservicoUpsertArgs<ExtArgs>>): Prisma__statussolicitacaoservicoClient<$Result.GetResult<Prisma.$statussolicitacaoservicoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Statussolicitacaoservicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statussolicitacaoservicoCountArgs} args - Arguments to filter Statussolicitacaoservicos to count.
     * @example
     * // Count the number of Statussolicitacaoservicos
     * const count = await prisma.statussolicitacaoservico.count({
     *   where: {
     *     // ... the filter for the Statussolicitacaoservicos we want to count
     *   }
     * })
    **/
    count<T extends statussolicitacaoservicoCountArgs>(
      args?: Subset<T, statussolicitacaoservicoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatussolicitacaoservicoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Statussolicitacaoservico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatussolicitacaoservicoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatussolicitacaoservicoAggregateArgs>(args: Subset<T, StatussolicitacaoservicoAggregateArgs>): Prisma.PrismaPromise<GetStatussolicitacaoservicoAggregateType<T>>

    /**
     * Group by Statussolicitacaoservico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statussolicitacaoservicoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends statussolicitacaoservicoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: statussolicitacaoservicoGroupByArgs['orderBy'] }
        : { orderBy?: statussolicitacaoservicoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, statussolicitacaoservicoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatussolicitacaoservicoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the statussolicitacaoservico model
   */
  readonly fields: statussolicitacaoservicoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for statussolicitacaoservico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__statussolicitacaoservicoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the statussolicitacaoservico model
   */
  interface statussolicitacaoservicoFieldRefs {
    readonly id: FieldRef<"statussolicitacaoservico", 'Int'>
    readonly codigo: FieldRef<"statussolicitacaoservico", 'Int'>
    readonly descricao: FieldRef<"statussolicitacaoservico", 'String'>
    readonly createdAt: FieldRef<"statussolicitacaoservico", 'DateTime'>
    readonly updatedAt: FieldRef<"statussolicitacaoservico", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * statussolicitacaoservico findUnique
   */
  export type statussolicitacaoservicoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statussolicitacaoservico
     */
    select?: statussolicitacaoservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statussolicitacaoservico
     */
    omit?: statussolicitacaoservicoOmit<ExtArgs> | null
    /**
     * Filter, which statussolicitacaoservico to fetch.
     */
    where: statussolicitacaoservicoWhereUniqueInput
  }

  /**
   * statussolicitacaoservico findUniqueOrThrow
   */
  export type statussolicitacaoservicoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statussolicitacaoservico
     */
    select?: statussolicitacaoservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statussolicitacaoservico
     */
    omit?: statussolicitacaoservicoOmit<ExtArgs> | null
    /**
     * Filter, which statussolicitacaoservico to fetch.
     */
    where: statussolicitacaoservicoWhereUniqueInput
  }

  /**
   * statussolicitacaoservico findFirst
   */
  export type statussolicitacaoservicoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statussolicitacaoservico
     */
    select?: statussolicitacaoservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statussolicitacaoservico
     */
    omit?: statussolicitacaoservicoOmit<ExtArgs> | null
    /**
     * Filter, which statussolicitacaoservico to fetch.
     */
    where?: statussolicitacaoservicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statussolicitacaoservicos to fetch.
     */
    orderBy?: statussolicitacaoservicoOrderByWithRelationInput | statussolicitacaoservicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statussolicitacaoservicos.
     */
    cursor?: statussolicitacaoservicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statussolicitacaoservicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statussolicitacaoservicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statussolicitacaoservicos.
     */
    distinct?: StatussolicitacaoservicoScalarFieldEnum | StatussolicitacaoservicoScalarFieldEnum[]
  }

  /**
   * statussolicitacaoservico findFirstOrThrow
   */
  export type statussolicitacaoservicoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statussolicitacaoservico
     */
    select?: statussolicitacaoservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statussolicitacaoservico
     */
    omit?: statussolicitacaoservicoOmit<ExtArgs> | null
    /**
     * Filter, which statussolicitacaoservico to fetch.
     */
    where?: statussolicitacaoservicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statussolicitacaoservicos to fetch.
     */
    orderBy?: statussolicitacaoservicoOrderByWithRelationInput | statussolicitacaoservicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for statussolicitacaoservicos.
     */
    cursor?: statussolicitacaoservicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statussolicitacaoservicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statussolicitacaoservicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of statussolicitacaoservicos.
     */
    distinct?: StatussolicitacaoservicoScalarFieldEnum | StatussolicitacaoservicoScalarFieldEnum[]
  }

  /**
   * statussolicitacaoservico findMany
   */
  export type statussolicitacaoservicoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statussolicitacaoservico
     */
    select?: statussolicitacaoservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statussolicitacaoservico
     */
    omit?: statussolicitacaoservicoOmit<ExtArgs> | null
    /**
     * Filter, which statussolicitacaoservicos to fetch.
     */
    where?: statussolicitacaoservicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of statussolicitacaoservicos to fetch.
     */
    orderBy?: statussolicitacaoservicoOrderByWithRelationInput | statussolicitacaoservicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing statussolicitacaoservicos.
     */
    cursor?: statussolicitacaoservicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` statussolicitacaoservicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` statussolicitacaoservicos.
     */
    skip?: number
    distinct?: StatussolicitacaoservicoScalarFieldEnum | StatussolicitacaoservicoScalarFieldEnum[]
  }

  /**
   * statussolicitacaoservico create
   */
  export type statussolicitacaoservicoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statussolicitacaoservico
     */
    select?: statussolicitacaoservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statussolicitacaoservico
     */
    omit?: statussolicitacaoservicoOmit<ExtArgs> | null
    /**
     * The data needed to create a statussolicitacaoservico.
     */
    data: XOR<statussolicitacaoservicoCreateInput, statussolicitacaoservicoUncheckedCreateInput>
  }

  /**
   * statussolicitacaoservico createMany
   */
  export type statussolicitacaoservicoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many statussolicitacaoservicos.
     */
    data: statussolicitacaoservicoCreateManyInput | statussolicitacaoservicoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * statussolicitacaoservico update
   */
  export type statussolicitacaoservicoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statussolicitacaoservico
     */
    select?: statussolicitacaoservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statussolicitacaoservico
     */
    omit?: statussolicitacaoservicoOmit<ExtArgs> | null
    /**
     * The data needed to update a statussolicitacaoservico.
     */
    data: XOR<statussolicitacaoservicoUpdateInput, statussolicitacaoservicoUncheckedUpdateInput>
    /**
     * Choose, which statussolicitacaoservico to update.
     */
    where: statussolicitacaoservicoWhereUniqueInput
  }

  /**
   * statussolicitacaoservico updateMany
   */
  export type statussolicitacaoservicoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update statussolicitacaoservicos.
     */
    data: XOR<statussolicitacaoservicoUpdateManyMutationInput, statussolicitacaoservicoUncheckedUpdateManyInput>
    /**
     * Filter which statussolicitacaoservicos to update
     */
    where?: statussolicitacaoservicoWhereInput
    /**
     * Limit how many statussolicitacaoservicos to update.
     */
    limit?: number
  }

  /**
   * statussolicitacaoservico upsert
   */
  export type statussolicitacaoservicoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statussolicitacaoservico
     */
    select?: statussolicitacaoservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statussolicitacaoservico
     */
    omit?: statussolicitacaoservicoOmit<ExtArgs> | null
    /**
     * The filter to search for the statussolicitacaoservico to update in case it exists.
     */
    where: statussolicitacaoservicoWhereUniqueInput
    /**
     * In case the statussolicitacaoservico found by the `where` argument doesn't exist, create a new statussolicitacaoservico with this data.
     */
    create: XOR<statussolicitacaoservicoCreateInput, statussolicitacaoservicoUncheckedCreateInput>
    /**
     * In case the statussolicitacaoservico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<statussolicitacaoservicoUpdateInput, statussolicitacaoservicoUncheckedUpdateInput>
  }

  /**
   * statussolicitacaoservico delete
   */
  export type statussolicitacaoservicoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statussolicitacaoservico
     */
    select?: statussolicitacaoservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statussolicitacaoservico
     */
    omit?: statussolicitacaoservicoOmit<ExtArgs> | null
    /**
     * Filter which statussolicitacaoservico to delete.
     */
    where: statussolicitacaoservicoWhereUniqueInput
  }

  /**
   * statussolicitacaoservico deleteMany
   */
  export type statussolicitacaoservicoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which statussolicitacaoservicos to delete
     */
    where?: statussolicitacaoservicoWhereInput
    /**
     * Limit how many statussolicitacaoservicos to delete.
     */
    limit?: number
  }

  /**
   * statussolicitacaoservico without action
   */
  export type statussolicitacaoservicoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the statussolicitacaoservico
     */
    select?: statussolicitacaoservicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the statussolicitacaoservico
     */
    omit?: statussolicitacaoservicoOmit<ExtArgs> | null
  }


  /**
   * Model tiposervico
   */

  export type AggregateTiposervico = {
    _count: TiposervicoCountAggregateOutputType | null
    _avg: TiposervicoAvgAggregateOutputType | null
    _sum: TiposervicoSumAggregateOutputType | null
    _min: TiposervicoMinAggregateOutputType | null
    _max: TiposervicoMaxAggregateOutputType | null
  }

  export type TiposervicoAvgAggregateOutputType = {
    id: number | null
    valorCusto: number | null
    valorVenda: number | null
    usuario_cad: number | null
    usuario_alt: number | null
    idfornecedor: number | null
  }

  export type TiposervicoSumAggregateOutputType = {
    id: number | null
    valorCusto: number | null
    valorVenda: number | null
    usuario_cad: number | null
    usuario_alt: number | null
    idfornecedor: number | null
  }

  export type TiposervicoMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    createdAt: Date | null
    updatedAt: Date | null
    valorCusto: number | null
    valorVenda: number | null
    ativo: boolean | null
    observacao: string | null
    usuario_cad: number | null
    usuario_alt: number | null
    idfornecedor: number | null
  }

  export type TiposervicoMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    createdAt: Date | null
    updatedAt: Date | null
    valorCusto: number | null
    valorVenda: number | null
    ativo: boolean | null
    observacao: string | null
    usuario_cad: number | null
    usuario_alt: number | null
    idfornecedor: number | null
  }

  export type TiposervicoCountAggregateOutputType = {
    id: number
    descricao: number
    createdAt: number
    updatedAt: number
    valorCusto: number
    valorVenda: number
    ativo: number
    observacao: number
    usuario_cad: number
    usuario_alt: number
    idfornecedor: number
    _all: number
  }


  export type TiposervicoAvgAggregateInputType = {
    id?: true
    valorCusto?: true
    valorVenda?: true
    usuario_cad?: true
    usuario_alt?: true
    idfornecedor?: true
  }

  export type TiposervicoSumAggregateInputType = {
    id?: true
    valorCusto?: true
    valorVenda?: true
    usuario_cad?: true
    usuario_alt?: true
    idfornecedor?: true
  }

  export type TiposervicoMinAggregateInputType = {
    id?: true
    descricao?: true
    createdAt?: true
    updatedAt?: true
    valorCusto?: true
    valorVenda?: true
    ativo?: true
    observacao?: true
    usuario_cad?: true
    usuario_alt?: true
    idfornecedor?: true
  }

  export type TiposervicoMaxAggregateInputType = {
    id?: true
    descricao?: true
    createdAt?: true
    updatedAt?: true
    valorCusto?: true
    valorVenda?: true
    ativo?: true
    observacao?: true
    usuario_cad?: true
    usuario_alt?: true
    idfornecedor?: true
  }

  export type TiposervicoCountAggregateInputType = {
    id?: true
    descricao?: true
    createdAt?: true
    updatedAt?: true
    valorCusto?: true
    valorVenda?: true
    ativo?: true
    observacao?: true
    usuario_cad?: true
    usuario_alt?: true
    idfornecedor?: true
    _all?: true
  }

  export type TiposervicoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tiposervico to aggregate.
     */
    where?: tiposervicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tiposervicos to fetch.
     */
    orderBy?: tiposervicoOrderByWithRelationInput | tiposervicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tiposervicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tiposervicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tiposervicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tiposervicos
    **/
    _count?: true | TiposervicoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TiposervicoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TiposervicoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TiposervicoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TiposervicoMaxAggregateInputType
  }

  export type GetTiposervicoAggregateType<T extends TiposervicoAggregateArgs> = {
        [P in keyof T & keyof AggregateTiposervico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTiposervico[P]>
      : GetScalarType<T[P], AggregateTiposervico[P]>
  }




  export type tiposervicoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tiposervicoWhereInput
    orderBy?: tiposervicoOrderByWithAggregationInput | tiposervicoOrderByWithAggregationInput[]
    by: TiposervicoScalarFieldEnum[] | TiposervicoScalarFieldEnum
    having?: tiposervicoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TiposervicoCountAggregateInputType | true
    _avg?: TiposervicoAvgAggregateInputType
    _sum?: TiposervicoSumAggregateInputType
    _min?: TiposervicoMinAggregateInputType
    _max?: TiposervicoMaxAggregateInputType
  }

  export type TiposervicoGroupByOutputType = {
    id: number
    descricao: string
    createdAt: Date
    updatedAt: Date
    valorCusto: number
    valorVenda: number
    ativo: boolean
    observacao: string | null
    usuario_cad: number
    usuario_alt: number
    idfornecedor: number
    _count: TiposervicoCountAggregateOutputType | null
    _avg: TiposervicoAvgAggregateOutputType | null
    _sum: TiposervicoSumAggregateOutputType | null
    _min: TiposervicoMinAggregateOutputType | null
    _max: TiposervicoMaxAggregateOutputType | null
  }

  type GetTiposervicoGroupByPayload<T extends tiposervicoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TiposervicoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TiposervicoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TiposervicoGroupByOutputType[P]>
            : GetScalarType<T[P], TiposervicoGroupByOutputType[P]>
        }
      >
    >


  export type tiposervicoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    valorCusto?: boolean
    valorVenda?: boolean
    ativo?: boolean
    observacao?: boolean
    usuario_cad?: boolean
    usuario_alt?: boolean
    idfornecedor?: boolean
  }, ExtArgs["result"]["tiposervico"]>



  export type tiposervicoSelectScalar = {
    id?: boolean
    descricao?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    valorCusto?: boolean
    valorVenda?: boolean
    ativo?: boolean
    observacao?: boolean
    usuario_cad?: boolean
    usuario_alt?: boolean
    idfornecedor?: boolean
  }

  export type tiposervicoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "createdAt" | "updatedAt" | "valorCusto" | "valorVenda" | "ativo" | "observacao" | "usuario_cad" | "usuario_alt" | "idfornecedor", ExtArgs["result"]["tiposervico"]>

  export type $tiposervicoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tiposervico"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      createdAt: Date
      updatedAt: Date
      valorCusto: number
      valorVenda: number
      ativo: boolean
      observacao: string | null
      usuario_cad: number
      usuario_alt: number
      idfornecedor: number
    }, ExtArgs["result"]["tiposervico"]>
    composites: {}
  }

  type tiposervicoGetPayload<S extends boolean | null | undefined | tiposervicoDefaultArgs> = $Result.GetResult<Prisma.$tiposervicoPayload, S>

  type tiposervicoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tiposervicoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TiposervicoCountAggregateInputType | true
    }

  export interface tiposervicoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tiposervico'], meta: { name: 'tiposervico' } }
    /**
     * Find zero or one Tiposervico that matches the filter.
     * @param {tiposervicoFindUniqueArgs} args - Arguments to find a Tiposervico
     * @example
     * // Get one Tiposervico
     * const tiposervico = await prisma.tiposervico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tiposervicoFindUniqueArgs>(args: SelectSubset<T, tiposervicoFindUniqueArgs<ExtArgs>>): Prisma__tiposervicoClient<$Result.GetResult<Prisma.$tiposervicoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tiposervico that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tiposervicoFindUniqueOrThrowArgs} args - Arguments to find a Tiposervico
     * @example
     * // Get one Tiposervico
     * const tiposervico = await prisma.tiposervico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tiposervicoFindUniqueOrThrowArgs>(args: SelectSubset<T, tiposervicoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tiposervicoClient<$Result.GetResult<Prisma.$tiposervicoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tiposervico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tiposervicoFindFirstArgs} args - Arguments to find a Tiposervico
     * @example
     * // Get one Tiposervico
     * const tiposervico = await prisma.tiposervico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tiposervicoFindFirstArgs>(args?: SelectSubset<T, tiposervicoFindFirstArgs<ExtArgs>>): Prisma__tiposervicoClient<$Result.GetResult<Prisma.$tiposervicoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tiposervico that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tiposervicoFindFirstOrThrowArgs} args - Arguments to find a Tiposervico
     * @example
     * // Get one Tiposervico
     * const tiposervico = await prisma.tiposervico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tiposervicoFindFirstOrThrowArgs>(args?: SelectSubset<T, tiposervicoFindFirstOrThrowArgs<ExtArgs>>): Prisma__tiposervicoClient<$Result.GetResult<Prisma.$tiposervicoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tiposervicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tiposervicoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tiposervicos
     * const tiposervicos = await prisma.tiposervico.findMany()
     * 
     * // Get first 10 Tiposervicos
     * const tiposervicos = await prisma.tiposervico.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tiposervicoWithIdOnly = await prisma.tiposervico.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tiposervicoFindManyArgs>(args?: SelectSubset<T, tiposervicoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tiposervicoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tiposervico.
     * @param {tiposervicoCreateArgs} args - Arguments to create a Tiposervico.
     * @example
     * // Create one Tiposervico
     * const Tiposervico = await prisma.tiposervico.create({
     *   data: {
     *     // ... data to create a Tiposervico
     *   }
     * })
     * 
     */
    create<T extends tiposervicoCreateArgs>(args: SelectSubset<T, tiposervicoCreateArgs<ExtArgs>>): Prisma__tiposervicoClient<$Result.GetResult<Prisma.$tiposervicoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tiposervicos.
     * @param {tiposervicoCreateManyArgs} args - Arguments to create many Tiposervicos.
     * @example
     * // Create many Tiposervicos
     * const tiposervico = await prisma.tiposervico.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tiposervicoCreateManyArgs>(args?: SelectSubset<T, tiposervicoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tiposervico.
     * @param {tiposervicoDeleteArgs} args - Arguments to delete one Tiposervico.
     * @example
     * // Delete one Tiposervico
     * const Tiposervico = await prisma.tiposervico.delete({
     *   where: {
     *     // ... filter to delete one Tiposervico
     *   }
     * })
     * 
     */
    delete<T extends tiposervicoDeleteArgs>(args: SelectSubset<T, tiposervicoDeleteArgs<ExtArgs>>): Prisma__tiposervicoClient<$Result.GetResult<Prisma.$tiposervicoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tiposervico.
     * @param {tiposervicoUpdateArgs} args - Arguments to update one Tiposervico.
     * @example
     * // Update one Tiposervico
     * const tiposervico = await prisma.tiposervico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tiposervicoUpdateArgs>(args: SelectSubset<T, tiposervicoUpdateArgs<ExtArgs>>): Prisma__tiposervicoClient<$Result.GetResult<Prisma.$tiposervicoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tiposervicos.
     * @param {tiposervicoDeleteManyArgs} args - Arguments to filter Tiposervicos to delete.
     * @example
     * // Delete a few Tiposervicos
     * const { count } = await prisma.tiposervico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tiposervicoDeleteManyArgs>(args?: SelectSubset<T, tiposervicoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tiposervicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tiposervicoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tiposervicos
     * const tiposervico = await prisma.tiposervico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tiposervicoUpdateManyArgs>(args: SelectSubset<T, tiposervicoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tiposervico.
     * @param {tiposervicoUpsertArgs} args - Arguments to update or create a Tiposervico.
     * @example
     * // Update or create a Tiposervico
     * const tiposervico = await prisma.tiposervico.upsert({
     *   create: {
     *     // ... data to create a Tiposervico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tiposervico we want to update
     *   }
     * })
     */
    upsert<T extends tiposervicoUpsertArgs>(args: SelectSubset<T, tiposervicoUpsertArgs<ExtArgs>>): Prisma__tiposervicoClient<$Result.GetResult<Prisma.$tiposervicoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tiposervicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tiposervicoCountArgs} args - Arguments to filter Tiposervicos to count.
     * @example
     * // Count the number of Tiposervicos
     * const count = await prisma.tiposervico.count({
     *   where: {
     *     // ... the filter for the Tiposervicos we want to count
     *   }
     * })
    **/
    count<T extends tiposervicoCountArgs>(
      args?: Subset<T, tiposervicoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TiposervicoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tiposervico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiposervicoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TiposervicoAggregateArgs>(args: Subset<T, TiposervicoAggregateArgs>): Prisma.PrismaPromise<GetTiposervicoAggregateType<T>>

    /**
     * Group by Tiposervico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tiposervicoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tiposervicoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tiposervicoGroupByArgs['orderBy'] }
        : { orderBy?: tiposervicoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tiposervicoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTiposervicoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tiposervico model
   */
  readonly fields: tiposervicoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tiposervico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tiposervicoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tiposervico model
   */
  interface tiposervicoFieldRefs {
    readonly id: FieldRef<"tiposervico", 'Int'>
    readonly descricao: FieldRef<"tiposervico", 'String'>
    readonly createdAt: FieldRef<"tiposervico", 'DateTime'>
    readonly updatedAt: FieldRef<"tiposervico", 'DateTime'>
    readonly valorCusto: FieldRef<"tiposervico", 'Float'>
    readonly valorVenda: FieldRef<"tiposervico", 'Float'>
    readonly ativo: FieldRef<"tiposervico", 'Boolean'>
    readonly observacao: FieldRef<"tiposervico", 'String'>
    readonly usuario_cad: FieldRef<"tiposervico", 'Int'>
    readonly usuario_alt: FieldRef<"tiposervico", 'Int'>
    readonly idfornecedor: FieldRef<"tiposervico", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tiposervico findUnique
   */
  export type tiposervicoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiposervico
     */
    select?: tiposervicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tiposervico
     */
    omit?: tiposervicoOmit<ExtArgs> | null
    /**
     * Filter, which tiposervico to fetch.
     */
    where: tiposervicoWhereUniqueInput
  }

  /**
   * tiposervico findUniqueOrThrow
   */
  export type tiposervicoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiposervico
     */
    select?: tiposervicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tiposervico
     */
    omit?: tiposervicoOmit<ExtArgs> | null
    /**
     * Filter, which tiposervico to fetch.
     */
    where: tiposervicoWhereUniqueInput
  }

  /**
   * tiposervico findFirst
   */
  export type tiposervicoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiposervico
     */
    select?: tiposervicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tiposervico
     */
    omit?: tiposervicoOmit<ExtArgs> | null
    /**
     * Filter, which tiposervico to fetch.
     */
    where?: tiposervicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tiposervicos to fetch.
     */
    orderBy?: tiposervicoOrderByWithRelationInput | tiposervicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tiposervicos.
     */
    cursor?: tiposervicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tiposervicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tiposervicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tiposervicos.
     */
    distinct?: TiposervicoScalarFieldEnum | TiposervicoScalarFieldEnum[]
  }

  /**
   * tiposervico findFirstOrThrow
   */
  export type tiposervicoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiposervico
     */
    select?: tiposervicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tiposervico
     */
    omit?: tiposervicoOmit<ExtArgs> | null
    /**
     * Filter, which tiposervico to fetch.
     */
    where?: tiposervicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tiposervicos to fetch.
     */
    orderBy?: tiposervicoOrderByWithRelationInput | tiposervicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tiposervicos.
     */
    cursor?: tiposervicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tiposervicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tiposervicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tiposervicos.
     */
    distinct?: TiposervicoScalarFieldEnum | TiposervicoScalarFieldEnum[]
  }

  /**
   * tiposervico findMany
   */
  export type tiposervicoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiposervico
     */
    select?: tiposervicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tiposervico
     */
    omit?: tiposervicoOmit<ExtArgs> | null
    /**
     * Filter, which tiposervicos to fetch.
     */
    where?: tiposervicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tiposervicos to fetch.
     */
    orderBy?: tiposervicoOrderByWithRelationInput | tiposervicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tiposervicos.
     */
    cursor?: tiposervicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tiposervicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tiposervicos.
     */
    skip?: number
    distinct?: TiposervicoScalarFieldEnum | TiposervicoScalarFieldEnum[]
  }

  /**
   * tiposervico create
   */
  export type tiposervicoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiposervico
     */
    select?: tiposervicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tiposervico
     */
    omit?: tiposervicoOmit<ExtArgs> | null
    /**
     * The data needed to create a tiposervico.
     */
    data: XOR<tiposervicoCreateInput, tiposervicoUncheckedCreateInput>
  }

  /**
   * tiposervico createMany
   */
  export type tiposervicoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tiposervicos.
     */
    data: tiposervicoCreateManyInput | tiposervicoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tiposervico update
   */
  export type tiposervicoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiposervico
     */
    select?: tiposervicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tiposervico
     */
    omit?: tiposervicoOmit<ExtArgs> | null
    /**
     * The data needed to update a tiposervico.
     */
    data: XOR<tiposervicoUpdateInput, tiposervicoUncheckedUpdateInput>
    /**
     * Choose, which tiposervico to update.
     */
    where: tiposervicoWhereUniqueInput
  }

  /**
   * tiposervico updateMany
   */
  export type tiposervicoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tiposervicos.
     */
    data: XOR<tiposervicoUpdateManyMutationInput, tiposervicoUncheckedUpdateManyInput>
    /**
     * Filter which tiposervicos to update
     */
    where?: tiposervicoWhereInput
    /**
     * Limit how many tiposervicos to update.
     */
    limit?: number
  }

  /**
   * tiposervico upsert
   */
  export type tiposervicoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiposervico
     */
    select?: tiposervicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tiposervico
     */
    omit?: tiposervicoOmit<ExtArgs> | null
    /**
     * The filter to search for the tiposervico to update in case it exists.
     */
    where: tiposervicoWhereUniqueInput
    /**
     * In case the tiposervico found by the `where` argument doesn't exist, create a new tiposervico with this data.
     */
    create: XOR<tiposervicoCreateInput, tiposervicoUncheckedCreateInput>
    /**
     * In case the tiposervico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tiposervicoUpdateInput, tiposervicoUncheckedUpdateInput>
  }

  /**
   * tiposervico delete
   */
  export type tiposervicoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiposervico
     */
    select?: tiposervicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tiposervico
     */
    omit?: tiposervicoOmit<ExtArgs> | null
    /**
     * Filter which tiposervico to delete.
     */
    where: tiposervicoWhereUniqueInput
  }

  /**
   * tiposervico deleteMany
   */
  export type tiposervicoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tiposervicos to delete
     */
    where?: tiposervicoWhereInput
    /**
     * Limit how many tiposervicos to delete.
     */
    limit?: number
  }

  /**
   * tiposervico without action
   */
  export type tiposervicoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiposervico
     */
    select?: tiposervicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tiposervico
     */
    omit?: tiposervicoOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BancosScalarFieldEnum: {
    id: 'id',
    codbanco: 'codbanco',
    instituicao: 'instituicao',
    segmento: 'segmento',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BancosScalarFieldEnum = (typeof BancosScalarFieldEnum)[keyof typeof BancosScalarFieldEnum]


  export const ConfiguracaoScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    config: 'config',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConfiguracaoScalarFieldEnum = (typeof ConfiguracaoScalarFieldEnum)[keyof typeof ConfiguracaoScalarFieldEnum]


  export const ConsultasScalarFieldEnum: {
    id: 'id',
    datahora: 'datahora',
    id_servico: 'id_servico',
    beneficio: 'beneficio',
    cpf: 'cpf',
    qtde: 'qtde',
    id_usuario: 'id_usuario',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tipotransacao: 'tipotransacao',
    observacao: 'observacao',
    valor_unit: 'valor_unit',
    matricula_siape: 'matricula_siape',
    tp_serv_origem: 'tp_serv_origem',
    id_extrato_off: 'id_extrato_off',
    origem_sol: 'origem_sol'
  };

  export type ConsultasScalarFieldEnum = (typeof ConsultasScalarFieldEnum)[keyof typeof ConsultasScalarFieldEnum]


  export const ConsultasofflineScalarFieldEnum: {
    id: 'id',
    idConsulta: 'idConsulta',
    erroID: 'erroID',
    idStatusSolicitacaoIn100: 'idStatusSolicitacaoIn100',
    situacao: 'situacao',
    resultado: 'resultado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConsultasofflineScalarFieldEnum = (typeof ConsultasofflineScalarFieldEnum)[keyof typeof ConsultasofflineScalarFieldEnum]


  export const ConsultasofflinesiapeScalarFieldEnum: {
    id: 'id',
    idConsulta: 'idConsulta',
    situacao: 'situacao',
    erroID: 'erroID',
    resultado: 'resultado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConsultasofflinesiapeScalarFieldEnum = (typeof ConsultasofflinesiapeScalarFieldEnum)[keyof typeof ConsultasofflinesiapeScalarFieldEnum]


  export const CreditoScalarFieldEnum: {
    id: 'id',
    datahora: 'datahora',
    valorun: 'valorun',
    vendedor: 'vendedor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    idusu_cli: 'idusu_cli',
    tiposervico: 'tiposervico',
    qtdecreditos: 'qtdecreditos',
    qtderestante: 'qtderestante',
    qtdeutilizada: 'qtdeutilizada'
  };

  export type CreditoScalarFieldEnum = (typeof CreditoScalarFieldEnum)[keyof typeof CreditoScalarFieldEnum]


  export const DesbloqueiosScalarFieldEnum: {
    id: 'id',
    datahora: 'datahora',
    beneficio: 'beneficio',
    cpf: 'cpf',
    protocolo: 'protocolo',
    requerente: 'requerente',
    unidade: 'unidade',
    status: 'status',
    id_usuario: 'id_usuario',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id_usu_desbloqueio: 'id_usu_desbloqueio',
    ddb: 'ddb'
  };

  export type DesbloqueiosScalarFieldEnum = (typeof DesbloqueiosScalarFieldEnum)[keyof typeof DesbloqueiosScalarFieldEnum]


  export const EntrantesinssScalarFieldEnum: {
    id: 'id',
    cpf: 'cpf',
    nome: 'nome',
    nascimento: 'nascimento',
    idade: 'idade',
    beneficio: 'beneficio',
    especie: 'especie',
    salario: 'salario',
    dib: 'dib',
    cidade: 'cidade',
    uf: 'uf',
    bairro: 'bairro',
    cep: 'cep',
    fone: 'fone',
    fone1: 'fone1',
    fone2: 'fone2',
    fone3: 'fone3',
    fone4: 'fone4',
    fone5: 'fone5',
    fone6: 'fone6',
    fone7: 'fone7',
    fone8: 'fone8',
    fone9: 'fone9',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EntrantesinssScalarFieldEnum = (typeof EntrantesinssScalarFieldEnum)[keyof typeof EntrantesinssScalarFieldEnum]


  export const EspeciebeneficioScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    descEspecieBeneficio: 'descEspecieBeneficio',
    gruposEspecie: 'gruposEspecie',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EspeciebeneficioScalarFieldEnum = (typeof EspeciebeneficioScalarFieldEnum)[keyof typeof EspeciebeneficioScalarFieldEnum]


  export const ExtratoofflineScalarFieldEnum: {
    id: 'id',
    cpf: 'cpf',
    beneficio: 'beneficio',
    jsonResult: 'jsonResult',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    idFornecedor: 'idFornecedor',
    idConsulta: 'idConsulta',
    idUsuario: 'idUsuario'
  };

  export type ExtratoofflineScalarFieldEnum = (typeof ExtratoofflineScalarFieldEnum)[keyof typeof ExtratoofflineScalarFieldEnum]


  export const ExtratoonlineScalarFieldEnum: {
    id: 'id',
    idConsulta: 'idConsulta',
    id_fornecedor: 'id_fornecedor',
    beneficio: 'beneficio',
    jsonResult: 'jsonResult',
    filePdf: 'filePdf',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isCache: 'isCache',
    statusConsulta: 'statusConsulta',
    idConsultaOffline: 'idConsultaOffline',
    errorResult: 'errorResult',
    idUsuario: 'idUsuario'
  };

  export type ExtratoonlineScalarFieldEnum = (typeof ExtratoonlineScalarFieldEnum)[keyof typeof ExtratoonlineScalarFieldEnum]


  export const FornecedorScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    cnpj: 'cnpj',
    logradouro: 'logradouro',
    numero: 'numero',
    complemento: 'complemento',
    cep: 'cep',
    cidade: 'cidade',
    estado: 'estado',
    apikey: 'apikey',
    ativo: 'ativo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    urlapi: 'urlapi',
    usuarioApi: 'usuarioApi',
    senhaApi: 'senhaApi',
    dataHoraValidacaoApiKey: 'dataHoraValidacaoApiKey'
  };

  export type FornecedorScalarFieldEnum = (typeof FornecedorScalarFieldEnum)[keyof typeof FornecedorScalarFieldEnum]


  export const FornecedorservicoScalarFieldEnum: {
    id: 'id',
    idServico: 'idServico',
    idFornecedor: 'idFornecedor',
    ativo: 'ativo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FornecedorservicoScalarFieldEnum = (typeof FornecedorservicoScalarFieldEnum)[keyof typeof FornecedorservicoScalarFieldEnum]


  export const HistoricoconsultaapiScalarFieldEnum: {
    id: 'id',
    idservico: 'idservico',
    idfornecedor: 'idfornecedor',
    cpf: 'cpf',
    cpfRepresentanteLegal: 'cpfRepresentanteLegal',
    beneficio: 'beneficio',
    resultado: 'resultado',
    statusConsulta: 'statusConsulta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HistoricoconsultaapiScalarFieldEnum = (typeof HistoricoconsultaapiScalarFieldEnum)[keyof typeof HistoricoconsultaapiScalarFieldEnum]


  export const HistoricocreditoScalarFieldEnum: {
    id: 'id',
    clienteId: 'clienteId',
    tipoOperacao: 'tipoOperacao',
    quantidade: 'quantidade',
    createdAt: 'createdAt',
    idServico: 'idServico'
  };

  export type HistoricocreditoScalarFieldEnum = (typeof HistoricocreditoScalarFieldEnum)[keyof typeof HistoricocreditoScalarFieldEnum]


  export const In100ScalarFieldEnum: {
    id: 'id',
    idUsuario: 'idUsuario',
    idConsulta: 'idConsulta',
    idConsultaOffline: 'idConsultaOffline',
    cpf: 'cpf',
    numeroBeneficio: 'numeroBeneficio',
    situacao: 'situacao',
    requisicao: 'requisicao',
    errorID: 'errorID',
    resultado: 'resultado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    cpfRepresentanteLegal: 'cpfRepresentanteLegal',
    idFornecedor: 'idFornecedor',
    idStatusSolicitacaoIn100: 'idStatusSolicitacaoIn100',
    msgErro: 'msgErro'
  };

  export type In100ScalarFieldEnum = (typeof In100ScalarFieldEnum)[keyof typeof In100ScalarFieldEnum]


  export const LoginsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    user_name: 'user_name',
    active: 'active',
    password: 'password',
    idperfil: 'idperfil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    cpf: 'cpf',
    email: 'email',
    telefone: 'telefone',
    usuarioAPi: 'usuarioAPi',
    chaveApi: 'chaveApi'
  };

  export type LoginsScalarFieldEnum = (typeof LoginsScalarFieldEnum)[keyof typeof LoginsScalarFieldEnum]


  export const MenuScalarFieldEnum: {
    id: 'id',
    codsequencia: 'codsequencia',
    descricao: 'descricao',
    pagina: 'pagina',
    rota: 'rota',
    idmodulo: 'idmodulo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    icone: 'icone'
  };

  export type MenuScalarFieldEnum = (typeof MenuScalarFieldEnum)[keyof typeof MenuScalarFieldEnum]


  export const ModulosScalarFieldEnum: {
    id: 'id',
    desc_modulo: 'desc_modulo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModulosScalarFieldEnum = (typeof ModulosScalarFieldEnum)[keyof typeof ModulosScalarFieldEnum]


  export const Perfil_moduloScalarFieldEnum: {
    id: 'id',
    idperfil: 'idperfil',
    idmodulo: 'idmodulo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Perfil_moduloScalarFieldEnum = (typeof Perfil_moduloScalarFieldEnum)[keyof typeof Perfil_moduloScalarFieldEnum]


  export const PerfilusuarioScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao'
  };

  export type PerfilusuarioScalarFieldEnum = (typeof PerfilusuarioScalarFieldEnum)[keyof typeof PerfilusuarioScalarFieldEnum]


  export const SenhasScalarFieldEnum: {
    id: 'id',
    idusuario: 'idusuario',
    senha: 'senha',
    idretorno: 'idretorno',
    observacao: 'observacao',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    cpf: 'cpf',
    idusuario_atualizacao: 'idusuario_atualizacao'
  };

  export type SenhasScalarFieldEnum = (typeof SenhasScalarFieldEnum)[keyof typeof SenhasScalarFieldEnum]


  export const SituacaoScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    icone: 'icone',
    cor: 'cor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    formsolicitar: 'formsolicitar'
  };

  export type SituacaoScalarFieldEnum = (typeof SituacaoScalarFieldEnum)[keyof typeof SituacaoScalarFieldEnum]


  export const SituacaosolicsenhaScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    telaSolicitar: 'telaSolicitar',
    telaAtualizar: 'telaAtualizar'
  };

  export type SituacaosolicsenhaScalarFieldEnum = (typeof SituacaosolicsenhaScalarFieldEnum)[keyof typeof SituacaosolicsenhaScalarFieldEnum]


  export const StatussolicitacaoservicoScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    descricao: 'descricao',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StatussolicitacaoservicoScalarFieldEnum = (typeof StatussolicitacaoservicoScalarFieldEnum)[keyof typeof StatussolicitacaoservicoScalarFieldEnum]


  export const TiposervicoScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    valorCusto: 'valorCusto',
    valorVenda: 'valorVenda',
    ativo: 'ativo',
    observacao: 'observacao',
    usuario_cad: 'usuario_cad',
    usuario_alt: 'usuario_alt',
    idfornecedor: 'idfornecedor'
  };

  export type TiposervicoScalarFieldEnum = (typeof TiposervicoScalarFieldEnum)[keyof typeof TiposervicoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const bancosOrderByRelevanceFieldEnum: {
    instituicao: 'instituicao',
    segmento: 'segmento'
  };

  export type bancosOrderByRelevanceFieldEnum = (typeof bancosOrderByRelevanceFieldEnum)[keyof typeof bancosOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const configuracaoOrderByRelevanceFieldEnum: {
    descricao: 'descricao'
  };

  export type configuracaoOrderByRelevanceFieldEnum = (typeof configuracaoOrderByRelevanceFieldEnum)[keyof typeof configuracaoOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const consultasOrderByRelevanceFieldEnum: {
    beneficio: 'beneficio',
    cpf: 'cpf',
    observacao: 'observacao',
    matricula_siape: 'matricula_siape'
  };

  export type consultasOrderByRelevanceFieldEnum = (typeof consultasOrderByRelevanceFieldEnum)[keyof typeof consultasOrderByRelevanceFieldEnum]


  export const consultasofflineOrderByRelevanceFieldEnum: {
    erroID: 'erroID',
    situacao: 'situacao'
  };

  export type consultasofflineOrderByRelevanceFieldEnum = (typeof consultasofflineOrderByRelevanceFieldEnum)[keyof typeof consultasofflineOrderByRelevanceFieldEnum]


  export const consultasofflinesiapeOrderByRelevanceFieldEnum: {
    situacao: 'situacao',
    erroID: 'erroID'
  };

  export type consultasofflinesiapeOrderByRelevanceFieldEnum = (typeof consultasofflinesiapeOrderByRelevanceFieldEnum)[keyof typeof consultasofflinesiapeOrderByRelevanceFieldEnum]


  export const desbloqueiosOrderByRelevanceFieldEnum: {
    beneficio: 'beneficio',
    cpf: 'cpf',
    protocolo: 'protocolo',
    requerente: 'requerente',
    unidade: 'unidade',
    ddb: 'ddb'
  };

  export type desbloqueiosOrderByRelevanceFieldEnum = (typeof desbloqueiosOrderByRelevanceFieldEnum)[keyof typeof desbloqueiosOrderByRelevanceFieldEnum]


  export const entrantesinssOrderByRelevanceFieldEnum: {
    cpf: 'cpf',
    nome: 'nome',
    cidade: 'cidade',
    uf: 'uf',
    bairro: 'bairro',
    cep: 'cep',
    fone: 'fone',
    fone1: 'fone1',
    fone2: 'fone2',
    fone3: 'fone3',
    fone4: 'fone4',
    fone5: 'fone5',
    fone6: 'fone6',
    fone7: 'fone7',
    fone8: 'fone8',
    fone9: 'fone9',
    email: 'email'
  };

  export type entrantesinssOrderByRelevanceFieldEnum = (typeof entrantesinssOrderByRelevanceFieldEnum)[keyof typeof entrantesinssOrderByRelevanceFieldEnum]


  export const especiebeneficioOrderByRelevanceFieldEnum: {
    descEspecieBeneficio: 'descEspecieBeneficio',
    gruposEspecie: 'gruposEspecie'
  };

  export type especiebeneficioOrderByRelevanceFieldEnum = (typeof especiebeneficioOrderByRelevanceFieldEnum)[keyof typeof especiebeneficioOrderByRelevanceFieldEnum]


  export const extratoofflineOrderByRelevanceFieldEnum: {
    cpf: 'cpf',
    beneficio: 'beneficio'
  };

  export type extratoofflineOrderByRelevanceFieldEnum = (typeof extratoofflineOrderByRelevanceFieldEnum)[keyof typeof extratoofflineOrderByRelevanceFieldEnum]


  export const extratoonlineOrderByRelevanceFieldEnum: {
    beneficio: 'beneficio',
    errorResult: 'errorResult'
  };

  export type extratoonlineOrderByRelevanceFieldEnum = (typeof extratoonlineOrderByRelevanceFieldEnum)[keyof typeof extratoonlineOrderByRelevanceFieldEnum]


  export const fornecedorOrderByRelevanceFieldEnum: {
    descricao: 'descricao',
    cnpj: 'cnpj',
    logradouro: 'logradouro',
    complemento: 'complemento',
    cep: 'cep',
    cidade: 'cidade',
    estado: 'estado',
    apikey: 'apikey',
    urlapi: 'urlapi',
    usuarioApi: 'usuarioApi',
    senhaApi: 'senhaApi'
  };

  export type fornecedorOrderByRelevanceFieldEnum = (typeof fornecedorOrderByRelevanceFieldEnum)[keyof typeof fornecedorOrderByRelevanceFieldEnum]


  export const historicoconsultaapiOrderByRelevanceFieldEnum: {
    cpf: 'cpf',
    cpfRepresentanteLegal: 'cpfRepresentanteLegal',
    beneficio: 'beneficio'
  };

  export type historicoconsultaapiOrderByRelevanceFieldEnum = (typeof historicoconsultaapiOrderByRelevanceFieldEnum)[keyof typeof historicoconsultaapiOrderByRelevanceFieldEnum]


  export const in100OrderByRelevanceFieldEnum: {
    cpf: 'cpf',
    numeroBeneficio: 'numeroBeneficio',
    situacao: 'situacao',
    errorID: 'errorID',
    cpfRepresentanteLegal: 'cpfRepresentanteLegal',
    msgErro: 'msgErro'
  };

  export type in100OrderByRelevanceFieldEnum = (typeof in100OrderByRelevanceFieldEnum)[keyof typeof in100OrderByRelevanceFieldEnum]


  export const loginsOrderByRelevanceFieldEnum: {
    name: 'name',
    user_name: 'user_name',
    password: 'password',
    cpf: 'cpf',
    email: 'email',
    telefone: 'telefone',
    chaveApi: 'chaveApi'
  };

  export type loginsOrderByRelevanceFieldEnum = (typeof loginsOrderByRelevanceFieldEnum)[keyof typeof loginsOrderByRelevanceFieldEnum]


  export const menuOrderByRelevanceFieldEnum: {
    descricao: 'descricao',
    pagina: 'pagina',
    rota: 'rota',
    icone: 'icone'
  };

  export type menuOrderByRelevanceFieldEnum = (typeof menuOrderByRelevanceFieldEnum)[keyof typeof menuOrderByRelevanceFieldEnum]


  export const modulosOrderByRelevanceFieldEnum: {
    desc_modulo: 'desc_modulo'
  };

  export type modulosOrderByRelevanceFieldEnum = (typeof modulosOrderByRelevanceFieldEnum)[keyof typeof modulosOrderByRelevanceFieldEnum]


  export const perfilusuarioOrderByRelevanceFieldEnum: {
    descricao: 'descricao'
  };

  export type perfilusuarioOrderByRelevanceFieldEnum = (typeof perfilusuarioOrderByRelevanceFieldEnum)[keyof typeof perfilusuarioOrderByRelevanceFieldEnum]


  export const senhasOrderByRelevanceFieldEnum: {
    senha: 'senha',
    observacao: 'observacao',
    cpf: 'cpf'
  };

  export type senhasOrderByRelevanceFieldEnum = (typeof senhasOrderByRelevanceFieldEnum)[keyof typeof senhasOrderByRelevanceFieldEnum]


  export const situacaoOrderByRelevanceFieldEnum: {
    descricao: 'descricao',
    icone: 'icone',
    cor: 'cor'
  };

  export type situacaoOrderByRelevanceFieldEnum = (typeof situacaoOrderByRelevanceFieldEnum)[keyof typeof situacaoOrderByRelevanceFieldEnum]


  export const situacaosolicsenhaOrderByRelevanceFieldEnum: {
    descricao: 'descricao'
  };

  export type situacaosolicsenhaOrderByRelevanceFieldEnum = (typeof situacaosolicsenhaOrderByRelevanceFieldEnum)[keyof typeof situacaosolicsenhaOrderByRelevanceFieldEnum]


  export const statussolicitacaoservicoOrderByRelevanceFieldEnum: {
    descricao: 'descricao'
  };

  export type statussolicitacaoservicoOrderByRelevanceFieldEnum = (typeof statussolicitacaoservicoOrderByRelevanceFieldEnum)[keyof typeof statussolicitacaoservicoOrderByRelevanceFieldEnum]


  export const tiposervicoOrderByRelevanceFieldEnum: {
    descricao: 'descricao',
    observacao: 'observacao'
  };

  export type tiposervicoOrderByRelevanceFieldEnum = (typeof tiposervicoOrderByRelevanceFieldEnum)[keyof typeof tiposervicoOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    
  /**
   * Deep Input Types
   */


  export type bancosWhereInput = {
    AND?: bancosWhereInput | bancosWhereInput[]
    OR?: bancosWhereInput[]
    NOT?: bancosWhereInput | bancosWhereInput[]
    id?: IntFilter<"bancos"> | number
    codbanco?: IntFilter<"bancos"> | number
    instituicao?: StringFilter<"bancos"> | string
    segmento?: StringFilter<"bancos"> | string
    createdAt?: DateTimeFilter<"bancos"> | Date | string
    updatedAt?: DateTimeFilter<"bancos"> | Date | string
  }

  export type bancosOrderByWithRelationInput = {
    id?: SortOrder
    codbanco?: SortOrder
    instituicao?: SortOrder
    segmento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: bancosOrderByRelevanceInput
  }

  export type bancosWhereUniqueInput = Prisma.AtLeast<{
    id_codbanco?: bancosIdCodbancoCompoundUniqueInput
    AND?: bancosWhereInput | bancosWhereInput[]
    OR?: bancosWhereInput[]
    NOT?: bancosWhereInput | bancosWhereInput[]
    id?: IntFilter<"bancos"> | number
    codbanco?: IntFilter<"bancos"> | number
    instituicao?: StringFilter<"bancos"> | string
    segmento?: StringFilter<"bancos"> | string
    createdAt?: DateTimeFilter<"bancos"> | Date | string
    updatedAt?: DateTimeFilter<"bancos"> | Date | string
  }, "id_codbanco">

  export type bancosOrderByWithAggregationInput = {
    id?: SortOrder
    codbanco?: SortOrder
    instituicao?: SortOrder
    segmento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: bancosCountOrderByAggregateInput
    _avg?: bancosAvgOrderByAggregateInput
    _max?: bancosMaxOrderByAggregateInput
    _min?: bancosMinOrderByAggregateInput
    _sum?: bancosSumOrderByAggregateInput
  }

  export type bancosScalarWhereWithAggregatesInput = {
    AND?: bancosScalarWhereWithAggregatesInput | bancosScalarWhereWithAggregatesInput[]
    OR?: bancosScalarWhereWithAggregatesInput[]
    NOT?: bancosScalarWhereWithAggregatesInput | bancosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bancos"> | number
    codbanco?: IntWithAggregatesFilter<"bancos"> | number
    instituicao?: StringWithAggregatesFilter<"bancos"> | string
    segmento?: StringWithAggregatesFilter<"bancos"> | string
    createdAt?: DateTimeWithAggregatesFilter<"bancos"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"bancos"> | Date | string
  }

  export type configuracaoWhereInput = {
    AND?: configuracaoWhereInput | configuracaoWhereInput[]
    OR?: configuracaoWhereInput[]
    NOT?: configuracaoWhereInput | configuracaoWhereInput[]
    id?: IntFilter<"configuracao"> | number
    descricao?: StringFilter<"configuracao"> | string
    config?: JsonFilter<"configuracao">
    createdAt?: DateTimeFilter<"configuracao"> | Date | string
    updatedAt?: DateTimeFilter<"configuracao"> | Date | string
  }

  export type configuracaoOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: configuracaoOrderByRelevanceInput
  }

  export type configuracaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: configuracaoWhereInput | configuracaoWhereInput[]
    OR?: configuracaoWhereInput[]
    NOT?: configuracaoWhereInput | configuracaoWhereInput[]
    descricao?: StringFilter<"configuracao"> | string
    config?: JsonFilter<"configuracao">
    createdAt?: DateTimeFilter<"configuracao"> | Date | string
    updatedAt?: DateTimeFilter<"configuracao"> | Date | string
  }, "id">

  export type configuracaoOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: configuracaoCountOrderByAggregateInput
    _avg?: configuracaoAvgOrderByAggregateInput
    _max?: configuracaoMaxOrderByAggregateInput
    _min?: configuracaoMinOrderByAggregateInput
    _sum?: configuracaoSumOrderByAggregateInput
  }

  export type configuracaoScalarWhereWithAggregatesInput = {
    AND?: configuracaoScalarWhereWithAggregatesInput | configuracaoScalarWhereWithAggregatesInput[]
    OR?: configuracaoScalarWhereWithAggregatesInput[]
    NOT?: configuracaoScalarWhereWithAggregatesInput | configuracaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"configuracao"> | number
    descricao?: StringWithAggregatesFilter<"configuracao"> | string
    config?: JsonWithAggregatesFilter<"configuracao">
    createdAt?: DateTimeWithAggregatesFilter<"configuracao"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"configuracao"> | Date | string
  }

  export type consultasWhereInput = {
    AND?: consultasWhereInput | consultasWhereInput[]
    OR?: consultasWhereInput[]
    NOT?: consultasWhereInput | consultasWhereInput[]
    id?: IntFilter<"consultas"> | number
    datahora?: DateTimeFilter<"consultas"> | Date | string
    id_servico?: IntFilter<"consultas"> | number
    beneficio?: StringNullableFilter<"consultas"> | string | null
    cpf?: StringNullableFilter<"consultas"> | string | null
    qtde?: IntFilter<"consultas"> | number
    id_usuario?: IntFilter<"consultas"> | number
    createdAt?: DateTimeFilter<"consultas"> | Date | string
    updatedAt?: DateTimeFilter<"consultas"> | Date | string
    tipotransacao?: IntFilter<"consultas"> | number
    observacao?: StringNullableFilter<"consultas"> | string | null
    valor_unit?: FloatFilter<"consultas"> | number
    matricula_siape?: StringNullableFilter<"consultas"> | string | null
    tp_serv_origem?: IntFilter<"consultas"> | number
    id_extrato_off?: IntFilter<"consultas"> | number
    origem_sol?: IntFilter<"consultas"> | number
  }

  export type consultasOrderByWithRelationInput = {
    id?: SortOrder
    datahora?: SortOrder
    id_servico?: SortOrder
    beneficio?: SortOrderInput | SortOrder
    cpf?: SortOrderInput | SortOrder
    qtde?: SortOrder
    id_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tipotransacao?: SortOrder
    observacao?: SortOrderInput | SortOrder
    valor_unit?: SortOrder
    matricula_siape?: SortOrderInput | SortOrder
    tp_serv_origem?: SortOrder
    id_extrato_off?: SortOrder
    origem_sol?: SortOrder
    _relevance?: consultasOrderByRelevanceInput
  }

  export type consultasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: consultasWhereInput | consultasWhereInput[]
    OR?: consultasWhereInput[]
    NOT?: consultasWhereInput | consultasWhereInput[]
    datahora?: DateTimeFilter<"consultas"> | Date | string
    id_servico?: IntFilter<"consultas"> | number
    beneficio?: StringNullableFilter<"consultas"> | string | null
    cpf?: StringNullableFilter<"consultas"> | string | null
    qtde?: IntFilter<"consultas"> | number
    id_usuario?: IntFilter<"consultas"> | number
    createdAt?: DateTimeFilter<"consultas"> | Date | string
    updatedAt?: DateTimeFilter<"consultas"> | Date | string
    tipotransacao?: IntFilter<"consultas"> | number
    observacao?: StringNullableFilter<"consultas"> | string | null
    valor_unit?: FloatFilter<"consultas"> | number
    matricula_siape?: StringNullableFilter<"consultas"> | string | null
    tp_serv_origem?: IntFilter<"consultas"> | number
    id_extrato_off?: IntFilter<"consultas"> | number
    origem_sol?: IntFilter<"consultas"> | number
  }, "id">

  export type consultasOrderByWithAggregationInput = {
    id?: SortOrder
    datahora?: SortOrder
    id_servico?: SortOrder
    beneficio?: SortOrderInput | SortOrder
    cpf?: SortOrderInput | SortOrder
    qtde?: SortOrder
    id_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tipotransacao?: SortOrder
    observacao?: SortOrderInput | SortOrder
    valor_unit?: SortOrder
    matricula_siape?: SortOrderInput | SortOrder
    tp_serv_origem?: SortOrder
    id_extrato_off?: SortOrder
    origem_sol?: SortOrder
    _count?: consultasCountOrderByAggregateInput
    _avg?: consultasAvgOrderByAggregateInput
    _max?: consultasMaxOrderByAggregateInput
    _min?: consultasMinOrderByAggregateInput
    _sum?: consultasSumOrderByAggregateInput
  }

  export type consultasScalarWhereWithAggregatesInput = {
    AND?: consultasScalarWhereWithAggregatesInput | consultasScalarWhereWithAggregatesInput[]
    OR?: consultasScalarWhereWithAggregatesInput[]
    NOT?: consultasScalarWhereWithAggregatesInput | consultasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"consultas"> | number
    datahora?: DateTimeWithAggregatesFilter<"consultas"> | Date | string
    id_servico?: IntWithAggregatesFilter<"consultas"> | number
    beneficio?: StringNullableWithAggregatesFilter<"consultas"> | string | null
    cpf?: StringNullableWithAggregatesFilter<"consultas"> | string | null
    qtde?: IntWithAggregatesFilter<"consultas"> | number
    id_usuario?: IntWithAggregatesFilter<"consultas"> | number
    createdAt?: DateTimeWithAggregatesFilter<"consultas"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"consultas"> | Date | string
    tipotransacao?: IntWithAggregatesFilter<"consultas"> | number
    observacao?: StringNullableWithAggregatesFilter<"consultas"> | string | null
    valor_unit?: FloatWithAggregatesFilter<"consultas"> | number
    matricula_siape?: StringNullableWithAggregatesFilter<"consultas"> | string | null
    tp_serv_origem?: IntWithAggregatesFilter<"consultas"> | number
    id_extrato_off?: IntWithAggregatesFilter<"consultas"> | number
    origem_sol?: IntWithAggregatesFilter<"consultas"> | number
  }

  export type consultasofflineWhereInput = {
    AND?: consultasofflineWhereInput | consultasofflineWhereInput[]
    OR?: consultasofflineWhereInput[]
    NOT?: consultasofflineWhereInput | consultasofflineWhereInput[]
    id?: IntFilter<"consultasoffline"> | number
    idConsulta?: IntFilter<"consultasoffline"> | number
    erroID?: StringNullableFilter<"consultasoffline"> | string | null
    idStatusSolicitacaoIn100?: IntFilter<"consultasoffline"> | number
    situacao?: StringNullableFilter<"consultasoffline"> | string | null
    resultado?: JsonNullableFilter<"consultasoffline">
    createdAt?: DateTimeFilter<"consultasoffline"> | Date | string
    updatedAt?: DateTimeFilter<"consultasoffline"> | Date | string
  }

  export type consultasofflineOrderByWithRelationInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    erroID?: SortOrderInput | SortOrder
    idStatusSolicitacaoIn100?: SortOrder
    situacao?: SortOrderInput | SortOrder
    resultado?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: consultasofflineOrderByRelevanceInput
  }

  export type consultasofflineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: consultasofflineWhereInput | consultasofflineWhereInput[]
    OR?: consultasofflineWhereInput[]
    NOT?: consultasofflineWhereInput | consultasofflineWhereInput[]
    idConsulta?: IntFilter<"consultasoffline"> | number
    erroID?: StringNullableFilter<"consultasoffline"> | string | null
    idStatusSolicitacaoIn100?: IntFilter<"consultasoffline"> | number
    situacao?: StringNullableFilter<"consultasoffline"> | string | null
    resultado?: JsonNullableFilter<"consultasoffline">
    createdAt?: DateTimeFilter<"consultasoffline"> | Date | string
    updatedAt?: DateTimeFilter<"consultasoffline"> | Date | string
  }, "id">

  export type consultasofflineOrderByWithAggregationInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    erroID?: SortOrderInput | SortOrder
    idStatusSolicitacaoIn100?: SortOrder
    situacao?: SortOrderInput | SortOrder
    resultado?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: consultasofflineCountOrderByAggregateInput
    _avg?: consultasofflineAvgOrderByAggregateInput
    _max?: consultasofflineMaxOrderByAggregateInput
    _min?: consultasofflineMinOrderByAggregateInput
    _sum?: consultasofflineSumOrderByAggregateInput
  }

  export type consultasofflineScalarWhereWithAggregatesInput = {
    AND?: consultasofflineScalarWhereWithAggregatesInput | consultasofflineScalarWhereWithAggregatesInput[]
    OR?: consultasofflineScalarWhereWithAggregatesInput[]
    NOT?: consultasofflineScalarWhereWithAggregatesInput | consultasofflineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"consultasoffline"> | number
    idConsulta?: IntWithAggregatesFilter<"consultasoffline"> | number
    erroID?: StringNullableWithAggregatesFilter<"consultasoffline"> | string | null
    idStatusSolicitacaoIn100?: IntWithAggregatesFilter<"consultasoffline"> | number
    situacao?: StringNullableWithAggregatesFilter<"consultasoffline"> | string | null
    resultado?: JsonNullableWithAggregatesFilter<"consultasoffline">
    createdAt?: DateTimeWithAggregatesFilter<"consultasoffline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"consultasoffline"> | Date | string
  }

  export type consultasofflinesiapeWhereInput = {
    AND?: consultasofflinesiapeWhereInput | consultasofflinesiapeWhereInput[]
    OR?: consultasofflinesiapeWhereInput[]
    NOT?: consultasofflinesiapeWhereInput | consultasofflinesiapeWhereInput[]
    id?: IntFilter<"consultasofflinesiape"> | number
    idConsulta?: IntFilter<"consultasofflinesiape"> | number
    situacao?: StringNullableFilter<"consultasofflinesiape"> | string | null
    erroID?: StringNullableFilter<"consultasofflinesiape"> | string | null
    resultado?: JsonNullableFilter<"consultasofflinesiape">
    createdAt?: DateTimeFilter<"consultasofflinesiape"> | Date | string
    updatedAt?: DateTimeFilter<"consultasofflinesiape"> | Date | string
  }

  export type consultasofflinesiapeOrderByWithRelationInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    situacao?: SortOrderInput | SortOrder
    erroID?: SortOrderInput | SortOrder
    resultado?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: consultasofflinesiapeOrderByRelevanceInput
  }

  export type consultasofflinesiapeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: consultasofflinesiapeWhereInput | consultasofflinesiapeWhereInput[]
    OR?: consultasofflinesiapeWhereInput[]
    NOT?: consultasofflinesiapeWhereInput | consultasofflinesiapeWhereInput[]
    idConsulta?: IntFilter<"consultasofflinesiape"> | number
    situacao?: StringNullableFilter<"consultasofflinesiape"> | string | null
    erroID?: StringNullableFilter<"consultasofflinesiape"> | string | null
    resultado?: JsonNullableFilter<"consultasofflinesiape">
    createdAt?: DateTimeFilter<"consultasofflinesiape"> | Date | string
    updatedAt?: DateTimeFilter<"consultasofflinesiape"> | Date | string
  }, "id">

  export type consultasofflinesiapeOrderByWithAggregationInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    situacao?: SortOrderInput | SortOrder
    erroID?: SortOrderInput | SortOrder
    resultado?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: consultasofflinesiapeCountOrderByAggregateInput
    _avg?: consultasofflinesiapeAvgOrderByAggregateInput
    _max?: consultasofflinesiapeMaxOrderByAggregateInput
    _min?: consultasofflinesiapeMinOrderByAggregateInput
    _sum?: consultasofflinesiapeSumOrderByAggregateInput
  }

  export type consultasofflinesiapeScalarWhereWithAggregatesInput = {
    AND?: consultasofflinesiapeScalarWhereWithAggregatesInput | consultasofflinesiapeScalarWhereWithAggregatesInput[]
    OR?: consultasofflinesiapeScalarWhereWithAggregatesInput[]
    NOT?: consultasofflinesiapeScalarWhereWithAggregatesInput | consultasofflinesiapeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"consultasofflinesiape"> | number
    idConsulta?: IntWithAggregatesFilter<"consultasofflinesiape"> | number
    situacao?: StringNullableWithAggregatesFilter<"consultasofflinesiape"> | string | null
    erroID?: StringNullableWithAggregatesFilter<"consultasofflinesiape"> | string | null
    resultado?: JsonNullableWithAggregatesFilter<"consultasofflinesiape">
    createdAt?: DateTimeWithAggregatesFilter<"consultasofflinesiape"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"consultasofflinesiape"> | Date | string
  }

  export type creditoWhereInput = {
    AND?: creditoWhereInput | creditoWhereInput[]
    OR?: creditoWhereInput[]
    NOT?: creditoWhereInput | creditoWhereInput[]
    id?: IntFilter<"credito"> | number
    datahora?: DateTimeFilter<"credito"> | Date | string
    valorun?: FloatNullableFilter<"credito"> | number | null
    vendedor?: IntFilter<"credito"> | number
    createdAt?: DateTimeFilter<"credito"> | Date | string
    updatedAt?: DateTimeFilter<"credito"> | Date | string
    idusu_cli?: IntFilter<"credito"> | number
    tiposervico?: IntFilter<"credito"> | number
    qtdecreditos?: IntFilter<"credito"> | number
    qtderestante?: IntFilter<"credito"> | number
    qtdeutilizada?: IntFilter<"credito"> | number
  }

  export type creditoOrderByWithRelationInput = {
    id?: SortOrder
    datahora?: SortOrder
    valorun?: SortOrderInput | SortOrder
    vendedor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idusu_cli?: SortOrder
    tiposervico?: SortOrder
    qtdecreditos?: SortOrder
    qtderestante?: SortOrder
    qtdeutilizada?: SortOrder
  }

  export type creditoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: creditoWhereInput | creditoWhereInput[]
    OR?: creditoWhereInput[]
    NOT?: creditoWhereInput | creditoWhereInput[]
    datahora?: DateTimeFilter<"credito"> | Date | string
    valorun?: FloatNullableFilter<"credito"> | number | null
    vendedor?: IntFilter<"credito"> | number
    createdAt?: DateTimeFilter<"credito"> | Date | string
    updatedAt?: DateTimeFilter<"credito"> | Date | string
    idusu_cli?: IntFilter<"credito"> | number
    tiposervico?: IntFilter<"credito"> | number
    qtdecreditos?: IntFilter<"credito"> | number
    qtderestante?: IntFilter<"credito"> | number
    qtdeutilizada?: IntFilter<"credito"> | number
  }, "id">

  export type creditoOrderByWithAggregationInput = {
    id?: SortOrder
    datahora?: SortOrder
    valorun?: SortOrderInput | SortOrder
    vendedor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idusu_cli?: SortOrder
    tiposervico?: SortOrder
    qtdecreditos?: SortOrder
    qtderestante?: SortOrder
    qtdeutilizada?: SortOrder
    _count?: creditoCountOrderByAggregateInput
    _avg?: creditoAvgOrderByAggregateInput
    _max?: creditoMaxOrderByAggregateInput
    _min?: creditoMinOrderByAggregateInput
    _sum?: creditoSumOrderByAggregateInput
  }

  export type creditoScalarWhereWithAggregatesInput = {
    AND?: creditoScalarWhereWithAggregatesInput | creditoScalarWhereWithAggregatesInput[]
    OR?: creditoScalarWhereWithAggregatesInput[]
    NOT?: creditoScalarWhereWithAggregatesInput | creditoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"credito"> | number
    datahora?: DateTimeWithAggregatesFilter<"credito"> | Date | string
    valorun?: FloatNullableWithAggregatesFilter<"credito"> | number | null
    vendedor?: IntWithAggregatesFilter<"credito"> | number
    createdAt?: DateTimeWithAggregatesFilter<"credito"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"credito"> | Date | string
    idusu_cli?: IntWithAggregatesFilter<"credito"> | number
    tiposervico?: IntWithAggregatesFilter<"credito"> | number
    qtdecreditos?: IntWithAggregatesFilter<"credito"> | number
    qtderestante?: IntWithAggregatesFilter<"credito"> | number
    qtdeutilizada?: IntWithAggregatesFilter<"credito"> | number
  }

  export type desbloqueiosWhereInput = {
    AND?: desbloqueiosWhereInput | desbloqueiosWhereInput[]
    OR?: desbloqueiosWhereInput[]
    NOT?: desbloqueiosWhereInput | desbloqueiosWhereInput[]
    id?: IntFilter<"desbloqueios"> | number
    datahora?: DateTimeFilter<"desbloqueios"> | Date | string
    beneficio?: StringFilter<"desbloqueios"> | string
    cpf?: StringFilter<"desbloqueios"> | string
    protocolo?: StringNullableFilter<"desbloqueios"> | string | null
    requerente?: StringNullableFilter<"desbloqueios"> | string | null
    unidade?: StringNullableFilter<"desbloqueios"> | string | null
    status?: IntFilter<"desbloqueios"> | number
    id_usuario?: IntFilter<"desbloqueios"> | number
    createdAt?: DateTimeFilter<"desbloqueios"> | Date | string
    updatedAt?: DateTimeFilter<"desbloqueios"> | Date | string
    id_usu_desbloqueio?: IntFilter<"desbloqueios"> | number
    ddb?: StringNullableFilter<"desbloqueios"> | string | null
  }

  export type desbloqueiosOrderByWithRelationInput = {
    id?: SortOrder
    datahora?: SortOrder
    beneficio?: SortOrder
    cpf?: SortOrder
    protocolo?: SortOrderInput | SortOrder
    requerente?: SortOrderInput | SortOrder
    unidade?: SortOrderInput | SortOrder
    status?: SortOrder
    id_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_usu_desbloqueio?: SortOrder
    ddb?: SortOrderInput | SortOrder
    _relevance?: desbloqueiosOrderByRelevanceInput
  }

  export type desbloqueiosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: desbloqueiosWhereInput | desbloqueiosWhereInput[]
    OR?: desbloqueiosWhereInput[]
    NOT?: desbloqueiosWhereInput | desbloqueiosWhereInput[]
    datahora?: DateTimeFilter<"desbloqueios"> | Date | string
    beneficio?: StringFilter<"desbloqueios"> | string
    cpf?: StringFilter<"desbloqueios"> | string
    protocolo?: StringNullableFilter<"desbloqueios"> | string | null
    requerente?: StringNullableFilter<"desbloqueios"> | string | null
    unidade?: StringNullableFilter<"desbloqueios"> | string | null
    status?: IntFilter<"desbloqueios"> | number
    id_usuario?: IntFilter<"desbloqueios"> | number
    createdAt?: DateTimeFilter<"desbloqueios"> | Date | string
    updatedAt?: DateTimeFilter<"desbloqueios"> | Date | string
    id_usu_desbloqueio?: IntFilter<"desbloqueios"> | number
    ddb?: StringNullableFilter<"desbloqueios"> | string | null
  }, "id">

  export type desbloqueiosOrderByWithAggregationInput = {
    id?: SortOrder
    datahora?: SortOrder
    beneficio?: SortOrder
    cpf?: SortOrder
    protocolo?: SortOrderInput | SortOrder
    requerente?: SortOrderInput | SortOrder
    unidade?: SortOrderInput | SortOrder
    status?: SortOrder
    id_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_usu_desbloqueio?: SortOrder
    ddb?: SortOrderInput | SortOrder
    _count?: desbloqueiosCountOrderByAggregateInput
    _avg?: desbloqueiosAvgOrderByAggregateInput
    _max?: desbloqueiosMaxOrderByAggregateInput
    _min?: desbloqueiosMinOrderByAggregateInput
    _sum?: desbloqueiosSumOrderByAggregateInput
  }

  export type desbloqueiosScalarWhereWithAggregatesInput = {
    AND?: desbloqueiosScalarWhereWithAggregatesInput | desbloqueiosScalarWhereWithAggregatesInput[]
    OR?: desbloqueiosScalarWhereWithAggregatesInput[]
    NOT?: desbloqueiosScalarWhereWithAggregatesInput | desbloqueiosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"desbloqueios"> | number
    datahora?: DateTimeWithAggregatesFilter<"desbloqueios"> | Date | string
    beneficio?: StringWithAggregatesFilter<"desbloqueios"> | string
    cpf?: StringWithAggregatesFilter<"desbloqueios"> | string
    protocolo?: StringNullableWithAggregatesFilter<"desbloqueios"> | string | null
    requerente?: StringNullableWithAggregatesFilter<"desbloqueios"> | string | null
    unidade?: StringNullableWithAggregatesFilter<"desbloqueios"> | string | null
    status?: IntWithAggregatesFilter<"desbloqueios"> | number
    id_usuario?: IntWithAggregatesFilter<"desbloqueios"> | number
    createdAt?: DateTimeWithAggregatesFilter<"desbloqueios"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"desbloqueios"> | Date | string
    id_usu_desbloqueio?: IntWithAggregatesFilter<"desbloqueios"> | number
    ddb?: StringNullableWithAggregatesFilter<"desbloqueios"> | string | null
  }

  export type entrantesinssWhereInput = {
    AND?: entrantesinssWhereInput | entrantesinssWhereInput[]
    OR?: entrantesinssWhereInput[]
    NOT?: entrantesinssWhereInput | entrantesinssWhereInput[]
    id?: IntFilter<"entrantesinss"> | number
    cpf?: StringNullableFilter<"entrantesinss"> | string | null
    nome?: StringNullableFilter<"entrantesinss"> | string | null
    nascimento?: DateTimeNullableFilter<"entrantesinss"> | Date | string | null
    idade?: IntNullableFilter<"entrantesinss"> | number | null
    beneficio?: IntNullableFilter<"entrantesinss"> | number | null
    especie?: IntNullableFilter<"entrantesinss"> | number | null
    salario?: FloatNullableFilter<"entrantesinss"> | number | null
    dib?: DateTimeNullableFilter<"entrantesinss"> | Date | string | null
    cidade?: StringNullableFilter<"entrantesinss"> | string | null
    uf?: StringNullableFilter<"entrantesinss"> | string | null
    bairro?: StringNullableFilter<"entrantesinss"> | string | null
    cep?: StringNullableFilter<"entrantesinss"> | string | null
    fone?: StringNullableFilter<"entrantesinss"> | string | null
    fone1?: StringNullableFilter<"entrantesinss"> | string | null
    fone2?: StringNullableFilter<"entrantesinss"> | string | null
    fone3?: StringNullableFilter<"entrantesinss"> | string | null
    fone4?: StringNullableFilter<"entrantesinss"> | string | null
    fone5?: StringNullableFilter<"entrantesinss"> | string | null
    fone6?: StringNullableFilter<"entrantesinss"> | string | null
    fone7?: StringNullableFilter<"entrantesinss"> | string | null
    fone8?: StringNullableFilter<"entrantesinss"> | string | null
    fone9?: StringNullableFilter<"entrantesinss"> | string | null
    email?: StringNullableFilter<"entrantesinss"> | string | null
    createdAt?: DateTimeFilter<"entrantesinss"> | Date | string
    updatedAt?: DateTimeFilter<"entrantesinss"> | Date | string
  }

  export type entrantesinssOrderByWithRelationInput = {
    id?: SortOrder
    cpf?: SortOrderInput | SortOrder
    nome?: SortOrderInput | SortOrder
    nascimento?: SortOrderInput | SortOrder
    idade?: SortOrderInput | SortOrder
    beneficio?: SortOrderInput | SortOrder
    especie?: SortOrderInput | SortOrder
    salario?: SortOrderInput | SortOrder
    dib?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    uf?: SortOrderInput | SortOrder
    bairro?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    fone?: SortOrderInput | SortOrder
    fone1?: SortOrderInput | SortOrder
    fone2?: SortOrderInput | SortOrder
    fone3?: SortOrderInput | SortOrder
    fone4?: SortOrderInput | SortOrder
    fone5?: SortOrderInput | SortOrder
    fone6?: SortOrderInput | SortOrder
    fone7?: SortOrderInput | SortOrder
    fone8?: SortOrderInput | SortOrder
    fone9?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: entrantesinssOrderByRelevanceInput
  }

  export type entrantesinssWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: entrantesinssWhereInput | entrantesinssWhereInput[]
    OR?: entrantesinssWhereInput[]
    NOT?: entrantesinssWhereInput | entrantesinssWhereInput[]
    cpf?: StringNullableFilter<"entrantesinss"> | string | null
    nome?: StringNullableFilter<"entrantesinss"> | string | null
    nascimento?: DateTimeNullableFilter<"entrantesinss"> | Date | string | null
    idade?: IntNullableFilter<"entrantesinss"> | number | null
    beneficio?: IntNullableFilter<"entrantesinss"> | number | null
    especie?: IntNullableFilter<"entrantesinss"> | number | null
    salario?: FloatNullableFilter<"entrantesinss"> | number | null
    dib?: DateTimeNullableFilter<"entrantesinss"> | Date | string | null
    cidade?: StringNullableFilter<"entrantesinss"> | string | null
    uf?: StringNullableFilter<"entrantesinss"> | string | null
    bairro?: StringNullableFilter<"entrantesinss"> | string | null
    cep?: StringNullableFilter<"entrantesinss"> | string | null
    fone?: StringNullableFilter<"entrantesinss"> | string | null
    fone1?: StringNullableFilter<"entrantesinss"> | string | null
    fone2?: StringNullableFilter<"entrantesinss"> | string | null
    fone3?: StringNullableFilter<"entrantesinss"> | string | null
    fone4?: StringNullableFilter<"entrantesinss"> | string | null
    fone5?: StringNullableFilter<"entrantesinss"> | string | null
    fone6?: StringNullableFilter<"entrantesinss"> | string | null
    fone7?: StringNullableFilter<"entrantesinss"> | string | null
    fone8?: StringNullableFilter<"entrantesinss"> | string | null
    fone9?: StringNullableFilter<"entrantesinss"> | string | null
    email?: StringNullableFilter<"entrantesinss"> | string | null
    createdAt?: DateTimeFilter<"entrantesinss"> | Date | string
    updatedAt?: DateTimeFilter<"entrantesinss"> | Date | string
  }, "id">

  export type entrantesinssOrderByWithAggregationInput = {
    id?: SortOrder
    cpf?: SortOrderInput | SortOrder
    nome?: SortOrderInput | SortOrder
    nascimento?: SortOrderInput | SortOrder
    idade?: SortOrderInput | SortOrder
    beneficio?: SortOrderInput | SortOrder
    especie?: SortOrderInput | SortOrder
    salario?: SortOrderInput | SortOrder
    dib?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    uf?: SortOrderInput | SortOrder
    bairro?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    fone?: SortOrderInput | SortOrder
    fone1?: SortOrderInput | SortOrder
    fone2?: SortOrderInput | SortOrder
    fone3?: SortOrderInput | SortOrder
    fone4?: SortOrderInput | SortOrder
    fone5?: SortOrderInput | SortOrder
    fone6?: SortOrderInput | SortOrder
    fone7?: SortOrderInput | SortOrder
    fone8?: SortOrderInput | SortOrder
    fone9?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: entrantesinssCountOrderByAggregateInput
    _avg?: entrantesinssAvgOrderByAggregateInput
    _max?: entrantesinssMaxOrderByAggregateInput
    _min?: entrantesinssMinOrderByAggregateInput
    _sum?: entrantesinssSumOrderByAggregateInput
  }

  export type entrantesinssScalarWhereWithAggregatesInput = {
    AND?: entrantesinssScalarWhereWithAggregatesInput | entrantesinssScalarWhereWithAggregatesInput[]
    OR?: entrantesinssScalarWhereWithAggregatesInput[]
    NOT?: entrantesinssScalarWhereWithAggregatesInput | entrantesinssScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"entrantesinss"> | number
    cpf?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    nome?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    nascimento?: DateTimeNullableWithAggregatesFilter<"entrantesinss"> | Date | string | null
    idade?: IntNullableWithAggregatesFilter<"entrantesinss"> | number | null
    beneficio?: IntNullableWithAggregatesFilter<"entrantesinss"> | number | null
    especie?: IntNullableWithAggregatesFilter<"entrantesinss"> | number | null
    salario?: FloatNullableWithAggregatesFilter<"entrantesinss"> | number | null
    dib?: DateTimeNullableWithAggregatesFilter<"entrantesinss"> | Date | string | null
    cidade?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    uf?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    bairro?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    cep?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    fone?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    fone1?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    fone2?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    fone3?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    fone4?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    fone5?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    fone6?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    fone7?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    fone8?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    fone9?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    email?: StringNullableWithAggregatesFilter<"entrantesinss"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"entrantesinss"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"entrantesinss"> | Date | string
  }

  export type especiebeneficioWhereInput = {
    AND?: especiebeneficioWhereInput | especiebeneficioWhereInput[]
    OR?: especiebeneficioWhereInput[]
    NOT?: especiebeneficioWhereInput | especiebeneficioWhereInput[]
    id?: IntFilter<"especiebeneficio"> | number
    codigo?: IntFilter<"especiebeneficio"> | number
    descEspecieBeneficio?: StringFilter<"especiebeneficio"> | string
    gruposEspecie?: StringFilter<"especiebeneficio"> | string
    createdAt?: DateTimeFilter<"especiebeneficio"> | Date | string
    updatedAt?: DateTimeFilter<"especiebeneficio"> | Date | string
  }

  export type especiebeneficioOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    descEspecieBeneficio?: SortOrder
    gruposEspecie?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: especiebeneficioOrderByRelevanceInput
  }

  export type especiebeneficioWhereUniqueInput = Prisma.AtLeast<{
    id_codigo?: especiebeneficioIdCodigoCompoundUniqueInput
    AND?: especiebeneficioWhereInput | especiebeneficioWhereInput[]
    OR?: especiebeneficioWhereInput[]
    NOT?: especiebeneficioWhereInput | especiebeneficioWhereInput[]
    id?: IntFilter<"especiebeneficio"> | number
    codigo?: IntFilter<"especiebeneficio"> | number
    descEspecieBeneficio?: StringFilter<"especiebeneficio"> | string
    gruposEspecie?: StringFilter<"especiebeneficio"> | string
    createdAt?: DateTimeFilter<"especiebeneficio"> | Date | string
    updatedAt?: DateTimeFilter<"especiebeneficio"> | Date | string
  }, "id_codigo">

  export type especiebeneficioOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    descEspecieBeneficio?: SortOrder
    gruposEspecie?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: especiebeneficioCountOrderByAggregateInput
    _avg?: especiebeneficioAvgOrderByAggregateInput
    _max?: especiebeneficioMaxOrderByAggregateInput
    _min?: especiebeneficioMinOrderByAggregateInput
    _sum?: especiebeneficioSumOrderByAggregateInput
  }

  export type especiebeneficioScalarWhereWithAggregatesInput = {
    AND?: especiebeneficioScalarWhereWithAggregatesInput | especiebeneficioScalarWhereWithAggregatesInput[]
    OR?: especiebeneficioScalarWhereWithAggregatesInput[]
    NOT?: especiebeneficioScalarWhereWithAggregatesInput | especiebeneficioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"especiebeneficio"> | number
    codigo?: IntWithAggregatesFilter<"especiebeneficio"> | number
    descEspecieBeneficio?: StringWithAggregatesFilter<"especiebeneficio"> | string
    gruposEspecie?: StringWithAggregatesFilter<"especiebeneficio"> | string
    createdAt?: DateTimeWithAggregatesFilter<"especiebeneficio"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"especiebeneficio"> | Date | string
  }

  export type extratoofflineWhereInput = {
    AND?: extratoofflineWhereInput | extratoofflineWhereInput[]
    OR?: extratoofflineWhereInput[]
    NOT?: extratoofflineWhereInput | extratoofflineWhereInput[]
    id?: IntFilter<"extratooffline"> | number
    cpf?: StringNullableFilter<"extratooffline"> | string | null
    beneficio?: StringNullableFilter<"extratooffline"> | string | null
    jsonResult?: JsonNullableFilter<"extratooffline">
    createdAt?: DateTimeFilter<"extratooffline"> | Date | string
    updatedAt?: DateTimeFilter<"extratooffline"> | Date | string
    idFornecedor?: IntFilter<"extratooffline"> | number
    idConsulta?: IntFilter<"extratooffline"> | number
    idUsuario?: IntFilter<"extratooffline"> | number
  }

  export type extratoofflineOrderByWithRelationInput = {
    id?: SortOrder
    cpf?: SortOrderInput | SortOrder
    beneficio?: SortOrderInput | SortOrder
    jsonResult?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idFornecedor?: SortOrder
    idConsulta?: SortOrder
    idUsuario?: SortOrder
    _relevance?: extratoofflineOrderByRelevanceInput
  }

  export type extratoofflineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: extratoofflineWhereInput | extratoofflineWhereInput[]
    OR?: extratoofflineWhereInput[]
    NOT?: extratoofflineWhereInput | extratoofflineWhereInput[]
    cpf?: StringNullableFilter<"extratooffline"> | string | null
    beneficio?: StringNullableFilter<"extratooffline"> | string | null
    jsonResult?: JsonNullableFilter<"extratooffline">
    createdAt?: DateTimeFilter<"extratooffline"> | Date | string
    updatedAt?: DateTimeFilter<"extratooffline"> | Date | string
    idFornecedor?: IntFilter<"extratooffline"> | number
    idConsulta?: IntFilter<"extratooffline"> | number
    idUsuario?: IntFilter<"extratooffline"> | number
  }, "id">

  export type extratoofflineOrderByWithAggregationInput = {
    id?: SortOrder
    cpf?: SortOrderInput | SortOrder
    beneficio?: SortOrderInput | SortOrder
    jsonResult?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idFornecedor?: SortOrder
    idConsulta?: SortOrder
    idUsuario?: SortOrder
    _count?: extratoofflineCountOrderByAggregateInput
    _avg?: extratoofflineAvgOrderByAggregateInput
    _max?: extratoofflineMaxOrderByAggregateInput
    _min?: extratoofflineMinOrderByAggregateInput
    _sum?: extratoofflineSumOrderByAggregateInput
  }

  export type extratoofflineScalarWhereWithAggregatesInput = {
    AND?: extratoofflineScalarWhereWithAggregatesInput | extratoofflineScalarWhereWithAggregatesInput[]
    OR?: extratoofflineScalarWhereWithAggregatesInput[]
    NOT?: extratoofflineScalarWhereWithAggregatesInput | extratoofflineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"extratooffline"> | number
    cpf?: StringNullableWithAggregatesFilter<"extratooffline"> | string | null
    beneficio?: StringNullableWithAggregatesFilter<"extratooffline"> | string | null
    jsonResult?: JsonNullableWithAggregatesFilter<"extratooffline">
    createdAt?: DateTimeWithAggregatesFilter<"extratooffline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"extratooffline"> | Date | string
    idFornecedor?: IntWithAggregatesFilter<"extratooffline"> | number
    idConsulta?: IntWithAggregatesFilter<"extratooffline"> | number
    idUsuario?: IntWithAggregatesFilter<"extratooffline"> | number
  }

  export type extratoonlineWhereInput = {
    AND?: extratoonlineWhereInput | extratoonlineWhereInput[]
    OR?: extratoonlineWhereInput[]
    NOT?: extratoonlineWhereInput | extratoonlineWhereInput[]
    id?: IntFilter<"extratoonline"> | number
    idConsulta?: IntFilter<"extratoonline"> | number
    id_fornecedor?: IntFilter<"extratoonline"> | number
    beneficio?: StringFilter<"extratoonline"> | string
    jsonResult?: JsonNullableFilter<"extratoonline">
    filePdf?: BytesNullableFilter<"extratoonline"> | Uint8Array | null
    createdAt?: DateTimeFilter<"extratoonline"> | Date | string
    updatedAt?: DateTimeFilter<"extratoonline"> | Date | string
    isCache?: BoolNullableFilter<"extratoonline"> | boolean | null
    statusConsulta?: IntNullableFilter<"extratoonline"> | number | null
    idConsultaOffline?: IntFilter<"extratoonline"> | number
    errorResult?: StringNullableFilter<"extratoonline"> | string | null
    idUsuario?: IntFilter<"extratoonline"> | number
  }

  export type extratoonlineOrderByWithRelationInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    id_fornecedor?: SortOrder
    beneficio?: SortOrder
    jsonResult?: SortOrderInput | SortOrder
    filePdf?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isCache?: SortOrderInput | SortOrder
    statusConsulta?: SortOrderInput | SortOrder
    idConsultaOffline?: SortOrder
    errorResult?: SortOrderInput | SortOrder
    idUsuario?: SortOrder
    _relevance?: extratoonlineOrderByRelevanceInput
  }

  export type extratoonlineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: extratoonlineWhereInput | extratoonlineWhereInput[]
    OR?: extratoonlineWhereInput[]
    NOT?: extratoonlineWhereInput | extratoonlineWhereInput[]
    idConsulta?: IntFilter<"extratoonline"> | number
    id_fornecedor?: IntFilter<"extratoonline"> | number
    beneficio?: StringFilter<"extratoonline"> | string
    jsonResult?: JsonNullableFilter<"extratoonline">
    filePdf?: BytesNullableFilter<"extratoonline"> | Uint8Array | null
    createdAt?: DateTimeFilter<"extratoonline"> | Date | string
    updatedAt?: DateTimeFilter<"extratoonline"> | Date | string
    isCache?: BoolNullableFilter<"extratoonline"> | boolean | null
    statusConsulta?: IntNullableFilter<"extratoonline"> | number | null
    idConsultaOffline?: IntFilter<"extratoonline"> | number
    errorResult?: StringNullableFilter<"extratoonline"> | string | null
    idUsuario?: IntFilter<"extratoonline"> | number
  }, "id">

  export type extratoonlineOrderByWithAggregationInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    id_fornecedor?: SortOrder
    beneficio?: SortOrder
    jsonResult?: SortOrderInput | SortOrder
    filePdf?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isCache?: SortOrderInput | SortOrder
    statusConsulta?: SortOrderInput | SortOrder
    idConsultaOffline?: SortOrder
    errorResult?: SortOrderInput | SortOrder
    idUsuario?: SortOrder
    _count?: extratoonlineCountOrderByAggregateInput
    _avg?: extratoonlineAvgOrderByAggregateInput
    _max?: extratoonlineMaxOrderByAggregateInput
    _min?: extratoonlineMinOrderByAggregateInput
    _sum?: extratoonlineSumOrderByAggregateInput
  }

  export type extratoonlineScalarWhereWithAggregatesInput = {
    AND?: extratoonlineScalarWhereWithAggregatesInput | extratoonlineScalarWhereWithAggregatesInput[]
    OR?: extratoonlineScalarWhereWithAggregatesInput[]
    NOT?: extratoonlineScalarWhereWithAggregatesInput | extratoonlineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"extratoonline"> | number
    idConsulta?: IntWithAggregatesFilter<"extratoonline"> | number
    id_fornecedor?: IntWithAggregatesFilter<"extratoonline"> | number
    beneficio?: StringWithAggregatesFilter<"extratoonline"> | string
    jsonResult?: JsonNullableWithAggregatesFilter<"extratoonline">
    filePdf?: BytesNullableWithAggregatesFilter<"extratoonline"> | Uint8Array | null
    createdAt?: DateTimeWithAggregatesFilter<"extratoonline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"extratoonline"> | Date | string
    isCache?: BoolNullableWithAggregatesFilter<"extratoonline"> | boolean | null
    statusConsulta?: IntNullableWithAggregatesFilter<"extratoonline"> | number | null
    idConsultaOffline?: IntWithAggregatesFilter<"extratoonline"> | number
    errorResult?: StringNullableWithAggregatesFilter<"extratoonline"> | string | null
    idUsuario?: IntWithAggregatesFilter<"extratoonline"> | number
  }

  export type fornecedorWhereInput = {
    AND?: fornecedorWhereInput | fornecedorWhereInput[]
    OR?: fornecedorWhereInput[]
    NOT?: fornecedorWhereInput | fornecedorWhereInput[]
    id?: IntFilter<"fornecedor"> | number
    descricao?: StringFilter<"fornecedor"> | string
    cnpj?: StringNullableFilter<"fornecedor"> | string | null
    logradouro?: StringNullableFilter<"fornecedor"> | string | null
    numero?: IntNullableFilter<"fornecedor"> | number | null
    complemento?: StringNullableFilter<"fornecedor"> | string | null
    cep?: StringNullableFilter<"fornecedor"> | string | null
    cidade?: StringNullableFilter<"fornecedor"> | string | null
    estado?: StringNullableFilter<"fornecedor"> | string | null
    apikey?: StringNullableFilter<"fornecedor"> | string | null
    ativo?: BoolFilter<"fornecedor"> | boolean
    createdAt?: DateTimeFilter<"fornecedor"> | Date | string
    updatedAt?: DateTimeFilter<"fornecedor"> | Date | string
    urlapi?: StringNullableFilter<"fornecedor"> | string | null
    usuarioApi?: StringNullableFilter<"fornecedor"> | string | null
    senhaApi?: StringNullableFilter<"fornecedor"> | string | null
    dataHoraValidacaoApiKey?: DateTimeNullableFilter<"fornecedor"> | Date | string | null
  }

  export type fornecedorOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    cnpj?: SortOrderInput | SortOrder
    logradouro?: SortOrderInput | SortOrder
    numero?: SortOrderInput | SortOrder
    complemento?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    apikey?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    urlapi?: SortOrderInput | SortOrder
    usuarioApi?: SortOrderInput | SortOrder
    senhaApi?: SortOrderInput | SortOrder
    dataHoraValidacaoApiKey?: SortOrderInput | SortOrder
    _relevance?: fornecedorOrderByRelevanceInput
  }

  export type fornecedorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: fornecedorWhereInput | fornecedorWhereInput[]
    OR?: fornecedorWhereInput[]
    NOT?: fornecedorWhereInput | fornecedorWhereInput[]
    descricao?: StringFilter<"fornecedor"> | string
    cnpj?: StringNullableFilter<"fornecedor"> | string | null
    logradouro?: StringNullableFilter<"fornecedor"> | string | null
    numero?: IntNullableFilter<"fornecedor"> | number | null
    complemento?: StringNullableFilter<"fornecedor"> | string | null
    cep?: StringNullableFilter<"fornecedor"> | string | null
    cidade?: StringNullableFilter<"fornecedor"> | string | null
    estado?: StringNullableFilter<"fornecedor"> | string | null
    apikey?: StringNullableFilter<"fornecedor"> | string | null
    ativo?: BoolFilter<"fornecedor"> | boolean
    createdAt?: DateTimeFilter<"fornecedor"> | Date | string
    updatedAt?: DateTimeFilter<"fornecedor"> | Date | string
    urlapi?: StringNullableFilter<"fornecedor"> | string | null
    usuarioApi?: StringNullableFilter<"fornecedor"> | string | null
    senhaApi?: StringNullableFilter<"fornecedor"> | string | null
    dataHoraValidacaoApiKey?: DateTimeNullableFilter<"fornecedor"> | Date | string | null
  }, "id">

  export type fornecedorOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    cnpj?: SortOrderInput | SortOrder
    logradouro?: SortOrderInput | SortOrder
    numero?: SortOrderInput | SortOrder
    complemento?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    apikey?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    urlapi?: SortOrderInput | SortOrder
    usuarioApi?: SortOrderInput | SortOrder
    senhaApi?: SortOrderInput | SortOrder
    dataHoraValidacaoApiKey?: SortOrderInput | SortOrder
    _count?: fornecedorCountOrderByAggregateInput
    _avg?: fornecedorAvgOrderByAggregateInput
    _max?: fornecedorMaxOrderByAggregateInput
    _min?: fornecedorMinOrderByAggregateInput
    _sum?: fornecedorSumOrderByAggregateInput
  }

  export type fornecedorScalarWhereWithAggregatesInput = {
    AND?: fornecedorScalarWhereWithAggregatesInput | fornecedorScalarWhereWithAggregatesInput[]
    OR?: fornecedorScalarWhereWithAggregatesInput[]
    NOT?: fornecedorScalarWhereWithAggregatesInput | fornecedorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"fornecedor"> | number
    descricao?: StringWithAggregatesFilter<"fornecedor"> | string
    cnpj?: StringNullableWithAggregatesFilter<"fornecedor"> | string | null
    logradouro?: StringNullableWithAggregatesFilter<"fornecedor"> | string | null
    numero?: IntNullableWithAggregatesFilter<"fornecedor"> | number | null
    complemento?: StringNullableWithAggregatesFilter<"fornecedor"> | string | null
    cep?: StringNullableWithAggregatesFilter<"fornecedor"> | string | null
    cidade?: StringNullableWithAggregatesFilter<"fornecedor"> | string | null
    estado?: StringNullableWithAggregatesFilter<"fornecedor"> | string | null
    apikey?: StringNullableWithAggregatesFilter<"fornecedor"> | string | null
    ativo?: BoolWithAggregatesFilter<"fornecedor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"fornecedor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"fornecedor"> | Date | string
    urlapi?: StringNullableWithAggregatesFilter<"fornecedor"> | string | null
    usuarioApi?: StringNullableWithAggregatesFilter<"fornecedor"> | string | null
    senhaApi?: StringNullableWithAggregatesFilter<"fornecedor"> | string | null
    dataHoraValidacaoApiKey?: DateTimeNullableWithAggregatesFilter<"fornecedor"> | Date | string | null
  }

  export type fornecedorservicoWhereInput = {
    AND?: fornecedorservicoWhereInput | fornecedorservicoWhereInput[]
    OR?: fornecedorservicoWhereInput[]
    NOT?: fornecedorservicoWhereInput | fornecedorservicoWhereInput[]
    id?: IntFilter<"fornecedorservico"> | number
    idServico?: IntFilter<"fornecedorservico"> | number
    idFornecedor?: IntFilter<"fornecedorservico"> | number
    ativo?: BoolNullableFilter<"fornecedorservico"> | boolean | null
    createdAt?: DateTimeFilter<"fornecedorservico"> | Date | string
    updatedAt?: DateTimeFilter<"fornecedorservico"> | Date | string
  }

  export type fornecedorservicoOrderByWithRelationInput = {
    id?: SortOrder
    idServico?: SortOrder
    idFornecedor?: SortOrder
    ativo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type fornecedorservicoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: fornecedorservicoWhereInput | fornecedorservicoWhereInput[]
    OR?: fornecedorservicoWhereInput[]
    NOT?: fornecedorservicoWhereInput | fornecedorservicoWhereInput[]
    idServico?: IntFilter<"fornecedorservico"> | number
    idFornecedor?: IntFilter<"fornecedorservico"> | number
    ativo?: BoolNullableFilter<"fornecedorservico"> | boolean | null
    createdAt?: DateTimeFilter<"fornecedorservico"> | Date | string
    updatedAt?: DateTimeFilter<"fornecedorservico"> | Date | string
  }, "id">

  export type fornecedorservicoOrderByWithAggregationInput = {
    id?: SortOrder
    idServico?: SortOrder
    idFornecedor?: SortOrder
    ativo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: fornecedorservicoCountOrderByAggregateInput
    _avg?: fornecedorservicoAvgOrderByAggregateInput
    _max?: fornecedorservicoMaxOrderByAggregateInput
    _min?: fornecedorservicoMinOrderByAggregateInput
    _sum?: fornecedorservicoSumOrderByAggregateInput
  }

  export type fornecedorservicoScalarWhereWithAggregatesInput = {
    AND?: fornecedorservicoScalarWhereWithAggregatesInput | fornecedorservicoScalarWhereWithAggregatesInput[]
    OR?: fornecedorservicoScalarWhereWithAggregatesInput[]
    NOT?: fornecedorservicoScalarWhereWithAggregatesInput | fornecedorservicoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"fornecedorservico"> | number
    idServico?: IntWithAggregatesFilter<"fornecedorservico"> | number
    idFornecedor?: IntWithAggregatesFilter<"fornecedorservico"> | number
    ativo?: BoolNullableWithAggregatesFilter<"fornecedorservico"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"fornecedorservico"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"fornecedorservico"> | Date | string
  }

  export type historicoconsultaapiWhereInput = {
    AND?: historicoconsultaapiWhereInput | historicoconsultaapiWhereInput[]
    OR?: historicoconsultaapiWhereInput[]
    NOT?: historicoconsultaapiWhereInput | historicoconsultaapiWhereInput[]
    id?: IntFilter<"historicoconsultaapi"> | number
    idservico?: IntFilter<"historicoconsultaapi"> | number
    idfornecedor?: IntFilter<"historicoconsultaapi"> | number
    cpf?: StringNullableFilter<"historicoconsultaapi"> | string | null
    cpfRepresentanteLegal?: StringNullableFilter<"historicoconsultaapi"> | string | null
    beneficio?: StringNullableFilter<"historicoconsultaapi"> | string | null
    resultado?: JsonNullableFilter<"historicoconsultaapi">
    statusConsulta?: IntNullableFilter<"historicoconsultaapi"> | number | null
    createdAt?: DateTimeFilter<"historicoconsultaapi"> | Date | string
    updatedAt?: DateTimeNullableFilter<"historicoconsultaapi"> | Date | string | null
  }

  export type historicoconsultaapiOrderByWithRelationInput = {
    id?: SortOrder
    idservico?: SortOrder
    idfornecedor?: SortOrder
    cpf?: SortOrderInput | SortOrder
    cpfRepresentanteLegal?: SortOrderInput | SortOrder
    beneficio?: SortOrderInput | SortOrder
    resultado?: SortOrderInput | SortOrder
    statusConsulta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _relevance?: historicoconsultaapiOrderByRelevanceInput
  }

  export type historicoconsultaapiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: historicoconsultaapiWhereInput | historicoconsultaapiWhereInput[]
    OR?: historicoconsultaapiWhereInput[]
    NOT?: historicoconsultaapiWhereInput | historicoconsultaapiWhereInput[]
    idservico?: IntFilter<"historicoconsultaapi"> | number
    idfornecedor?: IntFilter<"historicoconsultaapi"> | number
    cpf?: StringNullableFilter<"historicoconsultaapi"> | string | null
    cpfRepresentanteLegal?: StringNullableFilter<"historicoconsultaapi"> | string | null
    beneficio?: StringNullableFilter<"historicoconsultaapi"> | string | null
    resultado?: JsonNullableFilter<"historicoconsultaapi">
    statusConsulta?: IntNullableFilter<"historicoconsultaapi"> | number | null
    createdAt?: DateTimeFilter<"historicoconsultaapi"> | Date | string
    updatedAt?: DateTimeNullableFilter<"historicoconsultaapi"> | Date | string | null
  }, "id">

  export type historicoconsultaapiOrderByWithAggregationInput = {
    id?: SortOrder
    idservico?: SortOrder
    idfornecedor?: SortOrder
    cpf?: SortOrderInput | SortOrder
    cpfRepresentanteLegal?: SortOrderInput | SortOrder
    beneficio?: SortOrderInput | SortOrder
    resultado?: SortOrderInput | SortOrder
    statusConsulta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: historicoconsultaapiCountOrderByAggregateInput
    _avg?: historicoconsultaapiAvgOrderByAggregateInput
    _max?: historicoconsultaapiMaxOrderByAggregateInput
    _min?: historicoconsultaapiMinOrderByAggregateInput
    _sum?: historicoconsultaapiSumOrderByAggregateInput
  }

  export type historicoconsultaapiScalarWhereWithAggregatesInput = {
    AND?: historicoconsultaapiScalarWhereWithAggregatesInput | historicoconsultaapiScalarWhereWithAggregatesInput[]
    OR?: historicoconsultaapiScalarWhereWithAggregatesInput[]
    NOT?: historicoconsultaapiScalarWhereWithAggregatesInput | historicoconsultaapiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"historicoconsultaapi"> | number
    idservico?: IntWithAggregatesFilter<"historicoconsultaapi"> | number
    idfornecedor?: IntWithAggregatesFilter<"historicoconsultaapi"> | number
    cpf?: StringNullableWithAggregatesFilter<"historicoconsultaapi"> | string | null
    cpfRepresentanteLegal?: StringNullableWithAggregatesFilter<"historicoconsultaapi"> | string | null
    beneficio?: StringNullableWithAggregatesFilter<"historicoconsultaapi"> | string | null
    resultado?: JsonNullableWithAggregatesFilter<"historicoconsultaapi">
    statusConsulta?: IntNullableWithAggregatesFilter<"historicoconsultaapi"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"historicoconsultaapi"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"historicoconsultaapi"> | Date | string | null
  }

  export type historicocreditoWhereInput = {
    AND?: historicocreditoWhereInput | historicocreditoWhereInput[]
    OR?: historicocreditoWhereInput[]
    NOT?: historicocreditoWhereInput | historicocreditoWhereInput[]
    id?: IntFilter<"historicocredito"> | number
    clienteId?: IntFilter<"historicocredito"> | number
    tipoOperacao?: IntFilter<"historicocredito"> | number
    quantidade?: IntFilter<"historicocredito"> | number
    createdAt?: DateTimeFilter<"historicocredito"> | Date | string
    idServico?: IntFilter<"historicocredito"> | number
  }

  export type historicocreditoOrderByWithRelationInput = {
    id?: SortOrder
    clienteId?: SortOrder
    tipoOperacao?: SortOrder
    quantidade?: SortOrder
    createdAt?: SortOrder
    idServico?: SortOrder
  }

  export type historicocreditoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: historicocreditoWhereInput | historicocreditoWhereInput[]
    OR?: historicocreditoWhereInput[]
    NOT?: historicocreditoWhereInput | historicocreditoWhereInput[]
    clienteId?: IntFilter<"historicocredito"> | number
    tipoOperacao?: IntFilter<"historicocredito"> | number
    quantidade?: IntFilter<"historicocredito"> | number
    createdAt?: DateTimeFilter<"historicocredito"> | Date | string
    idServico?: IntFilter<"historicocredito"> | number
  }, "id">

  export type historicocreditoOrderByWithAggregationInput = {
    id?: SortOrder
    clienteId?: SortOrder
    tipoOperacao?: SortOrder
    quantidade?: SortOrder
    createdAt?: SortOrder
    idServico?: SortOrder
    _count?: historicocreditoCountOrderByAggregateInput
    _avg?: historicocreditoAvgOrderByAggregateInput
    _max?: historicocreditoMaxOrderByAggregateInput
    _min?: historicocreditoMinOrderByAggregateInput
    _sum?: historicocreditoSumOrderByAggregateInput
  }

  export type historicocreditoScalarWhereWithAggregatesInput = {
    AND?: historicocreditoScalarWhereWithAggregatesInput | historicocreditoScalarWhereWithAggregatesInput[]
    OR?: historicocreditoScalarWhereWithAggregatesInput[]
    NOT?: historicocreditoScalarWhereWithAggregatesInput | historicocreditoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"historicocredito"> | number
    clienteId?: IntWithAggregatesFilter<"historicocredito"> | number
    tipoOperacao?: IntWithAggregatesFilter<"historicocredito"> | number
    quantidade?: IntWithAggregatesFilter<"historicocredito"> | number
    createdAt?: DateTimeWithAggregatesFilter<"historicocredito"> | Date | string
    idServico?: IntWithAggregatesFilter<"historicocredito"> | number
  }

  export type in100WhereInput = {
    AND?: in100WhereInput | in100WhereInput[]
    OR?: in100WhereInput[]
    NOT?: in100WhereInput | in100WhereInput[]
    id?: IntFilter<"in100"> | number
    idUsuario?: IntFilter<"in100"> | number
    idConsulta?: IntFilter<"in100"> | number
    idConsultaOffline?: IntFilter<"in100"> | number
    cpf?: StringFilter<"in100"> | string
    numeroBeneficio?: StringNullableFilter<"in100"> | string | null
    situacao?: StringNullableFilter<"in100"> | string | null
    requisicao?: BigIntNullableFilter<"in100"> | bigint | number | null
    errorID?: StringNullableFilter<"in100"> | string | null
    resultado?: JsonNullableFilter<"in100">
    createdAt?: DateTimeFilter<"in100"> | Date | string
    updatedAt?: DateTimeFilter<"in100"> | Date | string
    cpfRepresentanteLegal?: StringNullableFilter<"in100"> | string | null
    idFornecedor?: IntFilter<"in100"> | number
    idStatusSolicitacaoIn100?: IntFilter<"in100"> | number
    msgErro?: StringNullableFilter<"in100"> | string | null
  }

  export type in100OrderByWithRelationInput = {
    id?: SortOrder
    idUsuario?: SortOrder
    idConsulta?: SortOrder
    idConsultaOffline?: SortOrder
    cpf?: SortOrder
    numeroBeneficio?: SortOrderInput | SortOrder
    situacao?: SortOrderInput | SortOrder
    requisicao?: SortOrderInput | SortOrder
    errorID?: SortOrderInput | SortOrder
    resultado?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpfRepresentanteLegal?: SortOrderInput | SortOrder
    idFornecedor?: SortOrder
    idStatusSolicitacaoIn100?: SortOrder
    msgErro?: SortOrderInput | SortOrder
    _relevance?: in100OrderByRelevanceInput
  }

  export type in100WhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: in100WhereInput | in100WhereInput[]
    OR?: in100WhereInput[]
    NOT?: in100WhereInput | in100WhereInput[]
    idUsuario?: IntFilter<"in100"> | number
    idConsulta?: IntFilter<"in100"> | number
    idConsultaOffline?: IntFilter<"in100"> | number
    cpf?: StringFilter<"in100"> | string
    numeroBeneficio?: StringNullableFilter<"in100"> | string | null
    situacao?: StringNullableFilter<"in100"> | string | null
    requisicao?: BigIntNullableFilter<"in100"> | bigint | number | null
    errorID?: StringNullableFilter<"in100"> | string | null
    resultado?: JsonNullableFilter<"in100">
    createdAt?: DateTimeFilter<"in100"> | Date | string
    updatedAt?: DateTimeFilter<"in100"> | Date | string
    cpfRepresentanteLegal?: StringNullableFilter<"in100"> | string | null
    idFornecedor?: IntFilter<"in100"> | number
    idStatusSolicitacaoIn100?: IntFilter<"in100"> | number
    msgErro?: StringNullableFilter<"in100"> | string | null
  }, "id">

  export type in100OrderByWithAggregationInput = {
    id?: SortOrder
    idUsuario?: SortOrder
    idConsulta?: SortOrder
    idConsultaOffline?: SortOrder
    cpf?: SortOrder
    numeroBeneficio?: SortOrderInput | SortOrder
    situacao?: SortOrderInput | SortOrder
    requisicao?: SortOrderInput | SortOrder
    errorID?: SortOrderInput | SortOrder
    resultado?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpfRepresentanteLegal?: SortOrderInput | SortOrder
    idFornecedor?: SortOrder
    idStatusSolicitacaoIn100?: SortOrder
    msgErro?: SortOrderInput | SortOrder
    _count?: in100CountOrderByAggregateInput
    _avg?: in100AvgOrderByAggregateInput
    _max?: in100MaxOrderByAggregateInput
    _min?: in100MinOrderByAggregateInput
    _sum?: in100SumOrderByAggregateInput
  }

  export type in100ScalarWhereWithAggregatesInput = {
    AND?: in100ScalarWhereWithAggregatesInput | in100ScalarWhereWithAggregatesInput[]
    OR?: in100ScalarWhereWithAggregatesInput[]
    NOT?: in100ScalarWhereWithAggregatesInput | in100ScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"in100"> | number
    idUsuario?: IntWithAggregatesFilter<"in100"> | number
    idConsulta?: IntWithAggregatesFilter<"in100"> | number
    idConsultaOffline?: IntWithAggregatesFilter<"in100"> | number
    cpf?: StringWithAggregatesFilter<"in100"> | string
    numeroBeneficio?: StringNullableWithAggregatesFilter<"in100"> | string | null
    situacao?: StringNullableWithAggregatesFilter<"in100"> | string | null
    requisicao?: BigIntNullableWithAggregatesFilter<"in100"> | bigint | number | null
    errorID?: StringNullableWithAggregatesFilter<"in100"> | string | null
    resultado?: JsonNullableWithAggregatesFilter<"in100">
    createdAt?: DateTimeWithAggregatesFilter<"in100"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"in100"> | Date | string
    cpfRepresentanteLegal?: StringNullableWithAggregatesFilter<"in100"> | string | null
    idFornecedor?: IntWithAggregatesFilter<"in100"> | number
    idStatusSolicitacaoIn100?: IntWithAggregatesFilter<"in100"> | number
    msgErro?: StringNullableWithAggregatesFilter<"in100"> | string | null
  }

  export type loginsWhereInput = {
    AND?: loginsWhereInput | loginsWhereInput[]
    OR?: loginsWhereInput[]
    NOT?: loginsWhereInput | loginsWhereInput[]
    id?: IntFilter<"logins"> | number
    name?: StringFilter<"logins"> | string
    user_name?: StringFilter<"logins"> | string
    active?: BoolFilter<"logins"> | boolean
    password?: StringFilter<"logins"> | string
    idperfil?: IntFilter<"logins"> | number
    createdAt?: DateTimeFilter<"logins"> | Date | string
    updatedAt?: DateTimeFilter<"logins"> | Date | string
    cpf?: StringFilter<"logins"> | string
    email?: StringFilter<"logins"> | string
    telefone?: StringFilter<"logins"> | string
    usuarioAPi?: BoolFilter<"logins"> | boolean
    chaveApi?: StringFilter<"logins"> | string
    perfil?: XOR<PerfilusuarioScalarRelationFilter, perfilusuarioWhereInput>
  }

  export type loginsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    user_name?: SortOrder
    active?: SortOrder
    password?: SortOrder
    idperfil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    usuarioAPi?: SortOrder
    chaveApi?: SortOrder
    perfil?: perfilusuarioOrderByWithRelationInput
    _relevance?: loginsOrderByRelevanceInput
  }

  export type loginsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: loginsWhereInput | loginsWhereInput[]
    OR?: loginsWhereInput[]
    NOT?: loginsWhereInput | loginsWhereInput[]
    name?: StringFilter<"logins"> | string
    user_name?: StringFilter<"logins"> | string
    active?: BoolFilter<"logins"> | boolean
    password?: StringFilter<"logins"> | string
    idperfil?: IntFilter<"logins"> | number
    createdAt?: DateTimeFilter<"logins"> | Date | string
    updatedAt?: DateTimeFilter<"logins"> | Date | string
    cpf?: StringFilter<"logins"> | string
    email?: StringFilter<"logins"> | string
    telefone?: StringFilter<"logins"> | string
    usuarioAPi?: BoolFilter<"logins"> | boolean
    chaveApi?: StringFilter<"logins"> | string
    perfil?: XOR<PerfilusuarioScalarRelationFilter, perfilusuarioWhereInput>
  }, "id">

  export type loginsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    user_name?: SortOrder
    active?: SortOrder
    password?: SortOrder
    idperfil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    usuarioAPi?: SortOrder
    chaveApi?: SortOrder
    _count?: loginsCountOrderByAggregateInput
    _avg?: loginsAvgOrderByAggregateInput
    _max?: loginsMaxOrderByAggregateInput
    _min?: loginsMinOrderByAggregateInput
    _sum?: loginsSumOrderByAggregateInput
  }

  export type loginsScalarWhereWithAggregatesInput = {
    AND?: loginsScalarWhereWithAggregatesInput | loginsScalarWhereWithAggregatesInput[]
    OR?: loginsScalarWhereWithAggregatesInput[]
    NOT?: loginsScalarWhereWithAggregatesInput | loginsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"logins"> | number
    name?: StringWithAggregatesFilter<"logins"> | string
    user_name?: StringWithAggregatesFilter<"logins"> | string
    active?: BoolWithAggregatesFilter<"logins"> | boolean
    password?: StringWithAggregatesFilter<"logins"> | string
    idperfil?: IntWithAggregatesFilter<"logins"> | number
    createdAt?: DateTimeWithAggregatesFilter<"logins"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"logins"> | Date | string
    cpf?: StringWithAggregatesFilter<"logins"> | string
    email?: StringWithAggregatesFilter<"logins"> | string
    telefone?: StringWithAggregatesFilter<"logins"> | string
    usuarioAPi?: BoolWithAggregatesFilter<"logins"> | boolean
    chaveApi?: StringWithAggregatesFilter<"logins"> | string
  }

  export type menuWhereInput = {
    AND?: menuWhereInput | menuWhereInput[]
    OR?: menuWhereInput[]
    NOT?: menuWhereInput | menuWhereInput[]
    id?: IntFilter<"menu"> | number
    codsequencia?: IntFilter<"menu"> | number
    descricao?: StringFilter<"menu"> | string
    pagina?: StringFilter<"menu"> | string
    rota?: StringFilter<"menu"> | string
    idmodulo?: IntFilter<"menu"> | number
    createdAt?: DateTimeFilter<"menu"> | Date | string
    updatedAt?: DateTimeFilter<"menu"> | Date | string
    icone?: StringNullableFilter<"menu"> | string | null
  }

  export type menuOrderByWithRelationInput = {
    id?: SortOrder
    codsequencia?: SortOrder
    descricao?: SortOrder
    pagina?: SortOrder
    rota?: SortOrder
    idmodulo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    icone?: SortOrderInput | SortOrder
    _relevance?: menuOrderByRelevanceInput
  }

  export type menuWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: menuWhereInput | menuWhereInput[]
    OR?: menuWhereInput[]
    NOT?: menuWhereInput | menuWhereInput[]
    codsequencia?: IntFilter<"menu"> | number
    descricao?: StringFilter<"menu"> | string
    pagina?: StringFilter<"menu"> | string
    rota?: StringFilter<"menu"> | string
    idmodulo?: IntFilter<"menu"> | number
    createdAt?: DateTimeFilter<"menu"> | Date | string
    updatedAt?: DateTimeFilter<"menu"> | Date | string
    icone?: StringNullableFilter<"menu"> | string | null
  }, "id">

  export type menuOrderByWithAggregationInput = {
    id?: SortOrder
    codsequencia?: SortOrder
    descricao?: SortOrder
    pagina?: SortOrder
    rota?: SortOrder
    idmodulo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    icone?: SortOrderInput | SortOrder
    _count?: menuCountOrderByAggregateInput
    _avg?: menuAvgOrderByAggregateInput
    _max?: menuMaxOrderByAggregateInput
    _min?: menuMinOrderByAggregateInput
    _sum?: menuSumOrderByAggregateInput
  }

  export type menuScalarWhereWithAggregatesInput = {
    AND?: menuScalarWhereWithAggregatesInput | menuScalarWhereWithAggregatesInput[]
    OR?: menuScalarWhereWithAggregatesInput[]
    NOT?: menuScalarWhereWithAggregatesInput | menuScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"menu"> | number
    codsequencia?: IntWithAggregatesFilter<"menu"> | number
    descricao?: StringWithAggregatesFilter<"menu"> | string
    pagina?: StringWithAggregatesFilter<"menu"> | string
    rota?: StringWithAggregatesFilter<"menu"> | string
    idmodulo?: IntWithAggregatesFilter<"menu"> | number
    createdAt?: DateTimeWithAggregatesFilter<"menu"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"menu"> | Date | string
    icone?: StringNullableWithAggregatesFilter<"menu"> | string | null
  }

  export type modulosWhereInput = {
    AND?: modulosWhereInput | modulosWhereInput[]
    OR?: modulosWhereInput[]
    NOT?: modulosWhereInput | modulosWhereInput[]
    id?: IntFilter<"modulos"> | number
    desc_modulo?: StringFilter<"modulos"> | string
    createdAt?: DateTimeFilter<"modulos"> | Date | string
    updatedAt?: DateTimeFilter<"modulos"> | Date | string
    perfilXmodulos?: Perfil_moduloListRelationFilter
  }

  export type modulosOrderByWithRelationInput = {
    id?: SortOrder
    desc_modulo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    perfilXmodulos?: perfil_moduloOrderByRelationAggregateInput
    _relevance?: modulosOrderByRelevanceInput
  }

  export type modulosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: modulosWhereInput | modulosWhereInput[]
    OR?: modulosWhereInput[]
    NOT?: modulosWhereInput | modulosWhereInput[]
    desc_modulo?: StringFilter<"modulos"> | string
    createdAt?: DateTimeFilter<"modulos"> | Date | string
    updatedAt?: DateTimeFilter<"modulos"> | Date | string
    perfilXmodulos?: Perfil_moduloListRelationFilter
  }, "id">

  export type modulosOrderByWithAggregationInput = {
    id?: SortOrder
    desc_modulo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: modulosCountOrderByAggregateInput
    _avg?: modulosAvgOrderByAggregateInput
    _max?: modulosMaxOrderByAggregateInput
    _min?: modulosMinOrderByAggregateInput
    _sum?: modulosSumOrderByAggregateInput
  }

  export type modulosScalarWhereWithAggregatesInput = {
    AND?: modulosScalarWhereWithAggregatesInput | modulosScalarWhereWithAggregatesInput[]
    OR?: modulosScalarWhereWithAggregatesInput[]
    NOT?: modulosScalarWhereWithAggregatesInput | modulosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"modulos"> | number
    desc_modulo?: StringWithAggregatesFilter<"modulos"> | string
    createdAt?: DateTimeWithAggregatesFilter<"modulos"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"modulos"> | Date | string
  }

  export type perfil_moduloWhereInput = {
    AND?: perfil_moduloWhereInput | perfil_moduloWhereInput[]
    OR?: perfil_moduloWhereInput[]
    NOT?: perfil_moduloWhereInput | perfil_moduloWhereInput[]
    id?: IntFilter<"perfil_modulo"> | number
    idperfil?: IntFilter<"perfil_modulo"> | number
    idmodulo?: IntFilter<"perfil_modulo"> | number
    createdAt?: DateTimeFilter<"perfil_modulo"> | Date | string
    updatedAt?: DateTimeFilter<"perfil_modulo"> | Date | string
    perfil?: XOR<PerfilusuarioScalarRelationFilter, perfilusuarioWhereInput>
    modulo?: XOR<ModulosScalarRelationFilter, modulosWhereInput>
  }

  export type perfil_moduloOrderByWithRelationInput = {
    id?: SortOrder
    idperfil?: SortOrder
    idmodulo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    perfil?: perfilusuarioOrderByWithRelationInput
    modulo?: modulosOrderByWithRelationInput
  }

  export type perfil_moduloWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: perfil_moduloWhereInput | perfil_moduloWhereInput[]
    OR?: perfil_moduloWhereInput[]
    NOT?: perfil_moduloWhereInput | perfil_moduloWhereInput[]
    idperfil?: IntFilter<"perfil_modulo"> | number
    idmodulo?: IntFilter<"perfil_modulo"> | number
    createdAt?: DateTimeFilter<"perfil_modulo"> | Date | string
    updatedAt?: DateTimeFilter<"perfil_modulo"> | Date | string
    perfil?: XOR<PerfilusuarioScalarRelationFilter, perfilusuarioWhereInput>
    modulo?: XOR<ModulosScalarRelationFilter, modulosWhereInput>
  }, "id">

  export type perfil_moduloOrderByWithAggregationInput = {
    id?: SortOrder
    idperfil?: SortOrder
    idmodulo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: perfil_moduloCountOrderByAggregateInput
    _avg?: perfil_moduloAvgOrderByAggregateInput
    _max?: perfil_moduloMaxOrderByAggregateInput
    _min?: perfil_moduloMinOrderByAggregateInput
    _sum?: perfil_moduloSumOrderByAggregateInput
  }

  export type perfil_moduloScalarWhereWithAggregatesInput = {
    AND?: perfil_moduloScalarWhereWithAggregatesInput | perfil_moduloScalarWhereWithAggregatesInput[]
    OR?: perfil_moduloScalarWhereWithAggregatesInput[]
    NOT?: perfil_moduloScalarWhereWithAggregatesInput | perfil_moduloScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"perfil_modulo"> | number
    idperfil?: IntWithAggregatesFilter<"perfil_modulo"> | number
    idmodulo?: IntWithAggregatesFilter<"perfil_modulo"> | number
    createdAt?: DateTimeWithAggregatesFilter<"perfil_modulo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"perfil_modulo"> | Date | string
  }

  export type perfilusuarioWhereInput = {
    AND?: perfilusuarioWhereInput | perfilusuarioWhereInput[]
    OR?: perfilusuarioWhereInput[]
    NOT?: perfilusuarioWhereInput | perfilusuarioWhereInput[]
    id?: IntFilter<"perfilusuario"> | number
    descricao?: StringFilter<"perfilusuario"> | string
    logins?: LoginsListRelationFilter
    perfilXmodulos?: Perfil_moduloListRelationFilter
  }

  export type perfilusuarioOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    logins?: loginsOrderByRelationAggregateInput
    perfilXmodulos?: perfil_moduloOrderByRelationAggregateInput
    _relevance?: perfilusuarioOrderByRelevanceInput
  }

  export type perfilusuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: perfilusuarioWhereInput | perfilusuarioWhereInput[]
    OR?: perfilusuarioWhereInput[]
    NOT?: perfilusuarioWhereInput | perfilusuarioWhereInput[]
    descricao?: StringFilter<"perfilusuario"> | string
    logins?: LoginsListRelationFilter
    perfilXmodulos?: Perfil_moduloListRelationFilter
  }, "id">

  export type perfilusuarioOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    _count?: perfilusuarioCountOrderByAggregateInput
    _avg?: perfilusuarioAvgOrderByAggregateInput
    _max?: perfilusuarioMaxOrderByAggregateInput
    _min?: perfilusuarioMinOrderByAggregateInput
    _sum?: perfilusuarioSumOrderByAggregateInput
  }

  export type perfilusuarioScalarWhereWithAggregatesInput = {
    AND?: perfilusuarioScalarWhereWithAggregatesInput | perfilusuarioScalarWhereWithAggregatesInput[]
    OR?: perfilusuarioScalarWhereWithAggregatesInput[]
    NOT?: perfilusuarioScalarWhereWithAggregatesInput | perfilusuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"perfilusuario"> | number
    descricao?: StringWithAggregatesFilter<"perfilusuario"> | string
  }

  export type senhasWhereInput = {
    AND?: senhasWhereInput | senhasWhereInput[]
    OR?: senhasWhereInput[]
    NOT?: senhasWhereInput | senhasWhereInput[]
    id?: IntFilter<"senhas"> | number
    idusuario?: IntFilter<"senhas"> | number
    senha?: StringNullableFilter<"senhas"> | string | null
    idretorno?: IntNullableFilter<"senhas"> | number | null
    observacao?: StringNullableFilter<"senhas"> | string | null
    createdAt?: DateTimeFilter<"senhas"> | Date | string
    updatedAt?: DateTimeFilter<"senhas"> | Date | string
    cpf?: StringFilter<"senhas"> | string
    idusuario_atualizacao?: IntNullableFilter<"senhas"> | number | null
  }

  export type senhasOrderByWithRelationInput = {
    id?: SortOrder
    idusuario?: SortOrder
    senha?: SortOrderInput | SortOrder
    idretorno?: SortOrderInput | SortOrder
    observacao?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpf?: SortOrder
    idusuario_atualizacao?: SortOrderInput | SortOrder
    _relevance?: senhasOrderByRelevanceInput
  }

  export type senhasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: senhasWhereInput | senhasWhereInput[]
    OR?: senhasWhereInput[]
    NOT?: senhasWhereInput | senhasWhereInput[]
    idusuario?: IntFilter<"senhas"> | number
    senha?: StringNullableFilter<"senhas"> | string | null
    idretorno?: IntNullableFilter<"senhas"> | number | null
    observacao?: StringNullableFilter<"senhas"> | string | null
    createdAt?: DateTimeFilter<"senhas"> | Date | string
    updatedAt?: DateTimeFilter<"senhas"> | Date | string
    cpf?: StringFilter<"senhas"> | string
    idusuario_atualizacao?: IntNullableFilter<"senhas"> | number | null
  }, "id">

  export type senhasOrderByWithAggregationInput = {
    id?: SortOrder
    idusuario?: SortOrder
    senha?: SortOrderInput | SortOrder
    idretorno?: SortOrderInput | SortOrder
    observacao?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpf?: SortOrder
    idusuario_atualizacao?: SortOrderInput | SortOrder
    _count?: senhasCountOrderByAggregateInput
    _avg?: senhasAvgOrderByAggregateInput
    _max?: senhasMaxOrderByAggregateInput
    _min?: senhasMinOrderByAggregateInput
    _sum?: senhasSumOrderByAggregateInput
  }

  export type senhasScalarWhereWithAggregatesInput = {
    AND?: senhasScalarWhereWithAggregatesInput | senhasScalarWhereWithAggregatesInput[]
    OR?: senhasScalarWhereWithAggregatesInput[]
    NOT?: senhasScalarWhereWithAggregatesInput | senhasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"senhas"> | number
    idusuario?: IntWithAggregatesFilter<"senhas"> | number
    senha?: StringNullableWithAggregatesFilter<"senhas"> | string | null
    idretorno?: IntNullableWithAggregatesFilter<"senhas"> | number | null
    observacao?: StringNullableWithAggregatesFilter<"senhas"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"senhas"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"senhas"> | Date | string
    cpf?: StringWithAggregatesFilter<"senhas"> | string
    idusuario_atualizacao?: IntNullableWithAggregatesFilter<"senhas"> | number | null
  }

  export type situacaoWhereInput = {
    AND?: situacaoWhereInput | situacaoWhereInput[]
    OR?: situacaoWhereInput[]
    NOT?: situacaoWhereInput | situacaoWhereInput[]
    id?: IntFilter<"situacao"> | number
    descricao?: StringFilter<"situacao"> | string
    icone?: StringNullableFilter<"situacao"> | string | null
    cor?: StringNullableFilter<"situacao"> | string | null
    createdAt?: DateTimeFilter<"situacao"> | Date | string
    updatedAt?: DateTimeFilter<"situacao"> | Date | string
    formsolicitar?: BoolFilter<"situacao"> | boolean
  }

  export type situacaoOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    icone?: SortOrderInput | SortOrder
    cor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    formsolicitar?: SortOrder
    _relevance?: situacaoOrderByRelevanceInput
  }

  export type situacaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: situacaoWhereInput | situacaoWhereInput[]
    OR?: situacaoWhereInput[]
    NOT?: situacaoWhereInput | situacaoWhereInput[]
    descricao?: StringFilter<"situacao"> | string
    icone?: StringNullableFilter<"situacao"> | string | null
    cor?: StringNullableFilter<"situacao"> | string | null
    createdAt?: DateTimeFilter<"situacao"> | Date | string
    updatedAt?: DateTimeFilter<"situacao"> | Date | string
    formsolicitar?: BoolFilter<"situacao"> | boolean
  }, "id">

  export type situacaoOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    icone?: SortOrderInput | SortOrder
    cor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    formsolicitar?: SortOrder
    _count?: situacaoCountOrderByAggregateInput
    _avg?: situacaoAvgOrderByAggregateInput
    _max?: situacaoMaxOrderByAggregateInput
    _min?: situacaoMinOrderByAggregateInput
    _sum?: situacaoSumOrderByAggregateInput
  }

  export type situacaoScalarWhereWithAggregatesInput = {
    AND?: situacaoScalarWhereWithAggregatesInput | situacaoScalarWhereWithAggregatesInput[]
    OR?: situacaoScalarWhereWithAggregatesInput[]
    NOT?: situacaoScalarWhereWithAggregatesInput | situacaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"situacao"> | number
    descricao?: StringWithAggregatesFilter<"situacao"> | string
    icone?: StringNullableWithAggregatesFilter<"situacao"> | string | null
    cor?: StringNullableWithAggregatesFilter<"situacao"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"situacao"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"situacao"> | Date | string
    formsolicitar?: BoolWithAggregatesFilter<"situacao"> | boolean
  }

  export type situacaosolicsenhaWhereInput = {
    AND?: situacaosolicsenhaWhereInput | situacaosolicsenhaWhereInput[]
    OR?: situacaosolicsenhaWhereInput[]
    NOT?: situacaosolicsenhaWhereInput | situacaosolicsenhaWhereInput[]
    id?: IntFilter<"situacaosolicsenha"> | number
    descricao?: StringFilter<"situacaosolicsenha"> | string
    createdAt?: DateTimeFilter<"situacaosolicsenha"> | Date | string
    updatedAt?: DateTimeFilter<"situacaosolicsenha"> | Date | string
    telaSolicitar?: BoolFilter<"situacaosolicsenha"> | boolean
    telaAtualizar?: BoolFilter<"situacaosolicsenha"> | boolean
  }

  export type situacaosolicsenhaOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telaSolicitar?: SortOrder
    telaAtualizar?: SortOrder
    _relevance?: situacaosolicsenhaOrderByRelevanceInput
  }

  export type situacaosolicsenhaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: situacaosolicsenhaWhereInput | situacaosolicsenhaWhereInput[]
    OR?: situacaosolicsenhaWhereInput[]
    NOT?: situacaosolicsenhaWhereInput | situacaosolicsenhaWhereInput[]
    descricao?: StringFilter<"situacaosolicsenha"> | string
    createdAt?: DateTimeFilter<"situacaosolicsenha"> | Date | string
    updatedAt?: DateTimeFilter<"situacaosolicsenha"> | Date | string
    telaSolicitar?: BoolFilter<"situacaosolicsenha"> | boolean
    telaAtualizar?: BoolFilter<"situacaosolicsenha"> | boolean
  }, "id">

  export type situacaosolicsenhaOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telaSolicitar?: SortOrder
    telaAtualizar?: SortOrder
    _count?: situacaosolicsenhaCountOrderByAggregateInput
    _avg?: situacaosolicsenhaAvgOrderByAggregateInput
    _max?: situacaosolicsenhaMaxOrderByAggregateInput
    _min?: situacaosolicsenhaMinOrderByAggregateInput
    _sum?: situacaosolicsenhaSumOrderByAggregateInput
  }

  export type situacaosolicsenhaScalarWhereWithAggregatesInput = {
    AND?: situacaosolicsenhaScalarWhereWithAggregatesInput | situacaosolicsenhaScalarWhereWithAggregatesInput[]
    OR?: situacaosolicsenhaScalarWhereWithAggregatesInput[]
    NOT?: situacaosolicsenhaScalarWhereWithAggregatesInput | situacaosolicsenhaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"situacaosolicsenha"> | number
    descricao?: StringWithAggregatesFilter<"situacaosolicsenha"> | string
    createdAt?: DateTimeWithAggregatesFilter<"situacaosolicsenha"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"situacaosolicsenha"> | Date | string
    telaSolicitar?: BoolWithAggregatesFilter<"situacaosolicsenha"> | boolean
    telaAtualizar?: BoolWithAggregatesFilter<"situacaosolicsenha"> | boolean
  }

  export type statussolicitacaoservicoWhereInput = {
    AND?: statussolicitacaoservicoWhereInput | statussolicitacaoservicoWhereInput[]
    OR?: statussolicitacaoservicoWhereInput[]
    NOT?: statussolicitacaoservicoWhereInput | statussolicitacaoservicoWhereInput[]
    id?: IntFilter<"statussolicitacaoservico"> | number
    codigo?: IntFilter<"statussolicitacaoservico"> | number
    descricao?: StringFilter<"statussolicitacaoservico"> | string
    createdAt?: DateTimeFilter<"statussolicitacaoservico"> | Date | string
    updatedAt?: DateTimeFilter<"statussolicitacaoservico"> | Date | string
  }

  export type statussolicitacaoservicoOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: statussolicitacaoservicoOrderByRelevanceInput
  }

  export type statussolicitacaoservicoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: statussolicitacaoservicoWhereInput | statussolicitacaoservicoWhereInput[]
    OR?: statussolicitacaoservicoWhereInput[]
    NOT?: statussolicitacaoservicoWhereInput | statussolicitacaoservicoWhereInput[]
    codigo?: IntFilter<"statussolicitacaoservico"> | number
    descricao?: StringFilter<"statussolicitacaoservico"> | string
    createdAt?: DateTimeFilter<"statussolicitacaoservico"> | Date | string
    updatedAt?: DateTimeFilter<"statussolicitacaoservico"> | Date | string
  }, "id">

  export type statussolicitacaoservicoOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: statussolicitacaoservicoCountOrderByAggregateInput
    _avg?: statussolicitacaoservicoAvgOrderByAggregateInput
    _max?: statussolicitacaoservicoMaxOrderByAggregateInput
    _min?: statussolicitacaoservicoMinOrderByAggregateInput
    _sum?: statussolicitacaoservicoSumOrderByAggregateInput
  }

  export type statussolicitacaoservicoScalarWhereWithAggregatesInput = {
    AND?: statussolicitacaoservicoScalarWhereWithAggregatesInput | statussolicitacaoservicoScalarWhereWithAggregatesInput[]
    OR?: statussolicitacaoservicoScalarWhereWithAggregatesInput[]
    NOT?: statussolicitacaoservicoScalarWhereWithAggregatesInput | statussolicitacaoservicoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"statussolicitacaoservico"> | number
    codigo?: IntWithAggregatesFilter<"statussolicitacaoservico"> | number
    descricao?: StringWithAggregatesFilter<"statussolicitacaoservico"> | string
    createdAt?: DateTimeWithAggregatesFilter<"statussolicitacaoservico"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"statussolicitacaoservico"> | Date | string
  }

  export type tiposervicoWhereInput = {
    AND?: tiposervicoWhereInput | tiposervicoWhereInput[]
    OR?: tiposervicoWhereInput[]
    NOT?: tiposervicoWhereInput | tiposervicoWhereInput[]
    id?: IntFilter<"tiposervico"> | number
    descricao?: StringFilter<"tiposervico"> | string
    createdAt?: DateTimeFilter<"tiposervico"> | Date | string
    updatedAt?: DateTimeFilter<"tiposervico"> | Date | string
    valorCusto?: FloatFilter<"tiposervico"> | number
    valorVenda?: FloatFilter<"tiposervico"> | number
    ativo?: BoolFilter<"tiposervico"> | boolean
    observacao?: StringNullableFilter<"tiposervico"> | string | null
    usuario_cad?: IntFilter<"tiposervico"> | number
    usuario_alt?: IntFilter<"tiposervico"> | number
    idfornecedor?: IntFilter<"tiposervico"> | number
  }

  export type tiposervicoOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    valorCusto?: SortOrder
    valorVenda?: SortOrder
    ativo?: SortOrder
    observacao?: SortOrderInput | SortOrder
    usuario_cad?: SortOrder
    usuario_alt?: SortOrder
    idfornecedor?: SortOrder
    _relevance?: tiposervicoOrderByRelevanceInput
  }

  export type tiposervicoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tiposervicoWhereInput | tiposervicoWhereInput[]
    OR?: tiposervicoWhereInput[]
    NOT?: tiposervicoWhereInput | tiposervicoWhereInput[]
    descricao?: StringFilter<"tiposervico"> | string
    createdAt?: DateTimeFilter<"tiposervico"> | Date | string
    updatedAt?: DateTimeFilter<"tiposervico"> | Date | string
    valorCusto?: FloatFilter<"tiposervico"> | number
    valorVenda?: FloatFilter<"tiposervico"> | number
    ativo?: BoolFilter<"tiposervico"> | boolean
    observacao?: StringNullableFilter<"tiposervico"> | string | null
    usuario_cad?: IntFilter<"tiposervico"> | number
    usuario_alt?: IntFilter<"tiposervico"> | number
    idfornecedor?: IntFilter<"tiposervico"> | number
  }, "id">

  export type tiposervicoOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    valorCusto?: SortOrder
    valorVenda?: SortOrder
    ativo?: SortOrder
    observacao?: SortOrderInput | SortOrder
    usuario_cad?: SortOrder
    usuario_alt?: SortOrder
    idfornecedor?: SortOrder
    _count?: tiposervicoCountOrderByAggregateInput
    _avg?: tiposervicoAvgOrderByAggregateInput
    _max?: tiposervicoMaxOrderByAggregateInput
    _min?: tiposervicoMinOrderByAggregateInput
    _sum?: tiposervicoSumOrderByAggregateInput
  }

  export type tiposervicoScalarWhereWithAggregatesInput = {
    AND?: tiposervicoScalarWhereWithAggregatesInput | tiposervicoScalarWhereWithAggregatesInput[]
    OR?: tiposervicoScalarWhereWithAggregatesInput[]
    NOT?: tiposervicoScalarWhereWithAggregatesInput | tiposervicoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tiposervico"> | number
    descricao?: StringWithAggregatesFilter<"tiposervico"> | string
    createdAt?: DateTimeWithAggregatesFilter<"tiposervico"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tiposervico"> | Date | string
    valorCusto?: FloatWithAggregatesFilter<"tiposervico"> | number
    valorVenda?: FloatWithAggregatesFilter<"tiposervico"> | number
    ativo?: BoolWithAggregatesFilter<"tiposervico"> | boolean
    observacao?: StringNullableWithAggregatesFilter<"tiposervico"> | string | null
    usuario_cad?: IntWithAggregatesFilter<"tiposervico"> | number
    usuario_alt?: IntWithAggregatesFilter<"tiposervico"> | number
    idfornecedor?: IntWithAggregatesFilter<"tiposervico"> | number
  }

  export type bancosCreateInput = {
    id?: number
    codbanco: number
    instituicao: string
    segmento: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type bancosUncheckedCreateInput = {
    id?: number
    codbanco: number
    instituicao: string
    segmento: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type bancosUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codbanco?: IntFieldUpdateOperationsInput | number
    instituicao?: StringFieldUpdateOperationsInput | string
    segmento?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bancosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codbanco?: IntFieldUpdateOperationsInput | number
    instituicao?: StringFieldUpdateOperationsInput | string
    segmento?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bancosCreateManyInput = {
    id?: number
    codbanco: number
    instituicao: string
    segmento: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type bancosUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    codbanco?: IntFieldUpdateOperationsInput | number
    instituicao?: StringFieldUpdateOperationsInput | string
    segmento?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bancosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codbanco?: IntFieldUpdateOperationsInput | number
    instituicao?: StringFieldUpdateOperationsInput | string
    segmento?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configuracaoCreateInput = {
    descricao: string
    config: JsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type configuracaoUncheckedCreateInput = {
    id?: number
    descricao: string
    config: JsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type configuracaoUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configuracaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configuracaoCreateManyInput = {
    id?: number
    descricao: string
    config: JsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type configuracaoUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type configuracaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consultasCreateInput = {
    datahora?: Date | string
    id_servico: number
    beneficio?: string | null
    cpf?: string | null
    qtde: number
    id_usuario: number
    createdAt: Date | string
    updatedAt: Date | string
    tipotransacao?: number
    observacao?: string | null
    valor_unit?: number
    matricula_siape?: string | null
    tp_serv_origem?: number
    id_extrato_off?: number
    origem_sol?: number
  }

  export type consultasUncheckedCreateInput = {
    id?: number
    datahora?: Date | string
    id_servico: number
    beneficio?: string | null
    cpf?: string | null
    qtde: number
    id_usuario: number
    createdAt: Date | string
    updatedAt: Date | string
    tipotransacao?: number
    observacao?: string | null
    valor_unit?: number
    matricula_siape?: string | null
    tp_serv_origem?: number
    id_extrato_off?: number
    origem_sol?: number
  }

  export type consultasUpdateInput = {
    datahora?: DateTimeFieldUpdateOperationsInput | Date | string
    id_servico?: IntFieldUpdateOperationsInput | number
    beneficio?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    qtde?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tipotransacao?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    valor_unit?: FloatFieldUpdateOperationsInput | number
    matricula_siape?: NullableStringFieldUpdateOperationsInput | string | null
    tp_serv_origem?: IntFieldUpdateOperationsInput | number
    id_extrato_off?: IntFieldUpdateOperationsInput | number
    origem_sol?: IntFieldUpdateOperationsInput | number
  }

  export type consultasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    datahora?: DateTimeFieldUpdateOperationsInput | Date | string
    id_servico?: IntFieldUpdateOperationsInput | number
    beneficio?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    qtde?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tipotransacao?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    valor_unit?: FloatFieldUpdateOperationsInput | number
    matricula_siape?: NullableStringFieldUpdateOperationsInput | string | null
    tp_serv_origem?: IntFieldUpdateOperationsInput | number
    id_extrato_off?: IntFieldUpdateOperationsInput | number
    origem_sol?: IntFieldUpdateOperationsInput | number
  }

  export type consultasCreateManyInput = {
    id?: number
    datahora?: Date | string
    id_servico: number
    beneficio?: string | null
    cpf?: string | null
    qtde: number
    id_usuario: number
    createdAt: Date | string
    updatedAt: Date | string
    tipotransacao?: number
    observacao?: string | null
    valor_unit?: number
    matricula_siape?: string | null
    tp_serv_origem?: number
    id_extrato_off?: number
    origem_sol?: number
  }

  export type consultasUpdateManyMutationInput = {
    datahora?: DateTimeFieldUpdateOperationsInput | Date | string
    id_servico?: IntFieldUpdateOperationsInput | number
    beneficio?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    qtde?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tipotransacao?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    valor_unit?: FloatFieldUpdateOperationsInput | number
    matricula_siape?: NullableStringFieldUpdateOperationsInput | string | null
    tp_serv_origem?: IntFieldUpdateOperationsInput | number
    id_extrato_off?: IntFieldUpdateOperationsInput | number
    origem_sol?: IntFieldUpdateOperationsInput | number
  }

  export type consultasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    datahora?: DateTimeFieldUpdateOperationsInput | Date | string
    id_servico?: IntFieldUpdateOperationsInput | number
    beneficio?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    qtde?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tipotransacao?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    valor_unit?: FloatFieldUpdateOperationsInput | number
    matricula_siape?: NullableStringFieldUpdateOperationsInput | string | null
    tp_serv_origem?: IntFieldUpdateOperationsInput | number
    id_extrato_off?: IntFieldUpdateOperationsInput | number
    origem_sol?: IntFieldUpdateOperationsInput | number
  }

  export type consultasofflineCreateInput = {
    idConsulta: number
    erroID?: string | null
    idStatusSolicitacaoIn100: number
    situacao?: string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type consultasofflineUncheckedCreateInput = {
    id?: number
    idConsulta: number
    erroID?: string | null
    idStatusSolicitacaoIn100: number
    situacao?: string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type consultasofflineUpdateInput = {
    idConsulta?: IntFieldUpdateOperationsInput | number
    erroID?: NullableStringFieldUpdateOperationsInput | string | null
    idStatusSolicitacaoIn100?: IntFieldUpdateOperationsInput | number
    situacao?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consultasofflineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idConsulta?: IntFieldUpdateOperationsInput | number
    erroID?: NullableStringFieldUpdateOperationsInput | string | null
    idStatusSolicitacaoIn100?: IntFieldUpdateOperationsInput | number
    situacao?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consultasofflineCreateManyInput = {
    id?: number
    idConsulta: number
    erroID?: string | null
    idStatusSolicitacaoIn100: number
    situacao?: string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type consultasofflineUpdateManyMutationInput = {
    idConsulta?: IntFieldUpdateOperationsInput | number
    erroID?: NullableStringFieldUpdateOperationsInput | string | null
    idStatusSolicitacaoIn100?: IntFieldUpdateOperationsInput | number
    situacao?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consultasofflineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idConsulta?: IntFieldUpdateOperationsInput | number
    erroID?: NullableStringFieldUpdateOperationsInput | string | null
    idStatusSolicitacaoIn100?: IntFieldUpdateOperationsInput | number
    situacao?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consultasofflinesiapeCreateInput = {
    idConsulta: number
    situacao?: string | null
    erroID?: string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type consultasofflinesiapeUncheckedCreateInput = {
    id?: number
    idConsulta: number
    situacao?: string | null
    erroID?: string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type consultasofflinesiapeUpdateInput = {
    idConsulta?: IntFieldUpdateOperationsInput | number
    situacao?: NullableStringFieldUpdateOperationsInput | string | null
    erroID?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consultasofflinesiapeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idConsulta?: IntFieldUpdateOperationsInput | number
    situacao?: NullableStringFieldUpdateOperationsInput | string | null
    erroID?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consultasofflinesiapeCreateManyInput = {
    id?: number
    idConsulta: number
    situacao?: string | null
    erroID?: string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type consultasofflinesiapeUpdateManyMutationInput = {
    idConsulta?: IntFieldUpdateOperationsInput | number
    situacao?: NullableStringFieldUpdateOperationsInput | string | null
    erroID?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type consultasofflinesiapeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idConsulta?: IntFieldUpdateOperationsInput | number
    situacao?: NullableStringFieldUpdateOperationsInput | string | null
    erroID?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type creditoCreateInput = {
    datahora?: Date | string
    valorun?: number | null
    vendedor: number
    createdAt: Date | string
    updatedAt: Date | string
    idusu_cli: number
    tiposervico: number
    qtdecreditos: number
    qtderestante: number
    qtdeutilizada: number
  }

  export type creditoUncheckedCreateInput = {
    id?: number
    datahora?: Date | string
    valorun?: number | null
    vendedor: number
    createdAt: Date | string
    updatedAt: Date | string
    idusu_cli: number
    tiposervico: number
    qtdecreditos: number
    qtderestante: number
    qtdeutilizada: number
  }

  export type creditoUpdateInput = {
    datahora?: DateTimeFieldUpdateOperationsInput | Date | string
    valorun?: NullableFloatFieldUpdateOperationsInput | number | null
    vendedor?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idusu_cli?: IntFieldUpdateOperationsInput | number
    tiposervico?: IntFieldUpdateOperationsInput | number
    qtdecreditos?: IntFieldUpdateOperationsInput | number
    qtderestante?: IntFieldUpdateOperationsInput | number
    qtdeutilizada?: IntFieldUpdateOperationsInput | number
  }

  export type creditoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    datahora?: DateTimeFieldUpdateOperationsInput | Date | string
    valorun?: NullableFloatFieldUpdateOperationsInput | number | null
    vendedor?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idusu_cli?: IntFieldUpdateOperationsInput | number
    tiposervico?: IntFieldUpdateOperationsInput | number
    qtdecreditos?: IntFieldUpdateOperationsInput | number
    qtderestante?: IntFieldUpdateOperationsInput | number
    qtdeutilizada?: IntFieldUpdateOperationsInput | number
  }

  export type creditoCreateManyInput = {
    id?: number
    datahora?: Date | string
    valorun?: number | null
    vendedor: number
    createdAt: Date | string
    updatedAt: Date | string
    idusu_cli: number
    tiposervico: number
    qtdecreditos: number
    qtderestante: number
    qtdeutilizada: number
  }

  export type creditoUpdateManyMutationInput = {
    datahora?: DateTimeFieldUpdateOperationsInput | Date | string
    valorun?: NullableFloatFieldUpdateOperationsInput | number | null
    vendedor?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idusu_cli?: IntFieldUpdateOperationsInput | number
    tiposervico?: IntFieldUpdateOperationsInput | number
    qtdecreditos?: IntFieldUpdateOperationsInput | number
    qtderestante?: IntFieldUpdateOperationsInput | number
    qtdeutilizada?: IntFieldUpdateOperationsInput | number
  }

  export type creditoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    datahora?: DateTimeFieldUpdateOperationsInput | Date | string
    valorun?: NullableFloatFieldUpdateOperationsInput | number | null
    vendedor?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idusu_cli?: IntFieldUpdateOperationsInput | number
    tiposervico?: IntFieldUpdateOperationsInput | number
    qtdecreditos?: IntFieldUpdateOperationsInput | number
    qtderestante?: IntFieldUpdateOperationsInput | number
    qtdeutilizada?: IntFieldUpdateOperationsInput | number
  }

  export type desbloqueiosCreateInput = {
    datahora?: Date | string
    beneficio: string
    cpf: string
    protocolo?: string | null
    requerente?: string | null
    unidade?: string | null
    status?: number
    id_usuario: number
    createdAt: Date | string
    updatedAt: Date | string
    id_usu_desbloqueio?: number
    ddb?: string | null
  }

  export type desbloqueiosUncheckedCreateInput = {
    id?: number
    datahora?: Date | string
    beneficio: string
    cpf: string
    protocolo?: string | null
    requerente?: string | null
    unidade?: string | null
    status?: number
    id_usuario: number
    createdAt: Date | string
    updatedAt: Date | string
    id_usu_desbloqueio?: number
    ddb?: string | null
  }

  export type desbloqueiosUpdateInput = {
    datahora?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficio?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    requerente?: NullableStringFieldUpdateOperationsInput | string | null
    unidade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_usu_desbloqueio?: IntFieldUpdateOperationsInput | number
    ddb?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type desbloqueiosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    datahora?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficio?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    requerente?: NullableStringFieldUpdateOperationsInput | string | null
    unidade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_usu_desbloqueio?: IntFieldUpdateOperationsInput | number
    ddb?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type desbloqueiosCreateManyInput = {
    id?: number
    datahora?: Date | string
    beneficio: string
    cpf: string
    protocolo?: string | null
    requerente?: string | null
    unidade?: string | null
    status?: number
    id_usuario: number
    createdAt: Date | string
    updatedAt: Date | string
    id_usu_desbloqueio?: number
    ddb?: string | null
  }

  export type desbloqueiosUpdateManyMutationInput = {
    datahora?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficio?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    requerente?: NullableStringFieldUpdateOperationsInput | string | null
    unidade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_usu_desbloqueio?: IntFieldUpdateOperationsInput | number
    ddb?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type desbloqueiosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    datahora?: DateTimeFieldUpdateOperationsInput | Date | string
    beneficio?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    protocolo?: NullableStringFieldUpdateOperationsInput | string | null
    requerente?: NullableStringFieldUpdateOperationsInput | string | null
    unidade?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id_usu_desbloqueio?: IntFieldUpdateOperationsInput | number
    ddb?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type entrantesinssCreateInput = {
    cpf?: string | null
    nome?: string | null
    nascimento?: Date | string | null
    idade?: number | null
    beneficio?: number | null
    especie?: number | null
    salario?: number | null
    dib?: Date | string | null
    cidade?: string | null
    uf?: string | null
    bairro?: string | null
    cep?: string | null
    fone?: string | null
    fone1?: string | null
    fone2?: string | null
    fone3?: string | null
    fone4?: string | null
    fone5?: string | null
    fone6?: string | null
    fone7?: string | null
    fone8?: string | null
    fone9?: string | null
    email?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type entrantesinssUncheckedCreateInput = {
    id?: number
    cpf?: string | null
    nome?: string | null
    nascimento?: Date | string | null
    idade?: number | null
    beneficio?: number | null
    especie?: number | null
    salario?: number | null
    dib?: Date | string | null
    cidade?: string | null
    uf?: string | null
    bairro?: string | null
    cep?: string | null
    fone?: string | null
    fone1?: string | null
    fone2?: string | null
    fone3?: string | null
    fone4?: string | null
    fone5?: string | null
    fone6?: string | null
    fone7?: string | null
    fone8?: string | null
    fone9?: string | null
    email?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type entrantesinssUpdateInput = {
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idade?: NullableIntFieldUpdateOperationsInput | number | null
    beneficio?: NullableIntFieldUpdateOperationsInput | number | null
    especie?: NullableIntFieldUpdateOperationsInput | number | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    dib?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    fone?: NullableStringFieldUpdateOperationsInput | string | null
    fone1?: NullableStringFieldUpdateOperationsInput | string | null
    fone2?: NullableStringFieldUpdateOperationsInput | string | null
    fone3?: NullableStringFieldUpdateOperationsInput | string | null
    fone4?: NullableStringFieldUpdateOperationsInput | string | null
    fone5?: NullableStringFieldUpdateOperationsInput | string | null
    fone6?: NullableStringFieldUpdateOperationsInput | string | null
    fone7?: NullableStringFieldUpdateOperationsInput | string | null
    fone8?: NullableStringFieldUpdateOperationsInput | string | null
    fone9?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type entrantesinssUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idade?: NullableIntFieldUpdateOperationsInput | number | null
    beneficio?: NullableIntFieldUpdateOperationsInput | number | null
    especie?: NullableIntFieldUpdateOperationsInput | number | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    dib?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    fone?: NullableStringFieldUpdateOperationsInput | string | null
    fone1?: NullableStringFieldUpdateOperationsInput | string | null
    fone2?: NullableStringFieldUpdateOperationsInput | string | null
    fone3?: NullableStringFieldUpdateOperationsInput | string | null
    fone4?: NullableStringFieldUpdateOperationsInput | string | null
    fone5?: NullableStringFieldUpdateOperationsInput | string | null
    fone6?: NullableStringFieldUpdateOperationsInput | string | null
    fone7?: NullableStringFieldUpdateOperationsInput | string | null
    fone8?: NullableStringFieldUpdateOperationsInput | string | null
    fone9?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type entrantesinssCreateManyInput = {
    id?: number
    cpf?: string | null
    nome?: string | null
    nascimento?: Date | string | null
    idade?: number | null
    beneficio?: number | null
    especie?: number | null
    salario?: number | null
    dib?: Date | string | null
    cidade?: string | null
    uf?: string | null
    bairro?: string | null
    cep?: string | null
    fone?: string | null
    fone1?: string | null
    fone2?: string | null
    fone3?: string | null
    fone4?: string | null
    fone5?: string | null
    fone6?: string | null
    fone7?: string | null
    fone8?: string | null
    fone9?: string | null
    email?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type entrantesinssUpdateManyMutationInput = {
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idade?: NullableIntFieldUpdateOperationsInput | number | null
    beneficio?: NullableIntFieldUpdateOperationsInput | number | null
    especie?: NullableIntFieldUpdateOperationsInput | number | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    dib?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    fone?: NullableStringFieldUpdateOperationsInput | string | null
    fone1?: NullableStringFieldUpdateOperationsInput | string | null
    fone2?: NullableStringFieldUpdateOperationsInput | string | null
    fone3?: NullableStringFieldUpdateOperationsInput | string | null
    fone4?: NullableStringFieldUpdateOperationsInput | string | null
    fone5?: NullableStringFieldUpdateOperationsInput | string | null
    fone6?: NullableStringFieldUpdateOperationsInput | string | null
    fone7?: NullableStringFieldUpdateOperationsInput | string | null
    fone8?: NullableStringFieldUpdateOperationsInput | string | null
    fone9?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type entrantesinssUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idade?: NullableIntFieldUpdateOperationsInput | number | null
    beneficio?: NullableIntFieldUpdateOperationsInput | number | null
    especie?: NullableIntFieldUpdateOperationsInput | number | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    dib?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    fone?: NullableStringFieldUpdateOperationsInput | string | null
    fone1?: NullableStringFieldUpdateOperationsInput | string | null
    fone2?: NullableStringFieldUpdateOperationsInput | string | null
    fone3?: NullableStringFieldUpdateOperationsInput | string | null
    fone4?: NullableStringFieldUpdateOperationsInput | string | null
    fone5?: NullableStringFieldUpdateOperationsInput | string | null
    fone6?: NullableStringFieldUpdateOperationsInput | string | null
    fone7?: NullableStringFieldUpdateOperationsInput | string | null
    fone8?: NullableStringFieldUpdateOperationsInput | string | null
    fone9?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type especiebeneficioCreateInput = {
    id?: number
    codigo: number
    descEspecieBeneficio: string
    gruposEspecie: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type especiebeneficioUncheckedCreateInput = {
    id?: number
    codigo: number
    descEspecieBeneficio: string
    gruposEspecie: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type especiebeneficioUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: IntFieldUpdateOperationsInput | number
    descEspecieBeneficio?: StringFieldUpdateOperationsInput | string
    gruposEspecie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type especiebeneficioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: IntFieldUpdateOperationsInput | number
    descEspecieBeneficio?: StringFieldUpdateOperationsInput | string
    gruposEspecie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type especiebeneficioCreateManyInput = {
    id?: number
    codigo: number
    descEspecieBeneficio: string
    gruposEspecie: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type especiebeneficioUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: IntFieldUpdateOperationsInput | number
    descEspecieBeneficio?: StringFieldUpdateOperationsInput | string
    gruposEspecie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type especiebeneficioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: IntFieldUpdateOperationsInput | number
    descEspecieBeneficio?: StringFieldUpdateOperationsInput | string
    gruposEspecie?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type extratoofflineCreateInput = {
    cpf?: string | null
    beneficio?: string | null
    jsonResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    idFornecedor: number
    idConsulta: number
    idUsuario: number
  }

  export type extratoofflineUncheckedCreateInput = {
    id?: number
    cpf?: string | null
    beneficio?: string | null
    jsonResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    idFornecedor: number
    idConsulta: number
    idUsuario: number
  }

  export type extratoofflineUpdateInput = {
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    beneficio?: NullableStringFieldUpdateOperationsInput | string | null
    jsonResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idFornecedor?: IntFieldUpdateOperationsInput | number
    idConsulta?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
  }

  export type extratoofflineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    beneficio?: NullableStringFieldUpdateOperationsInput | string | null
    jsonResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idFornecedor?: IntFieldUpdateOperationsInput | number
    idConsulta?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
  }

  export type extratoofflineCreateManyInput = {
    id?: number
    cpf?: string | null
    beneficio?: string | null
    jsonResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    idFornecedor: number
    idConsulta: number
    idUsuario: number
  }

  export type extratoofflineUpdateManyMutationInput = {
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    beneficio?: NullableStringFieldUpdateOperationsInput | string | null
    jsonResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idFornecedor?: IntFieldUpdateOperationsInput | number
    idConsulta?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
  }

  export type extratoofflineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    beneficio?: NullableStringFieldUpdateOperationsInput | string | null
    jsonResult?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idFornecedor?: IntFieldUpdateOperationsInput | number
    idConsulta?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
  }

  export type extratoonlineCreateInput = {
    idConsulta: number
    id_fornecedor: number
    beneficio: string
    jsonResult?: NullableJsonNullValueInput | InputJsonValue
    filePdf?: Uint8Array | null
    createdAt: Date | string
    updatedAt: Date | string
    isCache?: boolean | null
    statusConsulta?: number | null
    idConsultaOffline?: number
    errorResult?: string | null
    idUsuario: number
  }

  export type extratoonlineUncheckedCreateInput = {
    id?: number
    idConsulta: number
    id_fornecedor: number
    beneficio: string
    jsonResult?: NullableJsonNullValueInput | InputJsonValue
    filePdf?: Uint8Array | null
    createdAt: Date | string
    updatedAt: Date | string
    isCache?: boolean | null
    statusConsulta?: number | null
    idConsultaOffline?: number
    errorResult?: string | null
    idUsuario: number
  }

  export type extratoonlineUpdateInput = {
    idConsulta?: IntFieldUpdateOperationsInput | number
    id_fornecedor?: IntFieldUpdateOperationsInput | number
    beneficio?: StringFieldUpdateOperationsInput | string
    jsonResult?: NullableJsonNullValueInput | InputJsonValue
    filePdf?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCache?: NullableBoolFieldUpdateOperationsInput | boolean | null
    statusConsulta?: NullableIntFieldUpdateOperationsInput | number | null
    idConsultaOffline?: IntFieldUpdateOperationsInput | number
    errorResult?: NullableStringFieldUpdateOperationsInput | string | null
    idUsuario?: IntFieldUpdateOperationsInput | number
  }

  export type extratoonlineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idConsulta?: IntFieldUpdateOperationsInput | number
    id_fornecedor?: IntFieldUpdateOperationsInput | number
    beneficio?: StringFieldUpdateOperationsInput | string
    jsonResult?: NullableJsonNullValueInput | InputJsonValue
    filePdf?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCache?: NullableBoolFieldUpdateOperationsInput | boolean | null
    statusConsulta?: NullableIntFieldUpdateOperationsInput | number | null
    idConsultaOffline?: IntFieldUpdateOperationsInput | number
    errorResult?: NullableStringFieldUpdateOperationsInput | string | null
    idUsuario?: IntFieldUpdateOperationsInput | number
  }

  export type extratoonlineCreateManyInput = {
    id?: number
    idConsulta: number
    id_fornecedor: number
    beneficio: string
    jsonResult?: NullableJsonNullValueInput | InputJsonValue
    filePdf?: Uint8Array | null
    createdAt: Date | string
    updatedAt: Date | string
    isCache?: boolean | null
    statusConsulta?: number | null
    idConsultaOffline?: number
    errorResult?: string | null
    idUsuario: number
  }

  export type extratoonlineUpdateManyMutationInput = {
    idConsulta?: IntFieldUpdateOperationsInput | number
    id_fornecedor?: IntFieldUpdateOperationsInput | number
    beneficio?: StringFieldUpdateOperationsInput | string
    jsonResult?: NullableJsonNullValueInput | InputJsonValue
    filePdf?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCache?: NullableBoolFieldUpdateOperationsInput | boolean | null
    statusConsulta?: NullableIntFieldUpdateOperationsInput | number | null
    idConsultaOffline?: IntFieldUpdateOperationsInput | number
    errorResult?: NullableStringFieldUpdateOperationsInput | string | null
    idUsuario?: IntFieldUpdateOperationsInput | number
  }

  export type extratoonlineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idConsulta?: IntFieldUpdateOperationsInput | number
    id_fornecedor?: IntFieldUpdateOperationsInput | number
    beneficio?: StringFieldUpdateOperationsInput | string
    jsonResult?: NullableJsonNullValueInput | InputJsonValue
    filePdf?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCache?: NullableBoolFieldUpdateOperationsInput | boolean | null
    statusConsulta?: NullableIntFieldUpdateOperationsInput | number | null
    idConsultaOffline?: IntFieldUpdateOperationsInput | number
    errorResult?: NullableStringFieldUpdateOperationsInput | string | null
    idUsuario?: IntFieldUpdateOperationsInput | number
  }

  export type fornecedorCreateInput = {
    descricao: string
    cnpj?: string | null
    logradouro?: string | null
    numero?: number | null
    complemento?: string | null
    cep?: string | null
    cidade?: string | null
    estado?: string | null
    apikey?: string | null
    ativo?: boolean
    createdAt: Date | string
    updatedAt: Date | string
    urlapi?: string | null
    usuarioApi?: string | null
    senhaApi?: string | null
    dataHoraValidacaoApiKey?: Date | string | null
  }

  export type fornecedorUncheckedCreateInput = {
    id?: number
    descricao: string
    cnpj?: string | null
    logradouro?: string | null
    numero?: number | null
    complemento?: string | null
    cep?: string | null
    cidade?: string | null
    estado?: string | null
    apikey?: string | null
    ativo?: boolean
    createdAt: Date | string
    updatedAt: Date | string
    urlapi?: string | null
    usuarioApi?: string | null
    senhaApi?: string | null
    dataHoraValidacaoApiKey?: Date | string | null
  }

  export type fornecedorUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableIntFieldUpdateOperationsInput | number | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    apikey?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    urlapi?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioApi?: NullableStringFieldUpdateOperationsInput | string | null
    senhaApi?: NullableStringFieldUpdateOperationsInput | string | null
    dataHoraValidacaoApiKey?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type fornecedorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableIntFieldUpdateOperationsInput | number | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    apikey?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    urlapi?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioApi?: NullableStringFieldUpdateOperationsInput | string | null
    senhaApi?: NullableStringFieldUpdateOperationsInput | string | null
    dataHoraValidacaoApiKey?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type fornecedorCreateManyInput = {
    id?: number
    descricao: string
    cnpj?: string | null
    logradouro?: string | null
    numero?: number | null
    complemento?: string | null
    cep?: string | null
    cidade?: string | null
    estado?: string | null
    apikey?: string | null
    ativo?: boolean
    createdAt: Date | string
    updatedAt: Date | string
    urlapi?: string | null
    usuarioApi?: string | null
    senhaApi?: string | null
    dataHoraValidacaoApiKey?: Date | string | null
  }

  export type fornecedorUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableIntFieldUpdateOperationsInput | number | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    apikey?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    urlapi?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioApi?: NullableStringFieldUpdateOperationsInput | string | null
    senhaApi?: NullableStringFieldUpdateOperationsInput | string | null
    dataHoraValidacaoApiKey?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type fornecedorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    logradouro?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableIntFieldUpdateOperationsInput | number | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    apikey?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    urlapi?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioApi?: NullableStringFieldUpdateOperationsInput | string | null
    senhaApi?: NullableStringFieldUpdateOperationsInput | string | null
    dataHoraValidacaoApiKey?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type fornecedorservicoCreateInput = {
    idServico: number
    idFornecedor: number
    ativo?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type fornecedorservicoUncheckedCreateInput = {
    id?: number
    idServico: number
    idFornecedor: number
    ativo?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type fornecedorservicoUpdateInput = {
    idServico?: IntFieldUpdateOperationsInput | number
    idFornecedor?: IntFieldUpdateOperationsInput | number
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fornecedorservicoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idServico?: IntFieldUpdateOperationsInput | number
    idFornecedor?: IntFieldUpdateOperationsInput | number
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fornecedorservicoCreateManyInput = {
    id?: number
    idServico: number
    idFornecedor: number
    ativo?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type fornecedorservicoUpdateManyMutationInput = {
    idServico?: IntFieldUpdateOperationsInput | number
    idFornecedor?: IntFieldUpdateOperationsInput | number
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fornecedorservicoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idServico?: IntFieldUpdateOperationsInput | number
    idFornecedor?: IntFieldUpdateOperationsInput | number
    ativo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historicoconsultaapiCreateInput = {
    idservico: number
    idfornecedor: number
    cpf?: string | null
    cpfRepresentanteLegal?: string | null
    beneficio?: string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    statusConsulta?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type historicoconsultaapiUncheckedCreateInput = {
    id?: number
    idservico: number
    idfornecedor: number
    cpf?: string | null
    cpfRepresentanteLegal?: string | null
    beneficio?: string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    statusConsulta?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type historicoconsultaapiUpdateInput = {
    idservico?: IntFieldUpdateOperationsInput | number
    idfornecedor?: IntFieldUpdateOperationsInput | number
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    cpfRepresentanteLegal?: NullableStringFieldUpdateOperationsInput | string | null
    beneficio?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    statusConsulta?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historicoconsultaapiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idservico?: IntFieldUpdateOperationsInput | number
    idfornecedor?: IntFieldUpdateOperationsInput | number
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    cpfRepresentanteLegal?: NullableStringFieldUpdateOperationsInput | string | null
    beneficio?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    statusConsulta?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historicoconsultaapiCreateManyInput = {
    id?: number
    idservico: number
    idfornecedor: number
    cpf?: string | null
    cpfRepresentanteLegal?: string | null
    beneficio?: string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    statusConsulta?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type historicoconsultaapiUpdateManyMutationInput = {
    idservico?: IntFieldUpdateOperationsInput | number
    idfornecedor?: IntFieldUpdateOperationsInput | number
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    cpfRepresentanteLegal?: NullableStringFieldUpdateOperationsInput | string | null
    beneficio?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    statusConsulta?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historicoconsultaapiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idservico?: IntFieldUpdateOperationsInput | number
    idfornecedor?: IntFieldUpdateOperationsInput | number
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    cpfRepresentanteLegal?: NullableStringFieldUpdateOperationsInput | string | null
    beneficio?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    statusConsulta?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type historicocreditoCreateInput = {
    clienteId: number
    tipoOperacao: number
    quantidade: number
    createdAt: Date | string
    idServico: number
  }

  export type historicocreditoUncheckedCreateInput = {
    id?: number
    clienteId: number
    tipoOperacao: number
    quantidade: number
    createdAt: Date | string
    idServico: number
  }

  export type historicocreditoUpdateInput = {
    clienteId?: IntFieldUpdateOperationsInput | number
    tipoOperacao?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idServico?: IntFieldUpdateOperationsInput | number
  }

  export type historicocreditoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    tipoOperacao?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idServico?: IntFieldUpdateOperationsInput | number
  }

  export type historicocreditoCreateManyInput = {
    id?: number
    clienteId: number
    tipoOperacao: number
    quantidade: number
    createdAt: Date | string
    idServico: number
  }

  export type historicocreditoUpdateManyMutationInput = {
    clienteId?: IntFieldUpdateOperationsInput | number
    tipoOperacao?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idServico?: IntFieldUpdateOperationsInput | number
  }

  export type historicocreditoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clienteId?: IntFieldUpdateOperationsInput | number
    tipoOperacao?: IntFieldUpdateOperationsInput | number
    quantidade?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idServico?: IntFieldUpdateOperationsInput | number
  }

  export type in100CreateInput = {
    idUsuario: number
    idConsulta: number
    idConsultaOffline: number
    cpf: string
    numeroBeneficio?: string | null
    situacao?: string | null
    requisicao?: bigint | number | null
    errorID?: string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    cpfRepresentanteLegal?: string | null
    idFornecedor: number
    idStatusSolicitacaoIn100: number
    msgErro?: string | null
  }

  export type in100UncheckedCreateInput = {
    id?: number
    idUsuario: number
    idConsulta: number
    idConsultaOffline: number
    cpf: string
    numeroBeneficio?: string | null
    situacao?: string | null
    requisicao?: bigint | number | null
    errorID?: string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    cpfRepresentanteLegal?: string | null
    idFornecedor: number
    idStatusSolicitacaoIn100: number
    msgErro?: string | null
  }

  export type in100UpdateInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    idConsulta?: IntFieldUpdateOperationsInput | number
    idConsultaOffline?: IntFieldUpdateOperationsInput | number
    cpf?: StringFieldUpdateOperationsInput | string
    numeroBeneficio?: NullableStringFieldUpdateOperationsInput | string | null
    situacao?: NullableStringFieldUpdateOperationsInput | string | null
    requisicao?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    errorID?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpfRepresentanteLegal?: NullableStringFieldUpdateOperationsInput | string | null
    idFornecedor?: IntFieldUpdateOperationsInput | number
    idStatusSolicitacaoIn100?: IntFieldUpdateOperationsInput | number
    msgErro?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type in100UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    idConsulta?: IntFieldUpdateOperationsInput | number
    idConsultaOffline?: IntFieldUpdateOperationsInput | number
    cpf?: StringFieldUpdateOperationsInput | string
    numeroBeneficio?: NullableStringFieldUpdateOperationsInput | string | null
    situacao?: NullableStringFieldUpdateOperationsInput | string | null
    requisicao?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    errorID?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpfRepresentanteLegal?: NullableStringFieldUpdateOperationsInput | string | null
    idFornecedor?: IntFieldUpdateOperationsInput | number
    idStatusSolicitacaoIn100?: IntFieldUpdateOperationsInput | number
    msgErro?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type in100CreateManyInput = {
    id?: number
    idUsuario: number
    idConsulta: number
    idConsultaOffline: number
    cpf: string
    numeroBeneficio?: string | null
    situacao?: string | null
    requisicao?: bigint | number | null
    errorID?: string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    cpfRepresentanteLegal?: string | null
    idFornecedor: number
    idStatusSolicitacaoIn100: number
    msgErro?: string | null
  }

  export type in100UpdateManyMutationInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    idConsulta?: IntFieldUpdateOperationsInput | number
    idConsultaOffline?: IntFieldUpdateOperationsInput | number
    cpf?: StringFieldUpdateOperationsInput | string
    numeroBeneficio?: NullableStringFieldUpdateOperationsInput | string | null
    situacao?: NullableStringFieldUpdateOperationsInput | string | null
    requisicao?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    errorID?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpfRepresentanteLegal?: NullableStringFieldUpdateOperationsInput | string | null
    idFornecedor?: IntFieldUpdateOperationsInput | number
    idStatusSolicitacaoIn100?: IntFieldUpdateOperationsInput | number
    msgErro?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type in100UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    idConsulta?: IntFieldUpdateOperationsInput | number
    idConsultaOffline?: IntFieldUpdateOperationsInput | number
    cpf?: StringFieldUpdateOperationsInput | string
    numeroBeneficio?: NullableStringFieldUpdateOperationsInput | string | null
    situacao?: NullableStringFieldUpdateOperationsInput | string | null
    requisicao?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    errorID?: NullableStringFieldUpdateOperationsInput | string | null
    resultado?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpfRepresentanteLegal?: NullableStringFieldUpdateOperationsInput | string | null
    idFornecedor?: IntFieldUpdateOperationsInput | number
    idStatusSolicitacaoIn100?: IntFieldUpdateOperationsInput | number
    msgErro?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type loginsCreateInput = {
    name: string
    user_name: string
    active: boolean
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cpf: string
    email: string
    telefone: string
    usuarioAPi: boolean
    chaveApi: string
    perfil: perfilusuarioCreateNestedOneWithoutLoginsInput
  }

  export type loginsUncheckedCreateInput = {
    id?: number
    name: string
    user_name: string
    active: boolean
    password: string
    idperfil: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cpf: string
    email: string
    telefone: string
    usuarioAPi: boolean
    chaveApi: string
  }

  export type loginsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    usuarioAPi?: BoolFieldUpdateOperationsInput | boolean
    chaveApi?: StringFieldUpdateOperationsInput | string
    perfil?: perfilusuarioUpdateOneRequiredWithoutLoginsNestedInput
  }

  export type loginsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    idperfil?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    usuarioAPi?: BoolFieldUpdateOperationsInput | boolean
    chaveApi?: StringFieldUpdateOperationsInput | string
  }

  export type loginsCreateManyInput = {
    id?: number
    name: string
    user_name: string
    active: boolean
    password: string
    idperfil: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cpf: string
    email: string
    telefone: string
    usuarioAPi: boolean
    chaveApi: string
  }

  export type loginsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    usuarioAPi?: BoolFieldUpdateOperationsInput | boolean
    chaveApi?: StringFieldUpdateOperationsInput | string
  }

  export type loginsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    idperfil?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    usuarioAPi?: BoolFieldUpdateOperationsInput | boolean
    chaveApi?: StringFieldUpdateOperationsInput | string
  }

  export type menuCreateInput = {
    codsequencia: number
    descricao: string
    pagina: string
    rota: string
    idmodulo: number
    createdAt: Date | string
    updatedAt: Date | string
    icone?: string | null
  }

  export type menuUncheckedCreateInput = {
    id?: number
    codsequencia: number
    descricao: string
    pagina: string
    rota: string
    idmodulo: number
    createdAt: Date | string
    updatedAt: Date | string
    icone?: string | null
  }

  export type menuUpdateInput = {
    codsequencia?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    pagina?: StringFieldUpdateOperationsInput | string
    rota?: StringFieldUpdateOperationsInput | string
    idmodulo?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type menuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codsequencia?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    pagina?: StringFieldUpdateOperationsInput | string
    rota?: StringFieldUpdateOperationsInput | string
    idmodulo?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type menuCreateManyInput = {
    id?: number
    codsequencia: number
    descricao: string
    pagina: string
    rota: string
    idmodulo: number
    createdAt: Date | string
    updatedAt: Date | string
    icone?: string | null
  }

  export type menuUpdateManyMutationInput = {
    codsequencia?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    pagina?: StringFieldUpdateOperationsInput | string
    rota?: StringFieldUpdateOperationsInput | string
    idmodulo?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type menuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codsequencia?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    pagina?: StringFieldUpdateOperationsInput | string
    rota?: StringFieldUpdateOperationsInput | string
    idmodulo?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type modulosCreateInput = {
    desc_modulo: string
    createdAt: Date | string
    updatedAt: Date | string
    perfilXmodulos?: perfil_moduloCreateNestedManyWithoutModuloInput
  }

  export type modulosUncheckedCreateInput = {
    id?: number
    desc_modulo: string
    createdAt: Date | string
    updatedAt: Date | string
    perfilXmodulos?: perfil_moduloUncheckedCreateNestedManyWithoutModuloInput
  }

  export type modulosUpdateInput = {
    desc_modulo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perfilXmodulos?: perfil_moduloUpdateManyWithoutModuloNestedInput
  }

  export type modulosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    desc_modulo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perfilXmodulos?: perfil_moduloUncheckedUpdateManyWithoutModuloNestedInput
  }

  export type modulosCreateManyInput = {
    id?: number
    desc_modulo: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type modulosUpdateManyMutationInput = {
    desc_modulo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type modulosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    desc_modulo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type perfil_moduloCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    perfil: perfilusuarioCreateNestedOneWithoutPerfilXmodulosInput
    modulo: modulosCreateNestedOneWithoutPerfilXmodulosInput
  }

  export type perfil_moduloUncheckedCreateInput = {
    id?: number
    idperfil: number
    idmodulo: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type perfil_moduloUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perfil?: perfilusuarioUpdateOneRequiredWithoutPerfilXmodulosNestedInput
    modulo?: modulosUpdateOneRequiredWithoutPerfilXmodulosNestedInput
  }

  export type perfil_moduloUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idperfil?: IntFieldUpdateOperationsInput | number
    idmodulo?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type perfil_moduloCreateManyInput = {
    id?: number
    idperfil: number
    idmodulo: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type perfil_moduloUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type perfil_moduloUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idperfil?: IntFieldUpdateOperationsInput | number
    idmodulo?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type perfilusuarioCreateInput = {
    descricao: string
    logins?: loginsCreateNestedManyWithoutPerfilInput
    perfilXmodulos?: perfil_moduloCreateNestedManyWithoutPerfilInput
  }

  export type perfilusuarioUncheckedCreateInput = {
    id?: number
    descricao: string
    logins?: loginsUncheckedCreateNestedManyWithoutPerfilInput
    perfilXmodulos?: perfil_moduloUncheckedCreateNestedManyWithoutPerfilInput
  }

  export type perfilusuarioUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    logins?: loginsUpdateManyWithoutPerfilNestedInput
    perfilXmodulos?: perfil_moduloUpdateManyWithoutPerfilNestedInput
  }

  export type perfilusuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    logins?: loginsUncheckedUpdateManyWithoutPerfilNestedInput
    perfilXmodulos?: perfil_moduloUncheckedUpdateManyWithoutPerfilNestedInput
  }

  export type perfilusuarioCreateManyInput = {
    id?: number
    descricao: string
  }

  export type perfilusuarioUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type perfilusuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type senhasCreateInput = {
    idusuario: number
    senha?: string | null
    idretorno?: number | null
    observacao?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cpf: string
    idusuario_atualizacao?: number | null
  }

  export type senhasUncheckedCreateInput = {
    id?: number
    idusuario: number
    senha?: string | null
    idretorno?: number | null
    observacao?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cpf: string
    idusuario_atualizacao?: number | null
  }

  export type senhasUpdateInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    senha?: NullableStringFieldUpdateOperationsInput | string | null
    idretorno?: NullableIntFieldUpdateOperationsInput | number | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf?: StringFieldUpdateOperationsInput | string
    idusuario_atualizacao?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type senhasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idusuario?: IntFieldUpdateOperationsInput | number
    senha?: NullableStringFieldUpdateOperationsInput | string | null
    idretorno?: NullableIntFieldUpdateOperationsInput | number | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf?: StringFieldUpdateOperationsInput | string
    idusuario_atualizacao?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type senhasCreateManyInput = {
    id?: number
    idusuario: number
    senha?: string | null
    idretorno?: number | null
    observacao?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    cpf: string
    idusuario_atualizacao?: number | null
  }

  export type senhasUpdateManyMutationInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    senha?: NullableStringFieldUpdateOperationsInput | string | null
    idretorno?: NullableIntFieldUpdateOperationsInput | number | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf?: StringFieldUpdateOperationsInput | string
    idusuario_atualizacao?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type senhasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idusuario?: IntFieldUpdateOperationsInput | number
    senha?: NullableStringFieldUpdateOperationsInput | string | null
    idretorno?: NullableIntFieldUpdateOperationsInput | number | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf?: StringFieldUpdateOperationsInput | string
    idusuario_atualizacao?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type situacaoCreateInput = {
    descricao: string
    icone?: string | null
    cor?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    formsolicitar: boolean
  }

  export type situacaoUncheckedCreateInput = {
    id?: number
    descricao: string
    icone?: string | null
    cor?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    formsolicitar: boolean
  }

  export type situacaoUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    icone?: NullableStringFieldUpdateOperationsInput | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formsolicitar?: BoolFieldUpdateOperationsInput | boolean
  }

  export type situacaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    icone?: NullableStringFieldUpdateOperationsInput | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formsolicitar?: BoolFieldUpdateOperationsInput | boolean
  }

  export type situacaoCreateManyInput = {
    id?: number
    descricao: string
    icone?: string | null
    cor?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    formsolicitar: boolean
  }

  export type situacaoUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    icone?: NullableStringFieldUpdateOperationsInput | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formsolicitar?: BoolFieldUpdateOperationsInput | boolean
  }

  export type situacaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    icone?: NullableStringFieldUpdateOperationsInput | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formsolicitar?: BoolFieldUpdateOperationsInput | boolean
  }

  export type situacaosolicsenhaCreateInput = {
    descricao: string
    createdAt: Date | string
    updatedAt: Date | string
    telaSolicitar?: boolean
    telaAtualizar?: boolean
  }

  export type situacaosolicsenhaUncheckedCreateInput = {
    id?: number
    descricao: string
    createdAt: Date | string
    updatedAt: Date | string
    telaSolicitar?: boolean
    telaAtualizar?: boolean
  }

  export type situacaosolicsenhaUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telaSolicitar?: BoolFieldUpdateOperationsInput | boolean
    telaAtualizar?: BoolFieldUpdateOperationsInput | boolean
  }

  export type situacaosolicsenhaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telaSolicitar?: BoolFieldUpdateOperationsInput | boolean
    telaAtualizar?: BoolFieldUpdateOperationsInput | boolean
  }

  export type situacaosolicsenhaCreateManyInput = {
    id?: number
    descricao: string
    createdAt: Date | string
    updatedAt: Date | string
    telaSolicitar?: boolean
    telaAtualizar?: boolean
  }

  export type situacaosolicsenhaUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telaSolicitar?: BoolFieldUpdateOperationsInput | boolean
    telaAtualizar?: BoolFieldUpdateOperationsInput | boolean
  }

  export type situacaosolicsenhaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    telaSolicitar?: BoolFieldUpdateOperationsInput | boolean
    telaAtualizar?: BoolFieldUpdateOperationsInput | boolean
  }

  export type statussolicitacaoservicoCreateInput = {
    codigo: number
    descricao: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type statussolicitacaoservicoUncheckedCreateInput = {
    id?: number
    codigo: number
    descricao: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type statussolicitacaoservicoUpdateInput = {
    codigo?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type statussolicitacaoservicoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type statussolicitacaoservicoCreateManyInput = {
    id?: number
    codigo: number
    descricao: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type statussolicitacaoservicoUpdateManyMutationInput = {
    codigo?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type statussolicitacaoservicoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tiposervicoCreateInput = {
    descricao: string
    createdAt: Date | string
    updatedAt: Date | string
    valorCusto?: number
    valorVenda?: number
    ativo?: boolean
    observacao?: string | null
    usuario_cad?: number
    usuario_alt?: number
    idfornecedor?: number
  }

  export type tiposervicoUncheckedCreateInput = {
    id?: number
    descricao: string
    createdAt: Date | string
    updatedAt: Date | string
    valorCusto?: number
    valorVenda?: number
    ativo?: boolean
    observacao?: string | null
    usuario_cad?: number
    usuario_alt?: number
    idfornecedor?: number
  }

  export type tiposervicoUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    valorCusto?: FloatFieldUpdateOperationsInput | number
    valorVenda?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    usuario_cad?: IntFieldUpdateOperationsInput | number
    usuario_alt?: IntFieldUpdateOperationsInput | number
    idfornecedor?: IntFieldUpdateOperationsInput | number
  }

  export type tiposervicoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    valorCusto?: FloatFieldUpdateOperationsInput | number
    valorVenda?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    usuario_cad?: IntFieldUpdateOperationsInput | number
    usuario_alt?: IntFieldUpdateOperationsInput | number
    idfornecedor?: IntFieldUpdateOperationsInput | number
  }

  export type tiposervicoCreateManyInput = {
    id?: number
    descricao: string
    createdAt: Date | string
    updatedAt: Date | string
    valorCusto?: number
    valorVenda?: number
    ativo?: boolean
    observacao?: string | null
    usuario_cad?: number
    usuario_alt?: number
    idfornecedor?: number
  }

  export type tiposervicoUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    valorCusto?: FloatFieldUpdateOperationsInput | number
    valorVenda?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    usuario_cad?: IntFieldUpdateOperationsInput | number
    usuario_alt?: IntFieldUpdateOperationsInput | number
    idfornecedor?: IntFieldUpdateOperationsInput | number
  }

  export type tiposervicoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    valorCusto?: FloatFieldUpdateOperationsInput | number
    valorVenda?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    usuario_cad?: IntFieldUpdateOperationsInput | number
    usuario_alt?: IntFieldUpdateOperationsInput | number
    idfornecedor?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type bancosOrderByRelevanceInput = {
    fields: bancosOrderByRelevanceFieldEnum | bancosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type bancosIdCodbancoCompoundUniqueInput = {
    id: number
    codbanco: number
  }

  export type bancosCountOrderByAggregateInput = {
    id?: SortOrder
    codbanco?: SortOrder
    instituicao?: SortOrder
    segmento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type bancosAvgOrderByAggregateInput = {
    id?: SortOrder
    codbanco?: SortOrder
  }

  export type bancosMaxOrderByAggregateInput = {
    id?: SortOrder
    codbanco?: SortOrder
    instituicao?: SortOrder
    segmento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type bancosMinOrderByAggregateInput = {
    id?: SortOrder
    codbanco?: SortOrder
    instituicao?: SortOrder
    segmento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type bancosSumOrderByAggregateInput = {
    id?: SortOrder
    codbanco?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type configuracaoOrderByRelevanceInput = {
    fields: configuracaoOrderByRelevanceFieldEnum | configuracaoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type configuracaoCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type configuracaoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type configuracaoMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type configuracaoMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type configuracaoSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type consultasOrderByRelevanceInput = {
    fields: consultasOrderByRelevanceFieldEnum | consultasOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type consultasCountOrderByAggregateInput = {
    id?: SortOrder
    datahora?: SortOrder
    id_servico?: SortOrder
    beneficio?: SortOrder
    cpf?: SortOrder
    qtde?: SortOrder
    id_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tipotransacao?: SortOrder
    observacao?: SortOrder
    valor_unit?: SortOrder
    matricula_siape?: SortOrder
    tp_serv_origem?: SortOrder
    id_extrato_off?: SortOrder
    origem_sol?: SortOrder
  }

  export type consultasAvgOrderByAggregateInput = {
    id?: SortOrder
    id_servico?: SortOrder
    qtde?: SortOrder
    id_usuario?: SortOrder
    tipotransacao?: SortOrder
    valor_unit?: SortOrder
    tp_serv_origem?: SortOrder
    id_extrato_off?: SortOrder
    origem_sol?: SortOrder
  }

  export type consultasMaxOrderByAggregateInput = {
    id?: SortOrder
    datahora?: SortOrder
    id_servico?: SortOrder
    beneficio?: SortOrder
    cpf?: SortOrder
    qtde?: SortOrder
    id_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tipotransacao?: SortOrder
    observacao?: SortOrder
    valor_unit?: SortOrder
    matricula_siape?: SortOrder
    tp_serv_origem?: SortOrder
    id_extrato_off?: SortOrder
    origem_sol?: SortOrder
  }

  export type consultasMinOrderByAggregateInput = {
    id?: SortOrder
    datahora?: SortOrder
    id_servico?: SortOrder
    beneficio?: SortOrder
    cpf?: SortOrder
    qtde?: SortOrder
    id_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tipotransacao?: SortOrder
    observacao?: SortOrder
    valor_unit?: SortOrder
    matricula_siape?: SortOrder
    tp_serv_origem?: SortOrder
    id_extrato_off?: SortOrder
    origem_sol?: SortOrder
  }

  export type consultasSumOrderByAggregateInput = {
    id?: SortOrder
    id_servico?: SortOrder
    qtde?: SortOrder
    id_usuario?: SortOrder
    tipotransacao?: SortOrder
    valor_unit?: SortOrder
    tp_serv_origem?: SortOrder
    id_extrato_off?: SortOrder
    origem_sol?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type consultasofflineOrderByRelevanceInput = {
    fields: consultasofflineOrderByRelevanceFieldEnum | consultasofflineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type consultasofflineCountOrderByAggregateInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    erroID?: SortOrder
    idStatusSolicitacaoIn100?: SortOrder
    situacao?: SortOrder
    resultado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consultasofflineAvgOrderByAggregateInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    idStatusSolicitacaoIn100?: SortOrder
  }

  export type consultasofflineMaxOrderByAggregateInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    erroID?: SortOrder
    idStatusSolicitacaoIn100?: SortOrder
    situacao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consultasofflineMinOrderByAggregateInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    erroID?: SortOrder
    idStatusSolicitacaoIn100?: SortOrder
    situacao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consultasofflineSumOrderByAggregateInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    idStatusSolicitacaoIn100?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type consultasofflinesiapeOrderByRelevanceInput = {
    fields: consultasofflinesiapeOrderByRelevanceFieldEnum | consultasofflinesiapeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type consultasofflinesiapeCountOrderByAggregateInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    situacao?: SortOrder
    erroID?: SortOrder
    resultado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consultasofflinesiapeAvgOrderByAggregateInput = {
    id?: SortOrder
    idConsulta?: SortOrder
  }

  export type consultasofflinesiapeMaxOrderByAggregateInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    situacao?: SortOrder
    erroID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consultasofflinesiapeMinOrderByAggregateInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    situacao?: SortOrder
    erroID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type consultasofflinesiapeSumOrderByAggregateInput = {
    id?: SortOrder
    idConsulta?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type creditoCountOrderByAggregateInput = {
    id?: SortOrder
    datahora?: SortOrder
    valorun?: SortOrder
    vendedor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idusu_cli?: SortOrder
    tiposervico?: SortOrder
    qtdecreditos?: SortOrder
    qtderestante?: SortOrder
    qtdeutilizada?: SortOrder
  }

  export type creditoAvgOrderByAggregateInput = {
    id?: SortOrder
    valorun?: SortOrder
    vendedor?: SortOrder
    idusu_cli?: SortOrder
    tiposervico?: SortOrder
    qtdecreditos?: SortOrder
    qtderestante?: SortOrder
    qtdeutilizada?: SortOrder
  }

  export type creditoMaxOrderByAggregateInput = {
    id?: SortOrder
    datahora?: SortOrder
    valorun?: SortOrder
    vendedor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idusu_cli?: SortOrder
    tiposervico?: SortOrder
    qtdecreditos?: SortOrder
    qtderestante?: SortOrder
    qtdeutilizada?: SortOrder
  }

  export type creditoMinOrderByAggregateInput = {
    id?: SortOrder
    datahora?: SortOrder
    valorun?: SortOrder
    vendedor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idusu_cli?: SortOrder
    tiposervico?: SortOrder
    qtdecreditos?: SortOrder
    qtderestante?: SortOrder
    qtdeutilizada?: SortOrder
  }

  export type creditoSumOrderByAggregateInput = {
    id?: SortOrder
    valorun?: SortOrder
    vendedor?: SortOrder
    idusu_cli?: SortOrder
    tiposervico?: SortOrder
    qtdecreditos?: SortOrder
    qtderestante?: SortOrder
    qtdeutilizada?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type desbloqueiosOrderByRelevanceInput = {
    fields: desbloqueiosOrderByRelevanceFieldEnum | desbloqueiosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type desbloqueiosCountOrderByAggregateInput = {
    id?: SortOrder
    datahora?: SortOrder
    beneficio?: SortOrder
    cpf?: SortOrder
    protocolo?: SortOrder
    requerente?: SortOrder
    unidade?: SortOrder
    status?: SortOrder
    id_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_usu_desbloqueio?: SortOrder
    ddb?: SortOrder
  }

  export type desbloqueiosAvgOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    id_usuario?: SortOrder
    id_usu_desbloqueio?: SortOrder
  }

  export type desbloqueiosMaxOrderByAggregateInput = {
    id?: SortOrder
    datahora?: SortOrder
    beneficio?: SortOrder
    cpf?: SortOrder
    protocolo?: SortOrder
    requerente?: SortOrder
    unidade?: SortOrder
    status?: SortOrder
    id_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_usu_desbloqueio?: SortOrder
    ddb?: SortOrder
  }

  export type desbloqueiosMinOrderByAggregateInput = {
    id?: SortOrder
    datahora?: SortOrder
    beneficio?: SortOrder
    cpf?: SortOrder
    protocolo?: SortOrder
    requerente?: SortOrder
    unidade?: SortOrder
    status?: SortOrder
    id_usuario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id_usu_desbloqueio?: SortOrder
    ddb?: SortOrder
  }

  export type desbloqueiosSumOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    id_usuario?: SortOrder
    id_usu_desbloqueio?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type entrantesinssOrderByRelevanceInput = {
    fields: entrantesinssOrderByRelevanceFieldEnum | entrantesinssOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type entrantesinssCountOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    nome?: SortOrder
    nascimento?: SortOrder
    idade?: SortOrder
    beneficio?: SortOrder
    especie?: SortOrder
    salario?: SortOrder
    dib?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    fone?: SortOrder
    fone1?: SortOrder
    fone2?: SortOrder
    fone3?: SortOrder
    fone4?: SortOrder
    fone5?: SortOrder
    fone6?: SortOrder
    fone7?: SortOrder
    fone8?: SortOrder
    fone9?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type entrantesinssAvgOrderByAggregateInput = {
    id?: SortOrder
    idade?: SortOrder
    beneficio?: SortOrder
    especie?: SortOrder
    salario?: SortOrder
  }

  export type entrantesinssMaxOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    nome?: SortOrder
    nascimento?: SortOrder
    idade?: SortOrder
    beneficio?: SortOrder
    especie?: SortOrder
    salario?: SortOrder
    dib?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    fone?: SortOrder
    fone1?: SortOrder
    fone2?: SortOrder
    fone3?: SortOrder
    fone4?: SortOrder
    fone5?: SortOrder
    fone6?: SortOrder
    fone7?: SortOrder
    fone8?: SortOrder
    fone9?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type entrantesinssMinOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    nome?: SortOrder
    nascimento?: SortOrder
    idade?: SortOrder
    beneficio?: SortOrder
    especie?: SortOrder
    salario?: SortOrder
    dib?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    fone?: SortOrder
    fone1?: SortOrder
    fone2?: SortOrder
    fone3?: SortOrder
    fone4?: SortOrder
    fone5?: SortOrder
    fone6?: SortOrder
    fone7?: SortOrder
    fone8?: SortOrder
    fone9?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type entrantesinssSumOrderByAggregateInput = {
    id?: SortOrder
    idade?: SortOrder
    beneficio?: SortOrder
    especie?: SortOrder
    salario?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type especiebeneficioOrderByRelevanceInput = {
    fields: especiebeneficioOrderByRelevanceFieldEnum | especiebeneficioOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type especiebeneficioIdCodigoCompoundUniqueInput = {
    id: number
    codigo: number
  }

  export type especiebeneficioCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    descEspecieBeneficio?: SortOrder
    gruposEspecie?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type especiebeneficioAvgOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
  }

  export type especiebeneficioMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    descEspecieBeneficio?: SortOrder
    gruposEspecie?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type especiebeneficioMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    descEspecieBeneficio?: SortOrder
    gruposEspecie?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type especiebeneficioSumOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
  }

  export type extratoofflineOrderByRelevanceInput = {
    fields: extratoofflineOrderByRelevanceFieldEnum | extratoofflineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type extratoofflineCountOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    beneficio?: SortOrder
    jsonResult?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idFornecedor?: SortOrder
    idConsulta?: SortOrder
    idUsuario?: SortOrder
  }

  export type extratoofflineAvgOrderByAggregateInput = {
    id?: SortOrder
    idFornecedor?: SortOrder
    idConsulta?: SortOrder
    idUsuario?: SortOrder
  }

  export type extratoofflineMaxOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    beneficio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idFornecedor?: SortOrder
    idConsulta?: SortOrder
    idUsuario?: SortOrder
  }

  export type extratoofflineMinOrderByAggregateInput = {
    id?: SortOrder
    cpf?: SortOrder
    beneficio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idFornecedor?: SortOrder
    idConsulta?: SortOrder
    idUsuario?: SortOrder
  }

  export type extratoofflineSumOrderByAggregateInput = {
    id?: SortOrder
    idFornecedor?: SortOrder
    idConsulta?: SortOrder
    idUsuario?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type extratoonlineOrderByRelevanceInput = {
    fields: extratoonlineOrderByRelevanceFieldEnum | extratoonlineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type extratoonlineCountOrderByAggregateInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    id_fornecedor?: SortOrder
    beneficio?: SortOrder
    jsonResult?: SortOrder
    filePdf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isCache?: SortOrder
    statusConsulta?: SortOrder
    idConsultaOffline?: SortOrder
    errorResult?: SortOrder
    idUsuario?: SortOrder
  }

  export type extratoonlineAvgOrderByAggregateInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    id_fornecedor?: SortOrder
    statusConsulta?: SortOrder
    idConsultaOffline?: SortOrder
    idUsuario?: SortOrder
  }

  export type extratoonlineMaxOrderByAggregateInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    id_fornecedor?: SortOrder
    beneficio?: SortOrder
    filePdf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isCache?: SortOrder
    statusConsulta?: SortOrder
    idConsultaOffline?: SortOrder
    errorResult?: SortOrder
    idUsuario?: SortOrder
  }

  export type extratoonlineMinOrderByAggregateInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    id_fornecedor?: SortOrder
    beneficio?: SortOrder
    filePdf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isCache?: SortOrder
    statusConsulta?: SortOrder
    idConsultaOffline?: SortOrder
    errorResult?: SortOrder
    idUsuario?: SortOrder
  }

  export type extratoonlineSumOrderByAggregateInput = {
    id?: SortOrder
    idConsulta?: SortOrder
    id_fornecedor?: SortOrder
    statusConsulta?: SortOrder
    idConsultaOffline?: SortOrder
    idUsuario?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type fornecedorOrderByRelevanceInput = {
    fields: fornecedorOrderByRelevanceFieldEnum | fornecedorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type fornecedorCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    cnpj?: SortOrder
    logradouro?: SortOrder
    numero?: SortOrder
    complemento?: SortOrder
    cep?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    apikey?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    urlapi?: SortOrder
    usuarioApi?: SortOrder
    senhaApi?: SortOrder
    dataHoraValidacaoApiKey?: SortOrder
  }

  export type fornecedorAvgOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
  }

  export type fornecedorMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    cnpj?: SortOrder
    logradouro?: SortOrder
    numero?: SortOrder
    complemento?: SortOrder
    cep?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    apikey?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    urlapi?: SortOrder
    usuarioApi?: SortOrder
    senhaApi?: SortOrder
    dataHoraValidacaoApiKey?: SortOrder
  }

  export type fornecedorMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    cnpj?: SortOrder
    logradouro?: SortOrder
    numero?: SortOrder
    complemento?: SortOrder
    cep?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    apikey?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    urlapi?: SortOrder
    usuarioApi?: SortOrder
    senhaApi?: SortOrder
    dataHoraValidacaoApiKey?: SortOrder
  }

  export type fornecedorSumOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type fornecedorservicoCountOrderByAggregateInput = {
    id?: SortOrder
    idServico?: SortOrder
    idFornecedor?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type fornecedorservicoAvgOrderByAggregateInput = {
    id?: SortOrder
    idServico?: SortOrder
    idFornecedor?: SortOrder
  }

  export type fornecedorservicoMaxOrderByAggregateInput = {
    id?: SortOrder
    idServico?: SortOrder
    idFornecedor?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type fornecedorservicoMinOrderByAggregateInput = {
    id?: SortOrder
    idServico?: SortOrder
    idFornecedor?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type fornecedorservicoSumOrderByAggregateInput = {
    id?: SortOrder
    idServico?: SortOrder
    idFornecedor?: SortOrder
  }

  export type historicoconsultaapiOrderByRelevanceInput = {
    fields: historicoconsultaapiOrderByRelevanceFieldEnum | historicoconsultaapiOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type historicoconsultaapiCountOrderByAggregateInput = {
    id?: SortOrder
    idservico?: SortOrder
    idfornecedor?: SortOrder
    cpf?: SortOrder
    cpfRepresentanteLegal?: SortOrder
    beneficio?: SortOrder
    resultado?: SortOrder
    statusConsulta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type historicoconsultaapiAvgOrderByAggregateInput = {
    id?: SortOrder
    idservico?: SortOrder
    idfornecedor?: SortOrder
    statusConsulta?: SortOrder
  }

  export type historicoconsultaapiMaxOrderByAggregateInput = {
    id?: SortOrder
    idservico?: SortOrder
    idfornecedor?: SortOrder
    cpf?: SortOrder
    cpfRepresentanteLegal?: SortOrder
    beneficio?: SortOrder
    statusConsulta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type historicoconsultaapiMinOrderByAggregateInput = {
    id?: SortOrder
    idservico?: SortOrder
    idfornecedor?: SortOrder
    cpf?: SortOrder
    cpfRepresentanteLegal?: SortOrder
    beneficio?: SortOrder
    statusConsulta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type historicoconsultaapiSumOrderByAggregateInput = {
    id?: SortOrder
    idservico?: SortOrder
    idfornecedor?: SortOrder
    statusConsulta?: SortOrder
  }

  export type historicocreditoCountOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    tipoOperacao?: SortOrder
    quantidade?: SortOrder
    createdAt?: SortOrder
    idServico?: SortOrder
  }

  export type historicocreditoAvgOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    tipoOperacao?: SortOrder
    quantidade?: SortOrder
    idServico?: SortOrder
  }

  export type historicocreditoMaxOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    tipoOperacao?: SortOrder
    quantidade?: SortOrder
    createdAt?: SortOrder
    idServico?: SortOrder
  }

  export type historicocreditoMinOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    tipoOperacao?: SortOrder
    quantidade?: SortOrder
    createdAt?: SortOrder
    idServico?: SortOrder
  }

  export type historicocreditoSumOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    tipoOperacao?: SortOrder
    quantidade?: SortOrder
    idServico?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type in100OrderByRelevanceInput = {
    fields: in100OrderByRelevanceFieldEnum | in100OrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type in100CountOrderByAggregateInput = {
    id?: SortOrder
    idUsuario?: SortOrder
    idConsulta?: SortOrder
    idConsultaOffline?: SortOrder
    cpf?: SortOrder
    numeroBeneficio?: SortOrder
    situacao?: SortOrder
    requisicao?: SortOrder
    errorID?: SortOrder
    resultado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpfRepresentanteLegal?: SortOrder
    idFornecedor?: SortOrder
    idStatusSolicitacaoIn100?: SortOrder
    msgErro?: SortOrder
  }

  export type in100AvgOrderByAggregateInput = {
    id?: SortOrder
    idUsuario?: SortOrder
    idConsulta?: SortOrder
    idConsultaOffline?: SortOrder
    requisicao?: SortOrder
    idFornecedor?: SortOrder
    idStatusSolicitacaoIn100?: SortOrder
  }

  export type in100MaxOrderByAggregateInput = {
    id?: SortOrder
    idUsuario?: SortOrder
    idConsulta?: SortOrder
    idConsultaOffline?: SortOrder
    cpf?: SortOrder
    numeroBeneficio?: SortOrder
    situacao?: SortOrder
    requisicao?: SortOrder
    errorID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpfRepresentanteLegal?: SortOrder
    idFornecedor?: SortOrder
    idStatusSolicitacaoIn100?: SortOrder
    msgErro?: SortOrder
  }

  export type in100MinOrderByAggregateInput = {
    id?: SortOrder
    idUsuario?: SortOrder
    idConsulta?: SortOrder
    idConsultaOffline?: SortOrder
    cpf?: SortOrder
    numeroBeneficio?: SortOrder
    situacao?: SortOrder
    requisicao?: SortOrder
    errorID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpfRepresentanteLegal?: SortOrder
    idFornecedor?: SortOrder
    idStatusSolicitacaoIn100?: SortOrder
    msgErro?: SortOrder
  }

  export type in100SumOrderByAggregateInput = {
    id?: SortOrder
    idUsuario?: SortOrder
    idConsulta?: SortOrder
    idConsultaOffline?: SortOrder
    requisicao?: SortOrder
    idFornecedor?: SortOrder
    idStatusSolicitacaoIn100?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type PerfilusuarioScalarRelationFilter = {
    is?: perfilusuarioWhereInput
    isNot?: perfilusuarioWhereInput
  }

  export type loginsOrderByRelevanceInput = {
    fields: loginsOrderByRelevanceFieldEnum | loginsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type loginsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    user_name?: SortOrder
    active?: SortOrder
    password?: SortOrder
    idperfil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    usuarioAPi?: SortOrder
    chaveApi?: SortOrder
  }

  export type loginsAvgOrderByAggregateInput = {
    id?: SortOrder
    idperfil?: SortOrder
  }

  export type loginsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    user_name?: SortOrder
    active?: SortOrder
    password?: SortOrder
    idperfil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    usuarioAPi?: SortOrder
    chaveApi?: SortOrder
  }

  export type loginsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    user_name?: SortOrder
    active?: SortOrder
    password?: SortOrder
    idperfil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    usuarioAPi?: SortOrder
    chaveApi?: SortOrder
  }

  export type loginsSumOrderByAggregateInput = {
    id?: SortOrder
    idperfil?: SortOrder
  }

  export type menuOrderByRelevanceInput = {
    fields: menuOrderByRelevanceFieldEnum | menuOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type menuCountOrderByAggregateInput = {
    id?: SortOrder
    codsequencia?: SortOrder
    descricao?: SortOrder
    pagina?: SortOrder
    rota?: SortOrder
    idmodulo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    icone?: SortOrder
  }

  export type menuAvgOrderByAggregateInput = {
    id?: SortOrder
    codsequencia?: SortOrder
    idmodulo?: SortOrder
  }

  export type menuMaxOrderByAggregateInput = {
    id?: SortOrder
    codsequencia?: SortOrder
    descricao?: SortOrder
    pagina?: SortOrder
    rota?: SortOrder
    idmodulo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    icone?: SortOrder
  }

  export type menuMinOrderByAggregateInput = {
    id?: SortOrder
    codsequencia?: SortOrder
    descricao?: SortOrder
    pagina?: SortOrder
    rota?: SortOrder
    idmodulo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    icone?: SortOrder
  }

  export type menuSumOrderByAggregateInput = {
    id?: SortOrder
    codsequencia?: SortOrder
    idmodulo?: SortOrder
  }

  export type Perfil_moduloListRelationFilter = {
    every?: perfil_moduloWhereInput
    some?: perfil_moduloWhereInput
    none?: perfil_moduloWhereInput
  }

  export type perfil_moduloOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type modulosOrderByRelevanceInput = {
    fields: modulosOrderByRelevanceFieldEnum | modulosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type modulosCountOrderByAggregateInput = {
    id?: SortOrder
    desc_modulo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type modulosAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type modulosMaxOrderByAggregateInput = {
    id?: SortOrder
    desc_modulo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type modulosMinOrderByAggregateInput = {
    id?: SortOrder
    desc_modulo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type modulosSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ModulosScalarRelationFilter = {
    is?: modulosWhereInput
    isNot?: modulosWhereInput
  }

  export type perfil_moduloCountOrderByAggregateInput = {
    id?: SortOrder
    idperfil?: SortOrder
    idmodulo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type perfil_moduloAvgOrderByAggregateInput = {
    id?: SortOrder
    idperfil?: SortOrder
    idmodulo?: SortOrder
  }

  export type perfil_moduloMaxOrderByAggregateInput = {
    id?: SortOrder
    idperfil?: SortOrder
    idmodulo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type perfil_moduloMinOrderByAggregateInput = {
    id?: SortOrder
    idperfil?: SortOrder
    idmodulo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type perfil_moduloSumOrderByAggregateInput = {
    id?: SortOrder
    idperfil?: SortOrder
    idmodulo?: SortOrder
  }

  export type LoginsListRelationFilter = {
    every?: loginsWhereInput
    some?: loginsWhereInput
    none?: loginsWhereInput
  }

  export type loginsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type perfilusuarioOrderByRelevanceInput = {
    fields: perfilusuarioOrderByRelevanceFieldEnum | perfilusuarioOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type perfilusuarioCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type perfilusuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type perfilusuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type perfilusuarioMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type perfilusuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type senhasOrderByRelevanceInput = {
    fields: senhasOrderByRelevanceFieldEnum | senhasOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type senhasCountOrderByAggregateInput = {
    id?: SortOrder
    idusuario?: SortOrder
    senha?: SortOrder
    idretorno?: SortOrder
    observacao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpf?: SortOrder
    idusuario_atualizacao?: SortOrder
  }

  export type senhasAvgOrderByAggregateInput = {
    id?: SortOrder
    idusuario?: SortOrder
    idretorno?: SortOrder
    idusuario_atualizacao?: SortOrder
  }

  export type senhasMaxOrderByAggregateInput = {
    id?: SortOrder
    idusuario?: SortOrder
    senha?: SortOrder
    idretorno?: SortOrder
    observacao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpf?: SortOrder
    idusuario_atualizacao?: SortOrder
  }

  export type senhasMinOrderByAggregateInput = {
    id?: SortOrder
    idusuario?: SortOrder
    senha?: SortOrder
    idretorno?: SortOrder
    observacao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpf?: SortOrder
    idusuario_atualizacao?: SortOrder
  }

  export type senhasSumOrderByAggregateInput = {
    id?: SortOrder
    idusuario?: SortOrder
    idretorno?: SortOrder
    idusuario_atualizacao?: SortOrder
  }

  export type situacaoOrderByRelevanceInput = {
    fields: situacaoOrderByRelevanceFieldEnum | situacaoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type situacaoCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    icone?: SortOrder
    cor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    formsolicitar?: SortOrder
  }

  export type situacaoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type situacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    icone?: SortOrder
    cor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    formsolicitar?: SortOrder
  }

  export type situacaoMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    icone?: SortOrder
    cor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    formsolicitar?: SortOrder
  }

  export type situacaoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type situacaosolicsenhaOrderByRelevanceInput = {
    fields: situacaosolicsenhaOrderByRelevanceFieldEnum | situacaosolicsenhaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type situacaosolicsenhaCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telaSolicitar?: SortOrder
    telaAtualizar?: SortOrder
  }

  export type situacaosolicsenhaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type situacaosolicsenhaMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telaSolicitar?: SortOrder
    telaAtualizar?: SortOrder
  }

  export type situacaosolicsenhaMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    telaSolicitar?: SortOrder
    telaAtualizar?: SortOrder
  }

  export type situacaosolicsenhaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type statussolicitacaoservicoOrderByRelevanceInput = {
    fields: statussolicitacaoservicoOrderByRelevanceFieldEnum | statussolicitacaoservicoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type statussolicitacaoservicoCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type statussolicitacaoservicoAvgOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
  }

  export type statussolicitacaoservicoMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type statussolicitacaoservicoMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type statussolicitacaoservicoSumOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
  }

  export type tiposervicoOrderByRelevanceInput = {
    fields: tiposervicoOrderByRelevanceFieldEnum | tiposervicoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tiposervicoCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    valorCusto?: SortOrder
    valorVenda?: SortOrder
    ativo?: SortOrder
    observacao?: SortOrder
    usuario_cad?: SortOrder
    usuario_alt?: SortOrder
    idfornecedor?: SortOrder
  }

  export type tiposervicoAvgOrderByAggregateInput = {
    id?: SortOrder
    valorCusto?: SortOrder
    valorVenda?: SortOrder
    usuario_cad?: SortOrder
    usuario_alt?: SortOrder
    idfornecedor?: SortOrder
  }

  export type tiposervicoMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    valorCusto?: SortOrder
    valorVenda?: SortOrder
    ativo?: SortOrder
    observacao?: SortOrder
    usuario_cad?: SortOrder
    usuario_alt?: SortOrder
    idfornecedor?: SortOrder
  }

  export type tiposervicoMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    valorCusto?: SortOrder
    valorVenda?: SortOrder
    ativo?: SortOrder
    observacao?: SortOrder
    usuario_cad?: SortOrder
    usuario_alt?: SortOrder
    idfornecedor?: SortOrder
  }

  export type tiposervicoSumOrderByAggregateInput = {
    id?: SortOrder
    valorCusto?: SortOrder
    valorVenda?: SortOrder
    usuario_cad?: SortOrder
    usuario_alt?: SortOrder
    idfornecedor?: SortOrder
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type perfilusuarioCreateNestedOneWithoutLoginsInput = {
    create?: XOR<perfilusuarioCreateWithoutLoginsInput, perfilusuarioUncheckedCreateWithoutLoginsInput>
    connectOrCreate?: perfilusuarioCreateOrConnectWithoutLoginsInput
    connect?: perfilusuarioWhereUniqueInput
  }

  export type perfilusuarioUpdateOneRequiredWithoutLoginsNestedInput = {
    create?: XOR<perfilusuarioCreateWithoutLoginsInput, perfilusuarioUncheckedCreateWithoutLoginsInput>
    connectOrCreate?: perfilusuarioCreateOrConnectWithoutLoginsInput
    upsert?: perfilusuarioUpsertWithoutLoginsInput
    connect?: perfilusuarioWhereUniqueInput
    update?: XOR<XOR<perfilusuarioUpdateToOneWithWhereWithoutLoginsInput, perfilusuarioUpdateWithoutLoginsInput>, perfilusuarioUncheckedUpdateWithoutLoginsInput>
  }

  export type perfil_moduloCreateNestedManyWithoutModuloInput = {
    create?: XOR<perfil_moduloCreateWithoutModuloInput, perfil_moduloUncheckedCreateWithoutModuloInput> | perfil_moduloCreateWithoutModuloInput[] | perfil_moduloUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: perfil_moduloCreateOrConnectWithoutModuloInput | perfil_moduloCreateOrConnectWithoutModuloInput[]
    createMany?: perfil_moduloCreateManyModuloInputEnvelope
    connect?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
  }

  export type perfil_moduloUncheckedCreateNestedManyWithoutModuloInput = {
    create?: XOR<perfil_moduloCreateWithoutModuloInput, perfil_moduloUncheckedCreateWithoutModuloInput> | perfil_moduloCreateWithoutModuloInput[] | perfil_moduloUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: perfil_moduloCreateOrConnectWithoutModuloInput | perfil_moduloCreateOrConnectWithoutModuloInput[]
    createMany?: perfil_moduloCreateManyModuloInputEnvelope
    connect?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
  }

  export type perfil_moduloUpdateManyWithoutModuloNestedInput = {
    create?: XOR<perfil_moduloCreateWithoutModuloInput, perfil_moduloUncheckedCreateWithoutModuloInput> | perfil_moduloCreateWithoutModuloInput[] | perfil_moduloUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: perfil_moduloCreateOrConnectWithoutModuloInput | perfil_moduloCreateOrConnectWithoutModuloInput[]
    upsert?: perfil_moduloUpsertWithWhereUniqueWithoutModuloInput | perfil_moduloUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: perfil_moduloCreateManyModuloInputEnvelope
    set?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    disconnect?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    delete?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    connect?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    update?: perfil_moduloUpdateWithWhereUniqueWithoutModuloInput | perfil_moduloUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: perfil_moduloUpdateManyWithWhereWithoutModuloInput | perfil_moduloUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: perfil_moduloScalarWhereInput | perfil_moduloScalarWhereInput[]
  }

  export type perfil_moduloUncheckedUpdateManyWithoutModuloNestedInput = {
    create?: XOR<perfil_moduloCreateWithoutModuloInput, perfil_moduloUncheckedCreateWithoutModuloInput> | perfil_moduloCreateWithoutModuloInput[] | perfil_moduloUncheckedCreateWithoutModuloInput[]
    connectOrCreate?: perfil_moduloCreateOrConnectWithoutModuloInput | perfil_moduloCreateOrConnectWithoutModuloInput[]
    upsert?: perfil_moduloUpsertWithWhereUniqueWithoutModuloInput | perfil_moduloUpsertWithWhereUniqueWithoutModuloInput[]
    createMany?: perfil_moduloCreateManyModuloInputEnvelope
    set?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    disconnect?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    delete?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    connect?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    update?: perfil_moduloUpdateWithWhereUniqueWithoutModuloInput | perfil_moduloUpdateWithWhereUniqueWithoutModuloInput[]
    updateMany?: perfil_moduloUpdateManyWithWhereWithoutModuloInput | perfil_moduloUpdateManyWithWhereWithoutModuloInput[]
    deleteMany?: perfil_moduloScalarWhereInput | perfil_moduloScalarWhereInput[]
  }

  export type perfilusuarioCreateNestedOneWithoutPerfilXmodulosInput = {
    create?: XOR<perfilusuarioCreateWithoutPerfilXmodulosInput, perfilusuarioUncheckedCreateWithoutPerfilXmodulosInput>
    connectOrCreate?: perfilusuarioCreateOrConnectWithoutPerfilXmodulosInput
    connect?: perfilusuarioWhereUniqueInput
  }

  export type modulosCreateNestedOneWithoutPerfilXmodulosInput = {
    create?: XOR<modulosCreateWithoutPerfilXmodulosInput, modulosUncheckedCreateWithoutPerfilXmodulosInput>
    connectOrCreate?: modulosCreateOrConnectWithoutPerfilXmodulosInput
    connect?: modulosWhereUniqueInput
  }

  export type perfilusuarioUpdateOneRequiredWithoutPerfilXmodulosNestedInput = {
    create?: XOR<perfilusuarioCreateWithoutPerfilXmodulosInput, perfilusuarioUncheckedCreateWithoutPerfilXmodulosInput>
    connectOrCreate?: perfilusuarioCreateOrConnectWithoutPerfilXmodulosInput
    upsert?: perfilusuarioUpsertWithoutPerfilXmodulosInput
    connect?: perfilusuarioWhereUniqueInput
    update?: XOR<XOR<perfilusuarioUpdateToOneWithWhereWithoutPerfilXmodulosInput, perfilusuarioUpdateWithoutPerfilXmodulosInput>, perfilusuarioUncheckedUpdateWithoutPerfilXmodulosInput>
  }

  export type modulosUpdateOneRequiredWithoutPerfilXmodulosNestedInput = {
    create?: XOR<modulosCreateWithoutPerfilXmodulosInput, modulosUncheckedCreateWithoutPerfilXmodulosInput>
    connectOrCreate?: modulosCreateOrConnectWithoutPerfilXmodulosInput
    upsert?: modulosUpsertWithoutPerfilXmodulosInput
    connect?: modulosWhereUniqueInput
    update?: XOR<XOR<modulosUpdateToOneWithWhereWithoutPerfilXmodulosInput, modulosUpdateWithoutPerfilXmodulosInput>, modulosUncheckedUpdateWithoutPerfilXmodulosInput>
  }

  export type loginsCreateNestedManyWithoutPerfilInput = {
    create?: XOR<loginsCreateWithoutPerfilInput, loginsUncheckedCreateWithoutPerfilInput> | loginsCreateWithoutPerfilInput[] | loginsUncheckedCreateWithoutPerfilInput[]
    connectOrCreate?: loginsCreateOrConnectWithoutPerfilInput | loginsCreateOrConnectWithoutPerfilInput[]
    createMany?: loginsCreateManyPerfilInputEnvelope
    connect?: loginsWhereUniqueInput | loginsWhereUniqueInput[]
  }

  export type perfil_moduloCreateNestedManyWithoutPerfilInput = {
    create?: XOR<perfil_moduloCreateWithoutPerfilInput, perfil_moduloUncheckedCreateWithoutPerfilInput> | perfil_moduloCreateWithoutPerfilInput[] | perfil_moduloUncheckedCreateWithoutPerfilInput[]
    connectOrCreate?: perfil_moduloCreateOrConnectWithoutPerfilInput | perfil_moduloCreateOrConnectWithoutPerfilInput[]
    createMany?: perfil_moduloCreateManyPerfilInputEnvelope
    connect?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
  }

  export type loginsUncheckedCreateNestedManyWithoutPerfilInput = {
    create?: XOR<loginsCreateWithoutPerfilInput, loginsUncheckedCreateWithoutPerfilInput> | loginsCreateWithoutPerfilInput[] | loginsUncheckedCreateWithoutPerfilInput[]
    connectOrCreate?: loginsCreateOrConnectWithoutPerfilInput | loginsCreateOrConnectWithoutPerfilInput[]
    createMany?: loginsCreateManyPerfilInputEnvelope
    connect?: loginsWhereUniqueInput | loginsWhereUniqueInput[]
  }

  export type perfil_moduloUncheckedCreateNestedManyWithoutPerfilInput = {
    create?: XOR<perfil_moduloCreateWithoutPerfilInput, perfil_moduloUncheckedCreateWithoutPerfilInput> | perfil_moduloCreateWithoutPerfilInput[] | perfil_moduloUncheckedCreateWithoutPerfilInput[]
    connectOrCreate?: perfil_moduloCreateOrConnectWithoutPerfilInput | perfil_moduloCreateOrConnectWithoutPerfilInput[]
    createMany?: perfil_moduloCreateManyPerfilInputEnvelope
    connect?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
  }

  export type loginsUpdateManyWithoutPerfilNestedInput = {
    create?: XOR<loginsCreateWithoutPerfilInput, loginsUncheckedCreateWithoutPerfilInput> | loginsCreateWithoutPerfilInput[] | loginsUncheckedCreateWithoutPerfilInput[]
    connectOrCreate?: loginsCreateOrConnectWithoutPerfilInput | loginsCreateOrConnectWithoutPerfilInput[]
    upsert?: loginsUpsertWithWhereUniqueWithoutPerfilInput | loginsUpsertWithWhereUniqueWithoutPerfilInput[]
    createMany?: loginsCreateManyPerfilInputEnvelope
    set?: loginsWhereUniqueInput | loginsWhereUniqueInput[]
    disconnect?: loginsWhereUniqueInput | loginsWhereUniqueInput[]
    delete?: loginsWhereUniqueInput | loginsWhereUniqueInput[]
    connect?: loginsWhereUniqueInput | loginsWhereUniqueInput[]
    update?: loginsUpdateWithWhereUniqueWithoutPerfilInput | loginsUpdateWithWhereUniqueWithoutPerfilInput[]
    updateMany?: loginsUpdateManyWithWhereWithoutPerfilInput | loginsUpdateManyWithWhereWithoutPerfilInput[]
    deleteMany?: loginsScalarWhereInput | loginsScalarWhereInput[]
  }

  export type perfil_moduloUpdateManyWithoutPerfilNestedInput = {
    create?: XOR<perfil_moduloCreateWithoutPerfilInput, perfil_moduloUncheckedCreateWithoutPerfilInput> | perfil_moduloCreateWithoutPerfilInput[] | perfil_moduloUncheckedCreateWithoutPerfilInput[]
    connectOrCreate?: perfil_moduloCreateOrConnectWithoutPerfilInput | perfil_moduloCreateOrConnectWithoutPerfilInput[]
    upsert?: perfil_moduloUpsertWithWhereUniqueWithoutPerfilInput | perfil_moduloUpsertWithWhereUniqueWithoutPerfilInput[]
    createMany?: perfil_moduloCreateManyPerfilInputEnvelope
    set?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    disconnect?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    delete?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    connect?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    update?: perfil_moduloUpdateWithWhereUniqueWithoutPerfilInput | perfil_moduloUpdateWithWhereUniqueWithoutPerfilInput[]
    updateMany?: perfil_moduloUpdateManyWithWhereWithoutPerfilInput | perfil_moduloUpdateManyWithWhereWithoutPerfilInput[]
    deleteMany?: perfil_moduloScalarWhereInput | perfil_moduloScalarWhereInput[]
  }

  export type loginsUncheckedUpdateManyWithoutPerfilNestedInput = {
    create?: XOR<loginsCreateWithoutPerfilInput, loginsUncheckedCreateWithoutPerfilInput> | loginsCreateWithoutPerfilInput[] | loginsUncheckedCreateWithoutPerfilInput[]
    connectOrCreate?: loginsCreateOrConnectWithoutPerfilInput | loginsCreateOrConnectWithoutPerfilInput[]
    upsert?: loginsUpsertWithWhereUniqueWithoutPerfilInput | loginsUpsertWithWhereUniqueWithoutPerfilInput[]
    createMany?: loginsCreateManyPerfilInputEnvelope
    set?: loginsWhereUniqueInput | loginsWhereUniqueInput[]
    disconnect?: loginsWhereUniqueInput | loginsWhereUniqueInput[]
    delete?: loginsWhereUniqueInput | loginsWhereUniqueInput[]
    connect?: loginsWhereUniqueInput | loginsWhereUniqueInput[]
    update?: loginsUpdateWithWhereUniqueWithoutPerfilInput | loginsUpdateWithWhereUniqueWithoutPerfilInput[]
    updateMany?: loginsUpdateManyWithWhereWithoutPerfilInput | loginsUpdateManyWithWhereWithoutPerfilInput[]
    deleteMany?: loginsScalarWhereInput | loginsScalarWhereInput[]
  }

  export type perfil_moduloUncheckedUpdateManyWithoutPerfilNestedInput = {
    create?: XOR<perfil_moduloCreateWithoutPerfilInput, perfil_moduloUncheckedCreateWithoutPerfilInput> | perfil_moduloCreateWithoutPerfilInput[] | perfil_moduloUncheckedCreateWithoutPerfilInput[]
    connectOrCreate?: perfil_moduloCreateOrConnectWithoutPerfilInput | perfil_moduloCreateOrConnectWithoutPerfilInput[]
    upsert?: perfil_moduloUpsertWithWhereUniqueWithoutPerfilInput | perfil_moduloUpsertWithWhereUniqueWithoutPerfilInput[]
    createMany?: perfil_moduloCreateManyPerfilInputEnvelope
    set?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    disconnect?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    delete?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    connect?: perfil_moduloWhereUniqueInput | perfil_moduloWhereUniqueInput[]
    update?: perfil_moduloUpdateWithWhereUniqueWithoutPerfilInput | perfil_moduloUpdateWithWhereUniqueWithoutPerfilInput[]
    updateMany?: perfil_moduloUpdateManyWithWhereWithoutPerfilInput | perfil_moduloUpdateManyWithWhereWithoutPerfilInput[]
    deleteMany?: perfil_moduloScalarWhereInput | perfil_moduloScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type perfilusuarioCreateWithoutLoginsInput = {
    descricao: string
    perfilXmodulos?: perfil_moduloCreateNestedManyWithoutPerfilInput
  }

  export type perfilusuarioUncheckedCreateWithoutLoginsInput = {
    id?: number
    descricao: string
    perfilXmodulos?: perfil_moduloUncheckedCreateNestedManyWithoutPerfilInput
  }

  export type perfilusuarioCreateOrConnectWithoutLoginsInput = {
    where: perfilusuarioWhereUniqueInput
    create: XOR<perfilusuarioCreateWithoutLoginsInput, perfilusuarioUncheckedCreateWithoutLoginsInput>
  }

  export type perfilusuarioUpsertWithoutLoginsInput = {
    update: XOR<perfilusuarioUpdateWithoutLoginsInput, perfilusuarioUncheckedUpdateWithoutLoginsInput>
    create: XOR<perfilusuarioCreateWithoutLoginsInput, perfilusuarioUncheckedCreateWithoutLoginsInput>
    where?: perfilusuarioWhereInput
  }

  export type perfilusuarioUpdateToOneWithWhereWithoutLoginsInput = {
    where?: perfilusuarioWhereInput
    data: XOR<perfilusuarioUpdateWithoutLoginsInput, perfilusuarioUncheckedUpdateWithoutLoginsInput>
  }

  export type perfilusuarioUpdateWithoutLoginsInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    perfilXmodulos?: perfil_moduloUpdateManyWithoutPerfilNestedInput
  }

  export type perfilusuarioUncheckedUpdateWithoutLoginsInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    perfilXmodulos?: perfil_moduloUncheckedUpdateManyWithoutPerfilNestedInput
  }

  export type perfil_moduloCreateWithoutModuloInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    perfil: perfilusuarioCreateNestedOneWithoutPerfilXmodulosInput
  }

  export type perfil_moduloUncheckedCreateWithoutModuloInput = {
    id?: number
    idperfil: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type perfil_moduloCreateOrConnectWithoutModuloInput = {
    where: perfil_moduloWhereUniqueInput
    create: XOR<perfil_moduloCreateWithoutModuloInput, perfil_moduloUncheckedCreateWithoutModuloInput>
  }

  export type perfil_moduloCreateManyModuloInputEnvelope = {
    data: perfil_moduloCreateManyModuloInput | perfil_moduloCreateManyModuloInput[]
    skipDuplicates?: boolean
  }

  export type perfil_moduloUpsertWithWhereUniqueWithoutModuloInput = {
    where: perfil_moduloWhereUniqueInput
    update: XOR<perfil_moduloUpdateWithoutModuloInput, perfil_moduloUncheckedUpdateWithoutModuloInput>
    create: XOR<perfil_moduloCreateWithoutModuloInput, perfil_moduloUncheckedCreateWithoutModuloInput>
  }

  export type perfil_moduloUpdateWithWhereUniqueWithoutModuloInput = {
    where: perfil_moduloWhereUniqueInput
    data: XOR<perfil_moduloUpdateWithoutModuloInput, perfil_moduloUncheckedUpdateWithoutModuloInput>
  }

  export type perfil_moduloUpdateManyWithWhereWithoutModuloInput = {
    where: perfil_moduloScalarWhereInput
    data: XOR<perfil_moduloUpdateManyMutationInput, perfil_moduloUncheckedUpdateManyWithoutModuloInput>
  }

  export type perfil_moduloScalarWhereInput = {
    AND?: perfil_moduloScalarWhereInput | perfil_moduloScalarWhereInput[]
    OR?: perfil_moduloScalarWhereInput[]
    NOT?: perfil_moduloScalarWhereInput | perfil_moduloScalarWhereInput[]
    id?: IntFilter<"perfil_modulo"> | number
    idperfil?: IntFilter<"perfil_modulo"> | number
    idmodulo?: IntFilter<"perfil_modulo"> | number
    createdAt?: DateTimeFilter<"perfil_modulo"> | Date | string
    updatedAt?: DateTimeFilter<"perfil_modulo"> | Date | string
  }

  export type perfilusuarioCreateWithoutPerfilXmodulosInput = {
    descricao: string
    logins?: loginsCreateNestedManyWithoutPerfilInput
  }

  export type perfilusuarioUncheckedCreateWithoutPerfilXmodulosInput = {
    id?: number
    descricao: string
    logins?: loginsUncheckedCreateNestedManyWithoutPerfilInput
  }

  export type perfilusuarioCreateOrConnectWithoutPerfilXmodulosInput = {
    where: perfilusuarioWhereUniqueInput
    create: XOR<perfilusuarioCreateWithoutPerfilXmodulosInput, perfilusuarioUncheckedCreateWithoutPerfilXmodulosInput>
  }

  export type modulosCreateWithoutPerfilXmodulosInput = {
    desc_modulo: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type modulosUncheckedCreateWithoutPerfilXmodulosInput = {
    id?: number
    desc_modulo: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type modulosCreateOrConnectWithoutPerfilXmodulosInput = {
    where: modulosWhereUniqueInput
    create: XOR<modulosCreateWithoutPerfilXmodulosInput, modulosUncheckedCreateWithoutPerfilXmodulosInput>
  }

  export type perfilusuarioUpsertWithoutPerfilXmodulosInput = {
    update: XOR<perfilusuarioUpdateWithoutPerfilXmodulosInput, perfilusuarioUncheckedUpdateWithoutPerfilXmodulosInput>
    create: XOR<perfilusuarioCreateWithoutPerfilXmodulosInput, perfilusuarioUncheckedCreateWithoutPerfilXmodulosInput>
    where?: perfilusuarioWhereInput
  }

  export type perfilusuarioUpdateToOneWithWhereWithoutPerfilXmodulosInput = {
    where?: perfilusuarioWhereInput
    data: XOR<perfilusuarioUpdateWithoutPerfilXmodulosInput, perfilusuarioUncheckedUpdateWithoutPerfilXmodulosInput>
  }

  export type perfilusuarioUpdateWithoutPerfilXmodulosInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    logins?: loginsUpdateManyWithoutPerfilNestedInput
  }

  export type perfilusuarioUncheckedUpdateWithoutPerfilXmodulosInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    logins?: loginsUncheckedUpdateManyWithoutPerfilNestedInput
  }

  export type modulosUpsertWithoutPerfilXmodulosInput = {
    update: XOR<modulosUpdateWithoutPerfilXmodulosInput, modulosUncheckedUpdateWithoutPerfilXmodulosInput>
    create: XOR<modulosCreateWithoutPerfilXmodulosInput, modulosUncheckedCreateWithoutPerfilXmodulosInput>
    where?: modulosWhereInput
  }

  export type modulosUpdateToOneWithWhereWithoutPerfilXmodulosInput = {
    where?: modulosWhereInput
    data: XOR<modulosUpdateWithoutPerfilXmodulosInput, modulosUncheckedUpdateWithoutPerfilXmodulosInput>
  }

  export type modulosUpdateWithoutPerfilXmodulosInput = {
    desc_modulo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type modulosUncheckedUpdateWithoutPerfilXmodulosInput = {
    id?: IntFieldUpdateOperationsInput | number
    desc_modulo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loginsCreateWithoutPerfilInput = {
    name: string
    user_name: string
    active: boolean
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cpf: string
    email: string
    telefone: string
    usuarioAPi: boolean
    chaveApi: string
  }

  export type loginsUncheckedCreateWithoutPerfilInput = {
    id?: number
    name: string
    user_name: string
    active: boolean
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cpf: string
    email: string
    telefone: string
    usuarioAPi: boolean
    chaveApi: string
  }

  export type loginsCreateOrConnectWithoutPerfilInput = {
    where: loginsWhereUniqueInput
    create: XOR<loginsCreateWithoutPerfilInput, loginsUncheckedCreateWithoutPerfilInput>
  }

  export type loginsCreateManyPerfilInputEnvelope = {
    data: loginsCreateManyPerfilInput | loginsCreateManyPerfilInput[]
    skipDuplicates?: boolean
  }

  export type perfil_moduloCreateWithoutPerfilInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    modulo: modulosCreateNestedOneWithoutPerfilXmodulosInput
  }

  export type perfil_moduloUncheckedCreateWithoutPerfilInput = {
    id?: number
    idmodulo: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type perfil_moduloCreateOrConnectWithoutPerfilInput = {
    where: perfil_moduloWhereUniqueInput
    create: XOR<perfil_moduloCreateWithoutPerfilInput, perfil_moduloUncheckedCreateWithoutPerfilInput>
  }

  export type perfil_moduloCreateManyPerfilInputEnvelope = {
    data: perfil_moduloCreateManyPerfilInput | perfil_moduloCreateManyPerfilInput[]
    skipDuplicates?: boolean
  }

  export type loginsUpsertWithWhereUniqueWithoutPerfilInput = {
    where: loginsWhereUniqueInput
    update: XOR<loginsUpdateWithoutPerfilInput, loginsUncheckedUpdateWithoutPerfilInput>
    create: XOR<loginsCreateWithoutPerfilInput, loginsUncheckedCreateWithoutPerfilInput>
  }

  export type loginsUpdateWithWhereUniqueWithoutPerfilInput = {
    where: loginsWhereUniqueInput
    data: XOR<loginsUpdateWithoutPerfilInput, loginsUncheckedUpdateWithoutPerfilInput>
  }

  export type loginsUpdateManyWithWhereWithoutPerfilInput = {
    where: loginsScalarWhereInput
    data: XOR<loginsUpdateManyMutationInput, loginsUncheckedUpdateManyWithoutPerfilInput>
  }

  export type loginsScalarWhereInput = {
    AND?: loginsScalarWhereInput | loginsScalarWhereInput[]
    OR?: loginsScalarWhereInput[]
    NOT?: loginsScalarWhereInput | loginsScalarWhereInput[]
    id?: IntFilter<"logins"> | number
    name?: StringFilter<"logins"> | string
    user_name?: StringFilter<"logins"> | string
    active?: BoolFilter<"logins"> | boolean
    password?: StringFilter<"logins"> | string
    idperfil?: IntFilter<"logins"> | number
    createdAt?: DateTimeFilter<"logins"> | Date | string
    updatedAt?: DateTimeFilter<"logins"> | Date | string
    cpf?: StringFilter<"logins"> | string
    email?: StringFilter<"logins"> | string
    telefone?: StringFilter<"logins"> | string
    usuarioAPi?: BoolFilter<"logins"> | boolean
    chaveApi?: StringFilter<"logins"> | string
  }

  export type perfil_moduloUpsertWithWhereUniqueWithoutPerfilInput = {
    where: perfil_moduloWhereUniqueInput
    update: XOR<perfil_moduloUpdateWithoutPerfilInput, perfil_moduloUncheckedUpdateWithoutPerfilInput>
    create: XOR<perfil_moduloCreateWithoutPerfilInput, perfil_moduloUncheckedCreateWithoutPerfilInput>
  }

  export type perfil_moduloUpdateWithWhereUniqueWithoutPerfilInput = {
    where: perfil_moduloWhereUniqueInput
    data: XOR<perfil_moduloUpdateWithoutPerfilInput, perfil_moduloUncheckedUpdateWithoutPerfilInput>
  }

  export type perfil_moduloUpdateManyWithWhereWithoutPerfilInput = {
    where: perfil_moduloScalarWhereInput
    data: XOR<perfil_moduloUpdateManyMutationInput, perfil_moduloUncheckedUpdateManyWithoutPerfilInput>
  }

  export type perfil_moduloCreateManyModuloInput = {
    id?: number
    idperfil: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type perfil_moduloUpdateWithoutModuloInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    perfil?: perfilusuarioUpdateOneRequiredWithoutPerfilXmodulosNestedInput
  }

  export type perfil_moduloUncheckedUpdateWithoutModuloInput = {
    id?: IntFieldUpdateOperationsInput | number
    idperfil?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type perfil_moduloUncheckedUpdateManyWithoutModuloInput = {
    id?: IntFieldUpdateOperationsInput | number
    idperfil?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loginsCreateManyPerfilInput = {
    id?: number
    name: string
    user_name: string
    active: boolean
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cpf: string
    email: string
    telefone: string
    usuarioAPi: boolean
    chaveApi: string
  }

  export type perfil_moduloCreateManyPerfilInput = {
    id?: number
    idmodulo: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type loginsUpdateWithoutPerfilInput = {
    name?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    usuarioAPi?: BoolFieldUpdateOperationsInput | boolean
    chaveApi?: StringFieldUpdateOperationsInput | string
  }

  export type loginsUncheckedUpdateWithoutPerfilInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    usuarioAPi?: BoolFieldUpdateOperationsInput | boolean
    chaveApi?: StringFieldUpdateOperationsInput | string
  }

  export type loginsUncheckedUpdateManyWithoutPerfilInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpf?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefone?: StringFieldUpdateOperationsInput | string
    usuarioAPi?: BoolFieldUpdateOperationsInput | boolean
    chaveApi?: StringFieldUpdateOperationsInput | string
  }

  export type perfil_moduloUpdateWithoutPerfilInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modulo?: modulosUpdateOneRequiredWithoutPerfilXmodulosNestedInput
  }

  export type perfil_moduloUncheckedUpdateWithoutPerfilInput = {
    id?: IntFieldUpdateOperationsInput | number
    idmodulo?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type perfil_moduloUncheckedUpdateManyWithoutPerfilInput = {
    id?: IntFieldUpdateOperationsInput | number
    idmodulo?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}